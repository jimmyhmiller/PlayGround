// fn id : (x: t) -> t {
//   x
// }

// fn first : (a: a, b: b) -> a {
//   a
// }

fn len : (xs: List(t)) -> u32 {
  let mut count = 0;
  let mut current = xs;
  loop {
    if current == [] {
      break;
    }
    count = count + 1;
    current = tail(current);
  }
  count
}

// fn sum : (xs: List(i32)) -> i32 {
//   let mut total = 0;
//   let mut current = xs;
//   loop {
//     if current == [] {
//       break;
//     }
//     total = total + head(current);
//     current = tail(current);
//   }
//   total
// }

// fn map : (f: (a) -> b, xs: List(a)) -> List(b) {
//   let mut acc = [];
//   let mut current = xs;
//   loop {
//     if current == [] {
//       break;
//     }
//     let value = f(head(current));
//     acc = acc + [value];
//     current = tail(current);
//   }
//   acc
// }

// fn option_map : (f: (a) -> b, o: Option(a)) -> Option(b) {
//   if o == None {
//     None
//   } else {
//     Some(f(unwrap(o)))
//   }
// }

// fn zip : (as: List(a), bs: List(b)) -> List((a, b)) {
//   let mut acc = [];
//   let mut a_current = as;
//   let mut b_current = bs;
//   loop {
//     if a_current == [] || b_current == [] {
//       break;
//     }
//     let pair = (head(a_current), head(b_current));
//     acc = acc + [pair];
//     a_current = tail(a_current);
//     b_current = tail(b_current);
//   }
//   acc
// }

// fn compose : (f: (b) -> c, g: (a) -> b) -> ((a) -> c) {
//   x => f(g(x))
// }

// fn reverse : (xs: List(t)) -> List(t) {
//   let mut acc = [];
//   let mut current = xs;
//   loop {
//     if current == [] {
//       break;
//     }
//     acc = [head(current)] + acc;
//     current = tail(current);
//   }
//   acc
// }

// fn get_or_else : (o: Option(t), fallback: t) -> t {
//   if o == None {
//     fallback
//   } else {
//     unwrap(o)
//   }
// }

// struct Point {
//   x: int,
//   y: int
// }

// struct GenericPoint(x: Type, y: Type) {
//   x: x,
//   y: y
// }
