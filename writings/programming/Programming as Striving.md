# Programming as Striving

Peter Naur in his essay “Programming as Theory Building” offered us an analysis of what programming is. Perhaps analysis isn’t quite the right term. What Naur offered was not critieria jointly necessary and sufficient for an activity to count as programming. In fact, it is hard to know what to make of Naur’s characterization. In one guise he seems to be offering a necessary criteria. Programming must be theory building in order to properly be the activity it is. On this reading ChatGPT cannot program. But on another reading, Naur is merely giving us a lense through which to view programming. Programming *as* theory building is asking us to take this view and see what follows.

I want to be a bit more explicit in what I propose here. I am attempting neither of Naur putative projects here, though my project may find a kinship with the latter reading of Naur. Instead I want to talk about a particular way of interpreting our activity of programming. Or perhaps I want to offer an attitude one can take when programming. To put it another way, Naur explores what programming is, I want to explore what programming can mean.

## The Meaning of a Program or the Meaning of Programming

Our project might easily be confused with a similar sounding project namely: what is the meaning of a program?  While an important project in its own light, we will not endorse any answer to that problem here, but it might be illustrative question to begin with as a means of clarify what is meant by our project.

What are we looking for when we inquire into the “meaning” of a program? Well, much like when we are interpreting a prose text, we are trying to make the text intelligible. One answer to this question in programming is to assign some form of semantics to the structures in our program. Given this semantic, we can claim that the “meaning” of a program just is the value this semantic picks out when applied to our program. If we have an operational semantic, it might be a series of state transformations, if we have a denotational semantic, the meaning may consist in some well defined mathematical object.

This notion of meaning is rather narrow. It is useful in all sorts of formal settings, but it clearly does not exhaust what is meant by “meaning” of a program. Consider a court attempting to understand if a program constitutes fraud. Assigning a semantic to the program text hardly helps in that effort. But even in more mundane cases of every day development, formal notions of meaning are not enough. What exactly the “meaning” of a program is, is a large undertaking. (For an exploration of this in the legal context see Grimmelmann).

The notion of “meaning” we are concerned with in this article is even more expansive. In asking what a program means we are asking something analogous to its “linguistic” meaning. Here, we are instead looking for something a bit more personal. How can one find “meaning” in the act of programming itself, or to put it another way: What is the point of the activity of programming? Where does the act of programming get its worth? What are (should be) our motivations for programming?

## Instrumentalism

This task may seem a fools errand. There is no “meaning” to programming. Just as there is no “meaning” to life. If this were our project, it would indeed seem worthless. What I want to argue here is not that all acts of programming have some ultimate end. I am instead offering a way in which people can ascribe meaning to their acts of programming. But that is not quite right either. What I want to claim is that there is a legitimate way of finding meaning in programming that might, at first blush, not seem legitimate. This is what I call the *striving* approach to programming. Or to put it negatively the *anti-instrumental* approach to programming.

What does it mean for an approach to finding meaning in programming to be legitimate? This is a difficult question. It might seem that given there is not one right and true way of finding meaning in programming, that all methods of finding meaning in programming are legitmate. But a moments reflection finds that this is clearly not true. Imagine Bob has decided to program because he believes that programming will make him a more desirable romantic partner, for anyone he happens to talk to. Bob begins programming and finds his meaning in the fact that as he learns more and more esoteric features of C++ his romantic desirablity increases. Clearly Bob has made a mistake somewhere along the way.

But it isn’t merely unrealistic examples like this which may be illegitimate. Perhaps one finds meaning in programming because they believe they are creating good effects in the world. For example, they believe that their program will create better economic circumstances for the disadvantaged. Perhaps instead a their program actually creates a worse economic situation for the disadvantaged and in turn destroys the environment by that vast amount of computing resources it uses. (See cryptocurrency)

But let’s ignore these specific examples and be a bit more abstract. I think most people implicitly believe something like the following: Programming is about creating some program P and through the running of P, we achieve some good G; this good G is the meaning of our activity. This might seem all a bit too vague. So let’s fill in the details. Perhaps you are creating a program to help disadvantaged people find needed resources. People using your program allows them to find the needed resources. Perhaps you create an open source program that allows other people to achieve their ends, your good is the fact that you are helping them achieve their good. Or perhaps you create a program for a company that allows yourself to be paid and have money for your family. The exact way in which these indirect effects tie up might be a bit complicated. But the point is that in all of them the meaning you derive from program is derivative from some other good.

This sort of instrumental view is, I believe, implicit in almost all discussions (direct or indirect) about the meaning of programming. Programmers are supposed to make something that will be used by others. Our job is to make and build and for others to use what we make or build. Perhaps some of our programs won’t be used because we make them to learn, but even here, the learning is merely a means to get to the point where we can make a program others will use. My goal here is to show you a way to find meaning in programming that does not rely on this sort of instrumental good.

## Anti-instrumental Good

I think this claim that there can be legitimate meaning to programming that does not appeal to some external good may be surprising to some. But others may find it perfectly natural. Programming has all sorts of purposes. For example, the generative artist is not creating software for others to use, they are creating software to make art. There is no "good" being produced by the software, there is art. But if this is the response, it is merely to misunderstand how radical of a view I'm advocating. Here that good "G" is the art, or the enjoyment the viewers of the art derive, or however we want to cash out the good of art. This sort of view is still an instrumental one. It gives the creation of a program some sort of directedness. It points the activity at some End and claims that End is where the purpose of the activity is found.

Here instead I want to claim that there is a legitimate way of taking programming that does not appeal to any sort of end. Perhaps it would be tempting to say that I am claiming "programming is an end in itself", but I don't find this phrasing helpful. What I want is not to merely make a cliche statement, but offer a concrete way to take programming that can provide meaning without appeal to an instrumental good.









// example https://olano.dev/2023-11-30-code-is-run-more-than-read/
