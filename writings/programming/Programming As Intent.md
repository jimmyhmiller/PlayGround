# Programming as Intent

There is a ton of advice about how to write good code on the internet. This is my attempt to give such advice. In its bits and parts I'm sure it contains nothing novel, but as a whole I hope it is interesting. More than anything though I am writing this for me as means to discover a principle by which to live. Bret Victor spelled out this view of life in his incredibly influential talk "Inventing on Principle", yet despite its influence, its central message was lost. There is a path for the technologist to be an activist. This is the path I hope to take, but what precisely my cause is still eludes me. This is part of that self discovery.

## Programming with Intentions and Ends

There is a tension that is hard for me to resolve in how I view programs. First, programs are creations of people. When people write programs they have some intent or other that ultimately they encode into the program. At the same time, programs in some ways have a life of their own. There are good and bad changes to programs. Programs have an end to which they aspire. In other words, a program can flourish or flounder. It is this tension that is involved in writing good code. The task of the programmer is at once to express their intent, but at the same time discover what the program itself ought to be. 

This view of what it means to write a good program stands in stark contrast to many others out there. First, it doesn't lend itself to objective measurement. Measures like cyclomatic complexity or function size have their place, but do not define the sum and total of what is involved in writing good programs. Secondly, this view isn't presciptive of some structure or other that programs should follow. It doesn't marry itself to any particular paradigm, it could apply just as well to popular and unpopular paradigms, it can apply at all levels of systems, and can even apply to future ways of writing software that don't currently exist. Finally, this view doesn't prescribe a process that the programmer ought to take when writing a program. Views like TDD describe good programs in terms of the process used to create them, my view allows people to follow whatever process works best for them.

## Expressing the Tension

It is really hard to give advice about writing programs without being overly prescriptive. There is lots of advice that I myself generally follow. I am for example a big fan of small functions. And yet, I think spelling out these sorts of rules or heuristics, gives the wrong view of what it means to write good programs. Programming isn't a mechnical act. No amount of applying rules to the existing bad code will get you good code. Good code comes from a creative act. It comes from a process that isn't following rules.

Let's narrow our scope for a moment. Imagine you are approaching an existing program looking to make a change, but also looking to make the program better. This a program that you did not build. How should we approach this task? What are some tatics we can take to understand it? In what ways do we change the program? How do evaluate if our changes are any good? These are the sorts of questions I hope to give advice on. These are the questions every programmer has and yet never gets help on.

### The Messy Reality of Intent

Code we encounter on the day job is rarely of single minded intent. Perhaps the logic was translated from a legacy system, maybe the programmer working on it was distracted or under a time crunch, maybe it was once a unified whole but, many hasty changes later, the whole thing has become patchwork. This is often the code we want to fix; the code that has been overworked and underappreciated. The code that is a disaster zone, an area no one can understand. Our job is to find the intent hidden in the code. To search underneath the surface and find what the programmer meant for the code to be, and then to craft the code into what the code itself wants to be.

Discovering what our code ought to be is the process we embark on as we go to improve code. In order to do this, we must first pull code apart. More often than not, the process for improvement does not begin with a master plan, but with exploration. We start by playing with it and poking at it. Perhaps there is a function that is very large. Let's divide it into smaller functions. Maybe there is a variable set on the third line of a function, but not used till line 40 of the function, we can move that function closer to its use. As we go and make these changes, we begin to feel the structure of the code.

At this point intent starts to jump out at us. There begins to be a meandering path appearing in the code. We begin to see separate strands in the code that have been weaved together. We make conjectures about how the code may evolved, often checking `git blame` to confirm or disconfirm our beliefs. As the pieces begin to fall into place, we divide the code further, renaming variables, rearranging bits and parts until a coherent picture emerges.

### Putting the Pieces Together

This is not the end of our journey. More often then not this is the stopping point for most people. Making code better can often mean renaming bits, moving things around, adding a comment here or there. But if we are to write good code, these are just tools for understanding. This process we have taken on a bit of code unfamiliar to us was not itself the process of writing good code, but instead the process for gaining an understanding of the intent behind the code. Or to put it another way, bad code hides its intent, requiring a large amount of work for others to discover.

If bad code hides its intent, good code wears it on its sleaves. Good code helps those unfamiliar with it become familiar. Good code guides the reader into understanding the intent of the programmer who wrote it. But good code doesn't merely express intent, because our intent may not always be pure. Perhaps our intent is to hack something together just to finish it. Maybe our intent is to follow some advice we read on some blog. Whatever this intent is, just because our code displays it does not make our code good. In other words, clarity of intent is a necessary but not sufficent condition of good code.

What else must our code do in order for it to be good? Our code must fit well in the environment it was meant for. It must be structurally suited to perform the task, not only of computation, but for its life time of reading and modificaiton. Code has both intent and purpose. The purpose of the code helps give its conditions for what it means for that bit of code to be good. Not all code does the same thing or has the same lifetime. Given this, it hardly makes sense for there to be just one criteria for what makes code good or bad.

## Going Beyond Generalizations

Clear intent and a fit for its environment are the two key factors in what I consider to be good code. Elaborating on these topics and making them concrete is actually quite difficult. The sort of good code we are primarily concerned with are not examples that we can easily fit in a blog post. Code found in presentations or blogs looks rather different from the code we find in our day jobs. The code in our day jobs is filled with messy, crufty code, with 10 different ways of accomplishing the same things, with seemingly unused code, with out of date comments, with endless functions, with the one class to rule them all, with pointlessly deep class hierarchies, with metaprogramming magic, with ungreppable symbols, with hacks to get around strange constraints placed on us by existing frameworks, with tests that are endless walls of mocks. The list goes on.

Too often we oversimplify this messy reality in order to focus on some bit we find particularly compelling. But if we are to write good code on the job, we must confront the code as it is. Our code does not live in isolation. Our code isn't meant to be understood only by us. Too often advice assumes this single author approach. It assumes that those making changes to the code are fully knowledgeable of the problem and will make changes accordingly. Good code accepts that hasty programmers will come in and change it. It faces the reality that we can't predict what our code will be used for next. It knows that it doesn't live in isolation.

As programmers, we aren't merely systemetizing a problem, we are arranging an explanation of a problem. We are drawing a picture of the contours of the problem. We are providing a vocabulary for which to think about the problem. We must consider human habits of reading and writing code. We must provide a guide for future visitors of our code base, allowing them navigate, separate, and find a home for their new ideas.

### Human Navigation

As we've discussed our code has in itself a purpose, but so do the people who approach our code bases. Anyone reading a code base is approaching it with some more or less specific purpose in mind. These purposes will vary greatly from person to person and over the lifetime of our program. One of the simpliest purposes someone may have for our code base is to use it as a body of information for which to answer a question. This question may be one about the code base itself like "What technologies does code base use?". It could be about how this code base relates to some other piece of software like "Does this code base talk to service X?". Or it may be a business question like "How do we calculate the margin for Y?".

While seemingly obvious, code as a static body of information, not as a thing that executes, is not something often considered. How many times have you gone to a codebase to answer a question? How many times has the codebase given you the answer readily? How many times has it required digging deep, playing computer in your head to answer the question you had? If people are asking our codebases questions, why not structure them in a way that provides the answers easily?

Trying to tackle this problem, we immediately face issues. How can we possibly predict what questions will be asked of our code base? How can we know ahead of time, what future purposes people will have? In general we can't. As the environment around our code continues to shift and change, new questions will be asked that we would have never considered. Yet, we aren't without hope. While we may not be able to predict exactly which questions are asked, we can consider classes of questions.

This consideration brings us to the notion of "separations of concerns". Unfortunately, this phrase has come to mean something quite different from its original meaning giving to it by Dijkstra. In Dijkstra's essay "On the Role of Scientific Thought" separation of concerns is not about how we structure the modules of our code. It isn't separating presentation from style or practicing inversion of control. Separation of concerns is an intellectual habit. It is the ability to break things into pieces and consider them one at a time. This is the notion of separation of concerns we are interested in. We want to help the questioner focus only on their question. We want to allow them to consider their question in isolation, not needing to understand the whole in order to answer it.

### An Index of Information

Our code then becomes an index into a book of information. Depsite its execution and layout on a screen being linear, code as a static body of information is not. When considering code as information, any and every point of our code base is a starting point. In fact, more often than not, people don't (and shouldn't) begin at our "main" function to begin answering their question. Instead, they search. If we are to help people answer their questions, we must begin by making this search easy. 

This is where we get into traditional advice territory. So many worlds have been written on naming that I don't plan to rehash much of that discussion here. For any given language there are certain idioms and conventions you should follow. There are anti-patterns that you may be using if you are naming things in a certain ways. Those are things you can learn when using those languages. What we are concerned with here is searchable names. When someone comes to your code base and asks, "does this codebase use service-x", the easiest way to answer that question is to search for 'service-x'. If we name things well "service-x" should show up in their search results. 

Being an index for information begins, but does not end with, searchable names. More than likely, once the question about service-x is answered in the affirmative, the next question that person will have is something like "What endpoints of service-x does this use?". Here searching for each and every endpoint is the wrong answer. More than likely the set of endpoints is not even known. Instead, the person will most likely scan over the code, looking for a single instance of calling an endpoint, notice a pattern, and continue scanning for that pattern. If our code is to serve as  a useful index, that pattern should be consistent for all endpoints we call. If our code is to be even better, this pattern should be searchable. 

Here we have focused on a simple example, but being an index for information is a transformative way of considering a code base. By considering the questions people will ask of our code base, we can have guidance on what things to group together, what things to separate, what to call things, which parts should be interconnected. We have a basis for thinking about the structure of our code that has nothing to do with how it runs. It in fact, has nothing to do with the computer. Programming is not primarily about computers. It is about information, it is about knowledge, it is about [building a theory](/incommunicable). We must consider this as we begin structuring our code.

## Conceptual Engineering

Our code not only provides a structure for navigation of a body of information, it provides a conceptual vocabulary. Our code contains a number of different concepts, those related to the programming language it is written in, those belonging to the domain in which the program is employed, and those internal to the program itself. Our program makes use of these different conceptual domains to different ends. The concepts inherited from our language are necessary for encoding our theory. Our domain concepts are required as communication to others but also as tools to relate our program to world around us. Our internal concepts are generally abstractions used to aid our thinking.

Our use of these concepts is not neutral. We are not simply taking predefined concepts and using them in their standard way. Instead by placing our concepts into a program, we are practicing conceptual engineering. We are redefining words, creating new concepts, and emploring others to adopt our conceptual vocabulary. We are engaged in conceptual engineering, the attempt to refine and fix language; to change the way people use terms and think about problems. In other words, beyond the function of our code as an executable artifact, beyond the use of our code as an index for information, our code also serves as an argument, an attempt to persuade people to see things a certain way, to change their view on a problem.

### Changing People's Minds

On this surface of it, code as argument may seem a bit ridiculous. More often than not, we just see code as something that is. Code is an artifact, it is text that is understandable by the machine. And yet, the fact that code contains some sort of conceptual argument shouldn't be suprising when we consider the conceptual wars raging on in the larger programming world. To take the most obvious example, there's currently a battle between the Objected Oriented world and the Functional Programming camp about the right conceptual vocabulary for programmers. Should we think of our code as containing objects, things with properties and behaviors, or should we think of our code as mathemetical functions acting on data? Of course, there are also those arguing for a marrying of the two, but they are not neutral either, they are trying to persuade both sides to change their conceptual views.

Even in less contentious spaces conceptual engineering continues to happen. Consider the "serverless" movement, as many detractors insist on pointing out, there still are servers involved. Serverless isn't a call to get rid of servers, instead it is a call to write some code in a way where the concept of servers doesn't enter into your thinking or development of code at all. Dependent types extend our concept of types to include values. Lisp extends our concept of code by showing us that code can be data. Erlang extends our concept of computation to include actors, supervisors and the like as concurrent units of message passing processes.

These extension to our concepts don't happen automatically. Upon seeing some text of code, our concepts don't immediately become changed. Instead the code begins to teach us, to persuade us of these concepts through its structural properties. Having heard the code is data mantra of an encrazed lisp fan, we may be completely at a lose about what this may mean. But after examining, running, and writing lisp code including its more interesting features like macros (or perhaps writing our own lisp interpreter in lisp), we may find ourselves convinced, code really is data. How does code offer such an argument? What sorts of arguments can code make? How can code successful persuade? How does it fail to persuade? How can we ensure our message isn't lost?

### Argument Through Structure

Perhaps the most immediate way that our code can provide an argument for concepts is in its structure. Placing elements together or apart implicitly puts in them into a certain relationship. Take for example the classic OOP introduction of an Animal base class and its various subclasses (Dog, Horse, Cat, etc). Here we are trying to make a certain conceptual claim, that there is an important way these things are related (animality) that matters for the purpose our program is intended to serve. To look at the opposite end of the spectrum, pure, lazy, functional languages like haskell introduce the notion of a monad and many types that fall under that category (IO, Maybe, Either, etc). Here, the structure is trying to show us something common between these various types, namely that certain relations hold between these types, their operations and certain mathematical laws.

But is it really always the case that our structure is meant to serve as an argument? No, in fact more often than not our structure exists for more mundane reasons like social convention, adherence to an external style guide, a file feeling too long, or just pure laziness. As we began by stating, programming is about intent and yet, there is something beyond intent, something that our programs ought to be whether we intended them to be or not.

Regardless of our intent, people will take our program structure as an argument, whether conscious of that fact or not. People will look to our program's structure to learn something about the problem at hand. They will consider elements which are close together to have something to do with each other, they will consider elements far apart to be orthogonal, they will try to find a heirarchy to know the relative priority of concepts. These are ways in which people explore and understand a code base, so if we are going to write code we must consider them. Our structure must reflect the concepts we want to convey.

### Choosing an Argument

If our argument is going to be clear (or to put it another way, if our program is going to have good structure), we must know what we want to argue. So how do we do this? What is the right sort of arugment to make in code? As should be evident by now, that will depend on what purpose our code is meant to serve. What purpose our code serves depends largely on the context outside our code. If we are to make are argument with our code, we must consider the questions, needs, and desires of those who will work with our code. We must understand what the life of our code will look like. To make this concrete we will consider a realistic circumstance we might find ourselves in and see how we could use code to argue for our causes.

#### The Case of Frustrating Tests

Imagine we work on a team where unit tests are taken seriously. A team who has chosen a (perhaps misguided) metric of requiring 100% test coverage. In fact, there is not actually just one team working on this code base, there are four, some members of these teams have other responsibilities, but all told there are probably 6-9 people of various experience levels writing unit tests in this code base. As you can imagine, there will be a large amount of variation in how these tests are written. No two people write code in the exact same way and the variety is amplified by spreading people across teams. But variety in itself isn't bad. The problem is working on tests written by other people. 

But the problem is not just one of lack of familiarity, over time a few patterns emerge that make adding new tests increasingly difficult. The unit tests start by setting up some context and then in a series of nested tests begin mutating that context in order to setup the next test. Trying to add a new test requires finding the right location in this nested series of a tests where the context has been setup how you need it to be. But what happens if your test mutates this context? Well, all the tests after you, begin to fail. Adding a new test becomes a process that takes days.

How do we solve this problem? Well, it must be first recognized that this problem exists in our heads. Our fellow teammates do not see the problem the way we see it. Instead they believe the reason tests are taking so long is the lack of uniformity. If we set standards for how we write tests, there would be no problem here. They say this primarily because they have no problem modifying their own tests, so familiarity of structure must be the issue. We have a few paths forward 1) get our manager to mandate our way of structuring code that we think is better, 2) have discussisons trying to persuade our coworkers to see the problem the way we do, 3) allow our code to argue for us.

I hope it is clear why 1 is a bad idea, depending on mandates from above means we may find ourselves on the wrong side of a future mandate. 2 can be a good strategy, but more often than not I've found that differences in values and experience get in the way of convincing everyone. But more than that, 2 can be seen as confrontational or as attempt at a power grab. Letting our code argue for us lets us (in many ways) get beyond social dynamics. How can we have our code argue for our view of the issue?

We do this through our test structure. First, we need a sizable task to take on and write tests for. This feature should be sufficiently complicated so our example isn't a toy. Secondly we need to ensure that our code for the feature itself is clear and easy to work with, we don't want anything to distract from the point we intend to make. With these prerequisites out of the way, we can start structuring our tests. We begin by ensuring that our tests are not nested at all, all tests are isolated from each other. We also ensure that our context is not mutated across test bounds. Perhaps existing code mutates things, but we should ensure mutation is test local. We next make some helper functions to allow for obvious patterns to emerge, and finally we leave comments explaining how to use these helpers and when each of them is useful.

Here we have an argument in our code. We have a few features that are interesting. First, this test does not follow the structure of any of the other tests in the code base. So, if lack of familiarity is the root cause of the test confusion, this code should be hard to add tests for. Secondly, our code is organized in a way to control for the two factors we believe are causing the problem. First our tests are flat, not nested so if there is any searching that needs to be done, it is linear not branching. But we have taken this further, we have isolated tests so that all mutation only occurs inside a single test. This means that searching for the place to add a test is unneccesary. It also means that adding a test can never break an existing passing test. By setting up this structure, we can now test our argument by letting others (in due course) modify our feature and see how easy it is to add tests. If we are successful, our coworkers will be convinced, not by the words we've spoken, not by the text of the program itself, but by the experience of working with our code.

### Building Trust

In our extended example, there was a true dispute going on about code itself. This is a great time to let code be an argument, but code can argue even when there is no dispute present. When written well, our code argues for our view of the problem space. It teaches people correct and incorrect ways to use terms, to relate objects, to conceputalize problems. When done poorly our code can have the opposite effect. Poorly written code begins to argue against our conceptions of the problem. This bad code leaks out, infecting all views put into our code, eroding away the chance of convincing others.

Code is a powerful medium. Even the best of code is not easily read. Prose can be read unthinkingly. How many times have we found ourselves reading words, actually reading them, but thinking about something else? Code isn't like that. We may skim and ignore code while day-dreaming about something else, but reading code is an active activity. Code demands our attention in a unique way. Its text invades our mind changing our thought patterns. While good code still requires work, it makes the experience of thinking inside the code pleasant and enjoyable.

If we are to write good code, if we are going to convince people of our views, we must pay attention to this fact. We are offering people a guide into a way of thinking. We are making entry points into arguments for new conceptions. We are providing a new conceptual vocabulary, new tools for thinking. We must give people a reason to trust our view, we must help them along the way.