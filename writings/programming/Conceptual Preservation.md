# Conceptual Preservation

In the last post, I meantioned how we ought to learn from philosophers who have already explored these notions of Conceptual Engineering. Here we will do exactly that by focusing on the work by philosopher Matthew Lindauer [Conceptual engineering as concept preservation](https://onlinelibrary.wiley.com/doi/abs/10.1111/rati.12280). Despite the title Lindauer is not arguing that conceptual engineering is merely concept preservation, but rather that concept preservation is an important aspect of Conceptual Engineering. In fact, Lindauer's paper focuses on concept preservation because as he sees it, it may be the easiest, or clearest case of conceptual engineering. 

Lindauer is brings up concept preservation as a way to combat some constraints that some philosophers have placed on Conceptual Engineering. Most notably, Herman Cappelen has claimed that we don't really know how concepts change over time (Inscrutability), nor can we control how they change over time (Lack of Control). Lindauer wants to suggest that Inscrutability and Lack of Control are much less of a concern when it comes to concept preservation than to re-engineering and de novo engineering efforts. For this article, we won't dive into his argument here, but keeping this as background is important as we think about conceptual preservation as applied to our programming practice.

## Why Preserve?

Conceptual Engineering involves taking a normative stance, asking what our concepts ought to be, rather than what they are. Frequently we find concepts that are deficient in some regard and we aim to fix them, or to use the term of the art to ameliorate them. But what if our concepts are good? What if we have found a concept that we think is beneficial to keep? Are we done with our conceptual engineering work? Not by any means, over time semantic drift is inevitable if our words and concepts aren't protect and preserved.

It may seem that we already know exactly how to do this preservation process in software. In fact, arguably following best practices and using language features properly ought to lead to preservation. For example, in order to preserve a concept we can follow best practices by coding to an interface. Interfaces reify our concepts. They allow us to clearly delinate boundaries around our concepts. They also prevent people from circumventing our concepts. Shouldn't proper use of interfaces preserve our concepts for us?

### Interface Underdetermination

Sadly, interfaces are not enough to preserve our concepts. Our interfaces provide a structure to our code, but that structure is not what makes our code intelligible or tells us about what future modifications and usages are valid. When coding to interfaces, we have in our mind the purpose of those interfaces, we know the way they ought to be used and the ways they shouldn't be. We attempt to capture this by documenting them, describing invariants, and yet people still can take our interfaces and apply them in ways we didn't intend. But perhaps more importantly than that, concepts don't live in our code, they live in people. What people think about a concept and how they act in light of that concept is what determines if conceptual meaning has drifted. 

If this is true, in order to preserve a certain concept, it is not enough to program a certain way. We must consider human factors. We must evangelize our concepts. We must explain our concepts, and clear up moments of misunderstanding. More than any of that though, we have to get others on our same page, preservation cannot happen alone, others must share our goals, values, and principles in order for their ends not to be contradictory to our own. In other words, no amount of interface design or code in general will preserve our concepts, it is a social process.

## Expanding our Responsibilities

It is general excepted that overtime codebases typically get worse overtime. Interestingly enough, this worsening can happen with or without changes to that codebase. I think this notion of conceptual perservation (or lack there of) can explain part of why this occurs. Overtime we lose the meanings of the concepts that were meant to be encoded in this codebase. Sometimes this is due to intention changes by others, elsewhere in the business, but often this done merely through a failure to preserve the concepts in the minds of others.

As programmers we tend to think that our responsibility is to write clear, clean code. If we do this, others will be able to understand our ideas and the codebase will be properly maintainable. Yet, this never seems to happen in practice. As others begin to contribute to our codebase our concepts become lost. No longer do our interfaces mean what they once meant. No longer do our concepts drive changes in the codebase. Instead people approach our codebase with entirely different preconcieved notions and ascribe a new meaning to our concepts. This meaning can start to catch on and now we have two different groups with to different conceptions of the same term. These competing conceptions reak havoc on our codebase.

Our responsibility does not stop at writing code. We must work hard to preserve that concepts that matter. We must get them in others heads, we must teach others to act correctly in light of these concepts. A failure to preserve concepts can lead to undesirable effects. Think about how Alan Kay feels about the new understanding of Object Oriented Programming. Think about the way in which Agile has changed from something intended to help programmers, to something intended to micro-manage them. As programmers we must expand our notion of what is our responsibility. We must work hard to preserve our good concepts and change our bad ones.

