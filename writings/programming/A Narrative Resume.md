# A Narrative Resume

I've never been happy with a resume. The roles I've had, the technologies I've worked with, don't seem to fully define my career. Each job was more than just the technologies I used. More than the responsibilities I had. They shaped who I am as a software engineer. A resume does not tell you if you want to work with me. It does not tell you if I share the values your company holds. This is my attempt to do that. 

But I will help you out. If you actually are someone whose recieved my regular resume and chosen to come visit this page, each section will be the highlights. In fact if you hit the button just the right of resume. All the narrative collapses. And what you are left with is the resume as we normally concieve it. With one caveat, it is in chronological order. Rather than seeing what I've done lately you can see how I've grown.

## Heartland Payment Systems (2012-2014)

While I didn't write this directly in the blog post. It isn't a stretch to figure out my ["We ran out of columns" - The best, worst codebase](https://jimmyhmiller.com/ugliest-beautiful-codebase) was about my time Heartland Payment Systems. My first tech job. In fact, you can hear more about it about in [my interview with the Changelog](https://changelog.com/podcast/609) or if you are an audiobook listener, you can join 1M+ listeners and hear it [read to you by the Primagen](https://www.youtube.com/watch?v=uPrXEtvKFoI).

I won't recount all the details of this codebase here. But I'll give you some highlights of the tech stack. It was primarily C# codebase. But quite a bit of Visual Basic, a sprinkle of delphi, and a number of other old technologies like JScript.

After my internship quickly turned into a Junior Developer job, I was the junior developer mentoring the interns in a support, bug fixing adjacent role. Basically, the task of our group (1 Senior developer, 1 Analyst, 1 produce person, 5 interns and myself) was to fix the bugs and handle the manual data requests  that the business didn't want to spend money on. In practice, we did a ton of Brownfield development. Our software was made for internal customer support people and we talked to them directly. Gather requirements and built them software with in the existing monolith.

In this role I got to do all sorts of fun things. We had paid a contractor for custom time tracking software used by all the employees. But we had lost the source for it. So we had checked in decompiled sources for the software in source control. My job was to add new features using the decompiled sources as my source code. I spent a brief stint as the solo developer on a greenfield project. They brought in a senior developer to the team, but he was reassigned before doing to much work. The project pivoted.

Looking back, I didn't do a great job on the project but also about what I'd expect for an engineer with my experience and this level of instruction. This was in an era where rest was peak hype. I was told to make two different rest api servers for this one project. The first would access the database directly and expose the database tables with a one to one rest interface. The second would be a rest api that would talk to this data layer rest api. Then I was supposed to write a single page application in Backbone js or something similar. Instead, I used C# mvc with Razor as the templating language. 

I don't think either of these were the right choice. But I'm not sure looking back that there was a great choice for this project. It was ill defined, mostly demo ware. Disconnected from what customers needed. In many ways this was foreshadowing for projects to come later.

## NextGear Capital  (2014-2016, 2017)





