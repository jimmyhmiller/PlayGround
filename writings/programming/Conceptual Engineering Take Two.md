# Conceputal Engineering

Naming things is one of the most difficult task in all of software. This is a widely accepted fact in the programming world and yet no one discusses why. Why is choosing a name so hard? Perhaps names are hard to choose because others have already used them, or maybe the names we choose might be offensive in another language or context, or maybe we lose nuance and risk confusing two actually distinct concepts. While these all may be true, stopping here ignores the real complexity of naming and robs naming of the weight it properly carries. When we name things we aren't merely placing a label on something, we are creating and refining concepts and asserting that others ought to adopt our concepts. We are in the process of conceptual engineering, a process that if it is to be successful does not end once the name has been chosen.

This may seem overly grandiose, don't we just mean that picking a name is hard? Isn't that why we often end up with things like single letter variables or `temp12`? This is certainly true, but when we think about the systems we build we can see the dfficulty in naming stretches far beyond these local circumstances. How many times do you have to explain to a new developer that term A is used in system 1 to mean X, but is used in system 2 to mean Y? Or that, actually, even in system 1 X can mean three different thing? Or perhaps you have to explain an out of date term, one that reigned for sometime as the dominant name for something but was ultimately replaced but a newer, "better" term. In what sense is this term better? These sorts of matters hopefully show that the difficulty in the naming process isn't just in the dubbing of a concept, it is in the word's continual use and lifetime.

The names we choose how long term consequences. They serve not just as identifiers in the body of a program, but to form the concepts by which others will think about our code. The process of naming does not end with its dubbing, it is a continual process called "Conceptual Engineering". When we chose names in our programs we are taking a word, refining it to have a particular meaning, and encouraging others to take up our meaning. Whether by our intention or not, the words we choose and the way in which we employ them will deeply affect the way others interact with our programs and our business domain. We must not only choose the words, but convince others to take up our usage, teach others our meanings, and continue to refine these meanings as contexts change. Failure to do any of these elements can lead to a failure in naming.

## Conceptual Engineering in Practice

As software engineers we are constantly faced with the task of engineering concepts on two fronts, those of our domain and those of our codes abstractions. While it is useful to treat these two separate, they are more inter-related than we often acknowledge. The concepts in our domain can help inform our coding abstractions, but the coding abstractions we choose can also reinforce (or undermine) the intended meaning of our domain terms. This is getting a bit too abstract though. Let's dive in first to some familiar examples of conceptual engineering, then we will dive into our responsibilities. How can we as software engineers be successful at conceptual engineering?

### Conceptual Engineering in the Large

To engineer a concept is a take words, refine their meanings, and then advocate that others adopt these terms. We can see exactly this process in the original [1979 MVC memos](https://folk.uio.no/trygver/2007/MVC_Originals.pdf). Model View and Controller are not new invented terms, but rather existing terms that have been given a particular meaning in a particular context. What we mean by Model in MVC is of course related to what we mean by "model" in some non-programming contexts, but the Model of MVC has a more precise meaning. When working with a code base or framework that follows the MVC pattern, we concieve of our code in a different manner. As we write in line of code, we must consider where in this conceptual frame our code fits. Sometimes people find that their code doesn't quite fit into any of these categories, or that they don't think the division is quite right and so they invent their own modifications (MVVM, MVP, etc). Or perhaps you are on a project that follows MVC and someone doesn't understand it, doesn't know what it is, or just doesn't like it and so they break these boundaries. Or perhaps, someone thinks MVC is great, but also loves services, or repositories, or some other abstraction and adds these on top of the MVC model.

Regardless of your experience, or lack there of with MVC, once you are familiar with conceptual engineering as a concept, you begin to see its pervasiveness in software engineering. Agile, Lean, MVC, Serverless, Object Oriented Programming and Functional Programming (to just name a few), are all examples of major conceptual engineering projects that continue to propetuate and evolve based on the advocacy of their adherents. And while we may take some side or other in these various projects, we also have a more direct role in engineering concepts in the small. We are borrowers, refiners, and practioners of these larger projects, but when it comes to our codebases, we are the creators and originators of new concepts, ones which we hope to be successful.That is now where we turn. How can we successful engineer concepts in our code base, whether in our domain or in our abstractions? How can ensure these concepts are understood by others and don't morph into something we never intended?

### Conceptual Engineering in the Small

Our code bases are full have half-baked concepts, concepts that once reigned and have since fallen, and concepts that simply muddled and so confusing, no what knows what they once meant or if they ever meant anything. Seeing this problems is easy. As developers we are very good at point out flaws, but what about those successful concepts? What is it that makes them successful? How can create a new concept and ensure its survival and flourishing?

We must begin by thinking clear about what are task is? Are we hoping to create something new from scratch? Are you trying to refine and adapt an existing concept? Does our concept exist merely as an artifact in code or does it have implications for how we think about our domain? Considering all of these factors is an important key to ensure we have come up with the right concept. But it is equally important to think about how these factors affect they way we will communciate our new concept to others. To make this concrete we will discuss to scenarios where no matter how well we refactor our code, no matter what style guide we follow, we cannot fix this issue. We will see that the real, concrete problems we face can only be saved by embracing the work of conceptual engineering.

### A Broken Test Suite

