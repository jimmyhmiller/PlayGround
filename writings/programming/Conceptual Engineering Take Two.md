# Conceputal Engineering

Naming things is one of the most difficult task in all of software. This fact is generally agreed by all parties and yet exactly why it is so hard is never explored. If we explore this issue at all, it is at the very surface level. Perhaps names are hard to choose because others have already used them, or maybe the names we choose might be offensive in another language or context, or maybe we lose nuance and risk confusing two actually distinct concepts. These are all true things about what makes naming difficult. But to stop here ignores the true complexity of naming and also ignores a responsibility that we as software engineers have. When we name things we aren't merely placing a label on something, we are creating and refining concepts, and asserting that others ought to adopt our concepts. We are in the process of conceptual engineering, a process that if it is to be successful does not end once the name has been chosen.

This may seem overly grandiose, don't we just mean that picking a name is hard? Isn't that why we often end up with things like single letter variables or `temp12`? This is certainly true, but when we think about the systems we build we can see the dfficulty in naming stretches far beyond these local circumstances. How many times do you have to explain to a new developer that term A is used in system 1 to mean X, but is used in system 2 to mean Y? Or that actually even just in system 1 X can mean three different thing? Or perhaps you have to explain an out of date term, one that reigned for sometime as the dominant name for something but was ultimately replaced but a newer, "better" term. In what sense is this term better? These sorts of matters hopefully show that the difficulty in the naming process isn't just in the dubbing of a concept, it is in the word's continual use and lifetime.

The names we choose how long term consequences. They serve not just as identifiers in the body of a program, but to form the concepts by which others will think about our code. The process of naming does not end with its dubbing, it is a continual process called "Conceptual Engineering". When we chose names in our programs we are taking a word, refining it to have a particular meaning, and encouraging others to take up our meaning. Whether by our intention or not, the words we choose and the way in which we employ them will deeply effect the way others interact with our programs and our business domain. We must not only choose the words, but convince others to take up our usage, teach others our meanings, and continue to refine these meanings as contexts change. Failure to do any of these elements can lead to a failure in naming.

## Conceptual Engineering in Practice

As software engineers we are constantly faced with the task of engineering concepts on two fronts, those of our domain and those of our codes abstractions. While it is useful to treat these two separate, they are more inter-related than we often acknowledge. The concepts in our domain can help inform our coding abstractions, but the coding abstractions we choose can also reinforce (or undermine) the intended meaning of our domain terms. This is getting a bit too abstract though. Let's dive in first to some familiar examples of conceptual engineering, then we will dive into our responsibilities. How can we as software engineers be successful at conceptual engineering?

### Conceptual Engineering in the Programming at Large

To engineer a concept is a take words, refine their meanings, and then advocate that others adopt these terms. We can see exactly this process in the original [1979 MVC memos](https://folk.uio.no/trygver/2007/MVC_Originals.pdf). Model View and Controller are not new invented terms, but rather existing terms that have been given a particular meaning in a particular context. What we mean by Model in MVC is of course related to what we mean by "model" in some non-programming contexts, but the Model of MVC has a more precise meaning. When working with a code base or framework that follows the MVC pattern, we concieve of our code in a different manner. As we write in line of code, we must consider where in this conceptual model our code fits. Sometimes people find that their code doesn't quite fit these categories, or that they don't think the division is quite right and so they invent their own modifications (MVVM, MVP, etc). Or perhaps you are on a project that follows MVC and someone doesn't understand it, doesn't know what it is, or just doesn't like it and so they break these boundaries. Or perhaps, someone thinks MVC is great, but also loves services, or repositories, or some other abstraction and adds these on top of the MVC model.

I'd imagine that most people reading this have experienced some sort of MVC application. Perhaps you are a fan of MVC, or perhaps you have had to deal with over complicated, over engineered, terrible MVC code bases. Or maybe you have never even had to work with an MVC framework. Perhaps you came into software after the rise of React which ushered in a new conceptual vocabularily for frontend development. Or perhaps you are a lisper, prefering a bottom up, code as data approach. Or perhaps you are a haskeller resting content in your mtl stack to provide you the organizational principles you need. Regardless, of where you stand in the software world, your code is effected and made intelligible in light of some conceptual engineering project or other.

Conceptual Engineering is pervasive in software engineering. Agile, Lean, MVC, Serverless, Object Oriented Programming and Functional Programming (to just name a few), are all examples of major conceptual engineering projects that continue to propetuate and evolve based on the advocacy of their adherents. And while we may take some side or other in these various projects, we also have a more direct role in engineering concepts in the small. We are borrowers, refiners, and practioners of these larger projects, but when it comes to our codebases, we are the creators and originators of new concepts, ones which we hope to be successful.That is now where we turn. How can we successful engineer concepts in our code base, whether in our domain or in our abstractions? How can ensure these concepts are understood by others and don't morph into something we never intended?

### Conceptual Engineering in the Small

