# Building Meander in Meander

[Meander](https://github.com/noprompt/meander/) has been (in my personal opinion) a wonderful success. With meander.epsilon, we have been able to really get meander to the point where most of the things we want to talk about in data transformation can be expressed. There are of course a few rough edges, a few things we'd change. But as more people have begun to use meander and more people present problems they are tackling with meander, it becomes clear that this approach is working. And yet, there is something that isn't working quite the way we'd like, the implementation of the meander compiler itself.

This isn't meant as a diss on the code. Ultimately the organization of the code is actually really nice. There are clear defined boundaries, there is clear separation of functionality, the code itself isn't a mess by any standard. Nor is this a diss on the quality of code generated by the meander compiler. There are certainly areas that we could improve, but in general meander produces code that is fast and that is small. In all the meander matches we've written we have never once encounter the "method code too large" error that has plagued complex pattern matches when using libraries like core.match. 

But there is still something not right with the meander.epsilon compiler. As you dive into the code base and try to make modifications, it becomes hard to trace the way data is being transformed. The code is littered with if statements needed to inspect the structure of the data we are getting. Then, we have to pull out all the bits and parts we care about. What data is and isn't available at a given point is far from clear. But I think even more important than that is that the shape of our data is lost. The meander.epsilon compiler is really just converting between data structures, we read matches in as data, parse them as an ast, build a matrix based IR, build a more direct IR, do optimizations and duplication, and then generate clojure code (also data). But looking at our compiler all of this is completely opaque, despite our best efforts.

## meander.zeta

In meander.zeta we are taking a different approach. All the details haven't been worked out yet, but in this article I want to share the general approach so that others can understand what we are looking to accomplish. In order to do that, we are actually going to build our own mini-meander compiler using meander.epsilon. Our compiler will not be efficient or support many matches. But it will give you a taste of what meander can do as well as give a taste of how we are using meander to implement itself.

Before we get start though, let's talk about our plan. First in order to keep our code clear and this article from stretching out forever, we are going to limit our feature set to matching on logic-variables and vectors. For our purposes that should be all we need. Further, we are only going to be implementing the "match" side of meander. Substitution is left as an exercise to the reader. In order to accomplish all of this clearly, we will start by first implementing a parser. Then taking our AST (abstract syntax tree) produced from our parser, we will implement a simple meander interpreter. Finally, we will show how meander's symbolic nature allows us to easily transform this interpreter into a compiler, with minimal changes. Let's begin.

## Parser

Our parser is going to mirror the format used by the meander parser. I will deviate a bit, but the general approach will be the same, so you will be begin to see a bit of what the internals of meander looks like. But rather than build the parser first, let's describe the output we would like from our parser.

```clojure
(parse '?x)
;; =>
{:tag :logic-variable :symbol '?x}

(parse '[?x ?y])
;; =>
{:tag :vector
 :sequence [{:tag :logic-variable :symbol '?x}
            {:tag :logic-variable :symbol '?y}]}
```

Here we have two very simple examples of the input and output we expect from our parser. Our goal is to take our pattern and turn it into these nice, unambigious maps. These maps will always have a `:tag` value and then any other keys they need to record the information our interpreter or compiler might want. So, let's start by writing a parser that can only handle logic-variables, then will figure out how to deal with vectors.

```clojure
(defn parse [expr]
  (m/rewrite expr
    (m/symbol _ (m/re #"^\?.+") :as ?symbol)
    {:tag :logic-variable
     :symbol ?symbol}))

(parse '?x)
;; =>
{:tag :logic-variable :symbol '?x}

(parse '?y)
;; =>
{:tag :logic-variable :symbol '?y}

(parse 'y)
;; =>
nil
```

This parser is very straight forward. We are taking advantage of meander's `symbol` a `re` operators to make sure that we get a symbol whose name starts with a `?`. Other than that, we do not match on anything else and so everything else will just return nil. Let's start by trying to extend this to vectors.

```clojure
(defn parse [expr]
  (m/rewrite expr
    [!xs ...]
    {:tag :vector
     :sequence [(m/cata !xs) ...]}

    (m/symbol _ (m/re #"^\?.*") :as ?symbol)
    {:tag :logic-variable
     :symbol ?symbol}))

(parse '[?x ?y])
;; =>
{:tag :vector
 :sequence
 [{:tag :logic-variable, :symbol ?x}
  {:tag :logic-variable, :symbol ?y}]}

```

Here we pull out all the contents of our vector and use `m/cata` to recursively parse our input. If you have never used cata you can think of it just like recur but for patterns. With that we have written our parser as far as we need to for our purposes.

## Interpreter

