# Building Meander in Meander

[Meander](https://github.com/noprompt/meander/) has been (in my personal opinion) a wonderful success. With meander.epsilon, we have been able to really get meander to the point where most of the things we want to talk about in data transformation can be expressed. There are of course a few rough edges, a few things we'd change. But as more people have begun to use meander and more people present problems they are tackling with meander, it becomes clear that this approach is working. And yet, there is something that isn't working quite the way we'd like, the implementation of the meander compiler itself.

This isn't meant as a diss on the code. Ultimately the organization of the code is actually really nice. There are clear defined boundaries, there is clear separation of functionality, the code itself isn't a mess by any standard. Nor is this a diss on the quality of code generated by the meander compiler. There are certainly areas that we could improve, but in general meander produces code that is fast and that is small. In all the meander matches we've written we have never once encounter the "method code too large" error that has plagued complex pattern matches when using libraries like core.match. 

But there is still something not right with the meander.epsilon compiler. As you dive into the code base and try to make modifications, it becomes hard to trace the way data is being transformed. The code is littered with if statements needed to inspect the structure of the data we are getting. Then, we have to pull out all the bits and parts we care about. What data is and isn't available at a given point is far from clear. But I think even more important than that is that the shape of our data is lost. The meander.epsilon compiler is really just converting between data structures, we read matches in as data, parse them as an ast, build a matrix based IR, build a more direct IR, do optimizations and duplication, and then generate clojure code (also data). But looking at our compiler all of this is completely opaque, despite our best efforts.

## meander.zeta

In meander.zeta we are taking a different approach. All the details haven't been worked out yet, but in this article I want to share the general approach so that others can understand what we are looking to accomplish. In order to do that, we are actually going to build our own mini-meander compiler using meander.epsilon. Our compiler will not be efficient or support many matches. But it will give you a taste of what meander can do as well as give a taste of how we are using meander to implement itself.

Before we get start though, let's talk about our plan. First in order to keep our code clear and this article from stretching out forever, we are going to limit our feature set to matching on logic-variables and vectors. For our purposes that should be all we need. Further, we are only going to be implementing the "match" side of meander. Substitution is left as an exercise to the reader. In order to accomplish all of this clearly, we will start by first implementing a parser. Then taking our AST (abstract syntax tree) produced from our parser, we will implement a simple meander interpreter. Finally, we will show how meander's symbolic nature allows us to easily transform this interpreter into a compiler, with minimal changes. Let's begin.

## Parser

Our parser is going to mirror the format used by the meander parser. I will deviate a bit, but the general approach will be the same, so you will be begin to see a bit of what the internals of meander looks like. But rather than build the parser first, let's describe the output we would like from our parser.

```clojure
(parse '?x)
;; =>
{:tag :logic-variable :symbol '?x}

(parse '[?x ?y])
;; =>
{:tag :vector
 :sequence [{:tag :logic-variable :symbol '?x}
            {:tag :logic-variable :symbol '?y}]}
```

Here we have two very simple examples of the input and output we expect from our parser. Our goal is to take our pattern and turn it into these nice, unambigious maps. These maps will always have a `:tag` value and then any other keys they need to record the information our interpreter or compiler might want. So, let's start by writing a parser that can only handle logic-variables, then will figure out how to deal with vectors.

```clojure
(defn parse [expr]
  (m/rewrite expr
    (m/symbol _ (m/re #"^\?.+") :as ?symbol)
    {:tag :logic-variable
     :symbol ?symbol}))

(parse '?x)
;; =>
{:tag :logic-variable :symbol '?x}

(parse '?y)
;; =>
{:tag :logic-variable :symbol '?y}

(parse 'y)
;; =>
nil
```

This parser is very straight forward. We are taking advantage of meander's `symbol` a `re` operators to make sure that we get a symbol whose name starts with a `?`. Other than that, we do not match on anything else and so everything else will just return nil. Let's start by trying to extend this to vectors.

```clojure
(defn parse [expr]
  (m/rewrite expr
    [!xs ...]
    {:tag :vector
     :sequence [(m/cata !xs) ...]}

    (m/symbol _ (m/re #"^\?.*") :as ?symbol)
    {:tag :logic-variable
     :symbol ?symbol}))

(parse '[?x ?y])
;; =>
{:tag :vector
 :sequence
 [{:tag :logic-variable, :symbol ?x}
  {:tag :logic-variable, :symbol ?y}]}

```

Here we pull out all the contents of our vector and use `m/cata` to recursively parse our input. If you have never used cata you can think of it just like recur but for patterns. With that we have written our parser as far as we need to for our purposes.

## Interpreter

Now that we have an ast, we can write a simple interpreter. What our interpreter will do is given an input and a pattern and an evironment, we will return an environment with all our logic variables set to some value, or we will return `:fail`. Rather than try to assemble our interpreter piece by piece, I wil begen by showing you the entire thing.

```clojure
(defn interpret [expr target env]
  (m/match [expr target env]
    
    [{:tag :logic-variable :symbol ?symbol} ?target ?env]
    (if (contains? ?env ?symbol)
      (if (= ?target (get ?env ?symbol))
        ?env
        :fail)
      (assoc ?env ?symbol ?target))
    
    [{:tag :vector :sequence ()} ?target ?env]
    ?env

    [{:tag :vector :sequence (?x)} ?target ?env]
    (interpret ?x (nth ?target 0) ?env)
    
    [{:tag :vector :sequence (?x & ?rest)} ?target ?env]
    (interpret {:tag :vector :sequence ?rest} 
               (subvec ?target 1) 
               (interpret ?x (nth ?target 0) ?env))))

(interpret (parse '[?x ?y]) [1 2] {})

;; =>
{'?x 1 '?y 2}

```

If you've written an interpreter before this shouldn't be too suprising. First we handle logic variables by looking them up in the evironment. We handle the cases of it existing in the environment and matching, it existing and not matching, and it not existing. Next we handle some vectors cases. Here we handle the empty case, the single element case, and the case with more than one element. This interpreter does in fact work for the input we've given it. But think about what would happen if we did the same pattern but just passed a single number? We'd throw an error, because we never actually check that our input is a vector. We could just go and add a vector check to all of our vector cases, but that means we will be checking that something is a vector for every single element of our vector. So let's try a different apporach.

```clojure
(defn interpret [expr target env]
  (m/match [expr target env]
    
    [{:tag :logic-variable :symbol ?symbol} ?target ?env]
    (if (contains? ?env ?symbol)
      (if (= ?target (get ?env ?symbol))
        ?env
        :fail)
      (assoc ?env ?symbol ?target))

    ;; Ensure target is a vector
    [{:tag :vector :checked nil :sequence ?sequence} ?target ?env]
    (if (vector? ?target)
      (interpret {:tag :vector :checked true :sequence ?sequence} ?target ?env)
      :fail)
    
    [{:tag :vector :sequence ()} ?target ?env]
    ?env

    [{:tag :vector :sequence (?x)} ?target ?env]
    (interpret ?x (nth ?target 0) ?env)
    
    [{:tag :vector :checked ?checked :sequence (?x & ?rest)} ?target ?env]
    (interpret {:tag :vector :checked ?checked :sequence ?rest} 
               (subvec ?target 1) 
               (interpret ?x (nth ?target 0) ?env))))
```

Taking advantage of the fact that meander matches are ordered, we added an earlier match that will perform the check for us and then, when we recurse, we simply set checked to true. That means, this pattern will no longer match and we can continue with the interpreter as before. There is still a problem with this interpreter that we aren't going to fix in this post, it does not check the size of the vector. For our purposes, doing this would actually be fairly easy, we check the size of `?sequence` and ensure target has the same size. But what would we do if we added repeats (e.g. `...`, `..1` etc)? For now we will leave this off, but this might be a good exercise for thinking about on your own.

Now that we have a working interpreter, let's look at how we can make this a compiler. Doing so with meander will actually be suprisingly easy.

## Compiler

 