# Conceptual Engineering and Programming

At this point it is almost a truism that code isn't written *just* for the computer, it is written for other humans to understand as well. But what does this truism amount to? Typically it means that we ought to leave comments, we ought to name functions well, we should try not to be too clever with our code, and all sorts of other advice people generally give about writing good code. My aim is to show that this sort of advice sells our programs short, it leaves out a crucial function that our code serves and an activitity that we as programmers are constantly engaged in (even if we aren't aware of it). This is the role of Conceptual Engineer.

Conceptual Engineering here is not meant to be synonymous with software engineering. Conceptual Engineering is the process of creating and refining concepts and advocating that others adopt these concepts. Engaging in conceptual engineering is a process of trying to fix language, of trying to provide others with a new way to think about problems. Looking at the history of programming we can see all sorts of examples of conceptual engineering, for example, the creation of OOP. Creating OOP was not about writing some program or other. It was creating a new way of viewing programs. Programs viewed through the OO lense consist of objects that pass messages to one another. Under OOP communication is computation.

But software doesn't have a lock on conceptual engineering, it exists across disciplines. Einstien's redefinition of simultaneity to be perspective relative, Frege's notion of Sense, Raphael Lemkin's coining of the word Genocide. In some of these cases the meanings of old words are modulated to provide new meanings, in others, words are created to capture a particular concept. But all of these cases have something in common, they are attempts to change the way people approach certain questions and problems. Conceptual Engineering attempts to change the meaning of words in certain contexts, sometimes expounding on them, other times changing them entirely, but always with a certain aim in mind.

But clearly the activities we undertake in our day job are not that of creating a new programming paradigm or a new scientific theory. So in what way does the average programmer perform the role of conceptual engineer? My contention is that the whole process of building a code base is the process of conceptual engineering. Building a code base involves the building of a conceptual vocabulary, of explicating the relationships between the various words, and modulating their meanings through the ways in which we employ them. And further, that paying careful attention to this process can lead us to better code, code that does communicate to humans, not because the code employs words in their original meanings, but because by its nature it refines them and argues for this new perspective.

## Conceptual Engineering at a Company

Before we get to how code bases serve this role, let's think about the process of conceptual engineering inside a company. Starting a new job at a new company can be a rather daunting task. When you first start, someone at the company will typically talk to you one on one explaining the landscape. They will define key words and acronyms for you, they will hopefully show you some diagrams of pieces of the architecture. This initial conversation lays some groundwork and helps you get your barrings. But as you have more conversations you find that definition of words you thought you knew don't quite match up with usage. What you find is that this business has developed its own conceptual vocabulary. A "user" might mean some particular that is destinct from a "customer". Each domain has its certain terms, but these terms of refined even further within a particular company in order to allow communication to flow.

More often than not it turns out that the vocabulary your company is using is confused. The product people may use a term that has a specific meaning on the engineering team to refer to some general concept in the business domain. This can often make communication difficult and error-prone. Changing this fact, getting people to adopt a consistent vocabulary, is itself conceptual engineering and an incredibly important responsibility that engineers have. Sadly this is beyond the scope of this essay. I mention this fact though, because it is an important backdrop to all that we will do. Our work on a code base isn't isolated, it exists in this ever shifting context of the business. If we are to conceptual engineer, we must borrow from this context, as well as improve it.

## Conceptual Engineering a Code Base

The process of conceptual engineering looks quite a bit like coding. Conceptual Engineering isn't some upfront design process, it isn't building a bunch of UML diagrams, it is a way of seeing our code base. Whether we intend people to or not, as they read our code base, they will infer things about it by the way we use words, by the way we structure elements, by the way we arrange things. Conceptual Engineering is the process of considering what effects these elements will have.

### Users, Customers, Third Party Providers, and Support

Imagine that in our business domain we have three different types of users of our system. First there are our customers, the people who pay us for the service we provide. We provide them an interface that gives the information they need and allows them to update the information that is important for their business. We also have third party providers. These are not people who directly use our system for their work, instead they are inputting data into our system for use by our customers. Finally we have our own internal support people. They have an administration interface and are able to make changes that are needed on a customer's or third party provider's behalf.

The question for our code is how do we represent these use cases. Do all of these different people with different uses of our system count as "Users"? Should we represent them in the same way or should they be separate concepts? How should these concepts be related to each other? How can we decide this? For many coming from an OO background the word inheretence might come to mind. Let's look at what advice Martin Folwer in his book refactoring on when to "Extract a Superclass" to understand the wrong way to approach this problem.

> Duplicate code is one of the principal bad things in systems. If you say things in multiple places, then when it comes time to change what you say, you have more things to change than you should. One form of duplicate code is two classes that do similar things in the same way or similar things in different ways. Objects provide a built-in mechanism to simplify this situation with inheritance. 

In the context Fowler is talking about refactoring, but you can imagine the same advice in the context of creating code. If we want to know should we represent customers, third party providers, and support people using some common superclass, we could ask "Will we have lots of duplicate code if we don't?". I think this advice is thinking on the exact wrong level. What our code looks like is not the determining factor for how to represent our concepts. Instead we ask what we want to communicate, choose our representation, and ensure that our code reinforces this choice.

### Choosing Representations

Code duplication is bad or good depending our context and purposes. Perhaps we know that in the future these uses cases will diverge considerable. Perhaps we know that some use case we be removed in the near term future. Or maybe, we are going to be splitting this single application into multiple smaller applications. Here code deduplication cuts against our purposes, inhibiting us, rather than enabling us. But we have to not only consider our purposes, but those other developers who find themselves in our code base. Those who lack context, who do not know the plans we have for the future, or do not understand our business domain or the purpose and scope of this application.

The way we choose to represent users in this system will communicate to these new developers (by new I mean new to this code base not how long they've been programming). They will learn which parts are related in what ways, in which areas of the code base, by the names we give things and by the structures we place them in. We must consider the purposes of our code, the potential changes it may have, as well as the biases and purposes of other developers who approach our code. This will determine what structure our representation should take. But not only this, it will determine when/how to change this representation. If the purposes of parts of our system differ our representations will change as well.

This advice is in many ways unsatisfying as it does not lend itself to some definite criteria or rule of thumb. There is a tendency to reduce our code to something that is merely an artifact, something that given the right application of the right rules, will be good. But this isn't the way code is. Code contains in it the intentions of the people who wrote, it exists in an ever changing context, it is a tool for communication. 

### Bring Back the Concepts

We have considered what criteria we ought to use for representing our notion of user, but how does this relate to conceptual engineering. Well, our choosing of a structure is a mental act, we consider the purposes and plans involved in the life time of this project as best we can and decide on a representation, but now we must encode and communicate those choices in code. To do this we must choose names, for the concepts we are going to represent and then, if we are going to successfully communicate these concepts through our code, we must utilize them properly in codebase.

Let's try to make things concrete. Perhaps we've decided that for our purposes Customers, Third Party Providers, and Support People are actually distinct concepts. That despite these being general "users" of our system, they do not truly belong to the same category. We can now imagine all sorts of ways that we will fail to communicate this to new developers who look at our code base. If we are in an OO language, making these three concepts share a common base class will allow programmers to easily conflate these three distinct concepts. In a dynamic language, if we have a function that only works properly for customers but we call it `performActionForUser` we are inviting people to conflate yet again.

Perhaps things are a bit more complicated than this. Maybe there are "healthy" conflations and "unhealthy" ones. When it comes to authorization, it is healthy to conflate this concepts. We may have a generic system of authorization that is agnostic to what sort of things it is checking authorization for. But maybe for billing, conflating these notions would be unhealthy. First most obviously, Support People shouldn't be billed but perhaps as well our Customers and  Third Party Providers have very different ways they are billed. Customers may be usage based, whereas our Third Party Providers have a negotiated flat rate. 

This is where commitment to communication becomes increasingly important. The techniques and choices we make we will be particular our context as well as our language. But I will try to sketch ideas here of ways to approach this. First, we can separate our code in a way that makes this clear. By that I don't necessarily mean go and make a ton of classes and modules. I mean ensure that if someone is asking a question about Customers, they don't have to wade through a bunch of Third Party Provider code to try extract out what is going on. A guiding principle here is thinking about our code as an information repositiory and consider how quickly someone could answer their question by looking at your code.

We can also come up with our own terms for things that aren't necessarily entities in our domain. Perhaps we want to talk about people who use our system who do no work for us. Maybe these are "external users" or "end users". Perhaps Customers is actually quite a bit more complicated than what I've given here and that while it useful to talk about Customers, some subset might actually have something in common with Third Party Providers. In all these cases, we have consider the names we call these things and then ensure  use them in ways that correspond to their concepts.

### Out of the Domain

Now what I've been talking about here could be called domain modeling, but I want to be clear that this is merely an example of Conceptual Engineering, not its sum and total. There is also conceptual work that exists outside our domain and is instead only the purview of the code. A classic example is [MVC](https://blog.codinghorror.com/understanding-model-view-controller/). MVC is an attempt at conceptual engineering that tells us we ought think about any bit of our code as belonging to either the Model, the View, or the Controller.[Or extended with a few other concepts]. Think about code you have worked with that bought into the MVC model. Did it stay true to that model? Was there a clear separation between these various features? If so, that code base might count as a successful instance of conceptual engineering.

Our code base contains these same sorts of concepts. Perhaps we are adopting an existing pattern like MVC or creating our own way of organizing things. Regardless, we must take care to communicate these patterns successfully. 

