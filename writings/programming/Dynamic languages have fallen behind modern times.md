# Dynamic languages have fallen behind modern times

Dynamically type programming languages have fallen behind modern times. And no, I don’t mean they just need to add types. If you do, just bear with me for a second. Mainstream dynamically typed languages feel antiquated. Today, our machine’s our machines are filled with many higher performance cpu cores. Yet none of the mainstream dynamically typed languages take advantage of that. Javascript is single threaded, ruby and python both “have threads” but due to the GIL and GVL they don’t benefit much from them.

If we look at the design of these languages, they are clearly languages of the late 90s. Javascript has countless footguns that have been papered over by piles of linting. Python has strange scoping mechanisms and global dependencies management that necessitates confusing virtual environments. Ruby has a global namespace for all imports and pervasive monkey patching.

This isn’t to say something bad about these languages. I have worked with all three of them. There are things to love about all of them. It simply true that there are design decisions in all of them that we today would make differently. Why? Because we have learned from their example. Because through building large systems with all these languages, we’ve learned better ways to accomplish our tasks.

What would a dynamically typed language built for the modern era look like? Well, perhaps we should start by looking at the best contenders already out there currently.  To me there are only three, Julia, Elixir and Clojure.

Let’s start with Julia. In many ways Julia is a decidedly modern language. It is made for a modern niche, machine learning. It is performant, supports parallel execution, etc. Perhaps Julia is the answer, and I admit I haven’t used it much. But it seems unlikely. Julia is focused on mathematical computation. While it can be used for application development is hasn’t really gained any mindshare for doing that.

What about elixir? Elixir is a great language. It has wonderful community focused on providing value for real production apps. It’s support for macros makes its meta-programming capability top notch. Yet, its heritage does show. Elixir itself is modern, but it’s situated on top of a very old system. While the Beam is an impressive piece of technology, it is definitely from a different time.

Here the same can be said for Clojure. Clojure is a language I know and love. I am incredibly productive in Clojure. But it has things going against. First, because it is a lisp, a lot people will just write it off. But also its relationship with the jvm complicates things. Of course it brings incredible benefit, but it means as you dive deeper you need to know more and more about java and jvm, technologies bother from the 90’s.

So if none of these are the answer, what is? What does it even mean to be a “modern” language? Well in the statically typed world we have a number of examples. Look at Rust. Rust delivers a well integrated comprehensive experience. It comes with linter, formatted, language server, and package manager built in. It takes advantage of all the advances we’ve had in language design of the last three decades. What would a dynamically typed language which took this approach look like?

This is what I want to explore. What would a dynamic langauge look like if it was built today, from scratch, with all the lessons we’ve learned from the past? I don’t think the answer is obvious, but I do think there are some obvious attributes.

First, it goes without saying that tooling should be first-class, but its also important for it to be first party. Rust has shown us that shipping with an officially support formatter, linter, package manager, and language server can make a massive different in language ecosystem. So we need to do that as well.

But simply providing standard tooling is not enough. What should our language look like? How should it feel to program in it? Well, to start, it should not be object oriented. Now this might be the most controversial design decision. But this isn’t me saying something negative about object oriented languages. It’s just that all these legacy dynamic languages have already explored this space. Clojure and Elixir have started exploring the functional space, but are limited by their heritage to explore further.

I think the space that has remained unexplored is a dynamically typed functional language, that takes learnings from its statically typed counterparts seriously. Algebraic data types (or rust style enums if you are more familar with them) are fantastic tools for expressing data. Why do dynamic languages only simulate them rather than have a first class construct for them? Elm and rust have shown us just how good our error messages can be, why can’t a dynamic language have these? Null and exception have been found to be problematic. Is there a way to eliminate these in a dynamically typed language?

I think this is a space ripe for experimentation and for finding out what works and what doesn’t. But beyond experimentation, there are just features we know we need. Proper threading support, first class asynchronous execution, memory and cpu profiling, a first-class debugger. And perhaps most importantly, blazingly fast performance. Too many companies have spent too much money trying to retrofit over a slow language to make it fast.

Now all of this is a tall order and in many its just a wish-list. But if rewind back just a decade ago and made a similar list for rust or zig, people would tell you it can’t be achieved. Today, we have ambitious projects like Roc that are pushing the bounds for what you can accomplish in a statically typed, automated memory-managed langauge, functional language with only a small group. Why don’t we try to achieve this for dynamic languages? Why are dynamic languages either 1) from the past or 2) parasitic on existing platforms. It doesn’t have to be like this.

This is the project I’m embarking on. We are at the very humblest of beginnings right now. But the ambitions are high. In all honest I feel a little weird about making this video given the state of everything, but I’m inspired by the devlogs of game developers. They start with absolutely nothing and show you the journey of years of work. Why can’t programming languages be the same?