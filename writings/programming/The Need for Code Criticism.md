# The Need for Code Criticism

Code is a remarkably aesthetic activity. When you are first learning to program this fact might not be obvious. Most of your time will be spent figuring out how to tell the computer what you want it to do. But as you program more, this takes up less and less of your time. Instead, you start asking yourself meta-questions. Questions about code organization, code simplicity, potential future changes, understandability, flexibility, etc. When contemplating all these questions, you are not merely thinking about algorithms. You aren’t thinking performance. Instead, you are going beyond the needs of the computer into the realm of taste, of judgment, of opinion. These topics are constantly on our minds, and yet where in the programming community are these topics fully discussed?

Instead of discussion, we get dogmatic treatments, partisans claiming their style is the true and only good style. Countless books give you prescriptive advice on how you “ought” to code. They tell what “good” code amounts to. But this is precisely not what I’m after. We do not need more rote memorization of a series of best practices, nor a list of patterns you ought to apply, we need to have a better understanding of the aesthetic dimensions of code. 

## Structural Beauty
When talking of aesthetic dimensions of code, I am not talking about the text itself. Reformatting code does not make it more beautiful in this sense (though that isn’t to say formatting has no role to play). What I am focusing on instead are the structural choices we make with our code. Some code is strikingly minimal, direct, and transparent, yet perhaps rigid and inflexible. Other code is highly structured, predictable, and regimented, yet perhaps overly verbose and baroque. Yet still, other code is sparse, indirect, and flexible, yet perhaps opaque and hard to trace.

These are all styles that some programmer or other prefers. While some programmers might consider one style or another bad, none of these styles are examples of obviously bad code; code that no one would want to claim as their own. Doubtless, if you have explored many codebases, you can think about which ones fit which style here. (Not that this list is exhaustive). More than that, I’m sure you can assign various programmers you know to these categories.

And yet, what are the names for these styles? What codebases are exemplars of these styles? How can I go study a particular style and learn to do it well? What are the limitations of a given style? What values does this style convey? What problems are particularly suited to a particular style? Does style have any effect on solving various types of problems?

These are all questions to which the programming community has not turned its attention. These are all questions to which there are no resources to turn to. We have neglected style, we have neglected to study our own works in depth. But why exactly? What has kept us from this critical work? What has kept us from identifying style, creating movements, and understanding better the way we code?

## The Beginnings of Code Criticism

I’m not sure I have the answers to these questions other than to point to our collective unease with the subjective. Our belief that anything that is good or true can be quantified. This vestige of the long-dead logical positivism still has its hold on us. But we can ignore this. Forge forward, begin a new project built on the assumption of subjectivity, of taste, of style. We can recognize what we already practice; that we all have ways of writing code that differ.
Starting from this point we can begin developing the practice of Code Criticism. I suggest a simple start, close readings of programs. If we are going to develop any ideas about what code criticism looks like, what its forms ought to be, what theories about it we ought to accept, we need to start by attempting it. Practice almost always precedes theory. 

And yet, I admit that this task is a rather difficult one. Codebases are large things. They are, like paintings, non-linear in presentation. A codebase proper includes not only its current code but also its history. Ultimately we need code criticism that can scale to the size of our codebases. But this is the goal, not the starting point. We must instead start with something manageable. But regardless of where we start, we need this reflection, we need a vocabulary to talk about styles of code. We need criticism to help us navigate what styles we want. We need criticism to help us move forward onto better ways of programming.