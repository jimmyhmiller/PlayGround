# Card Driven Development

Every company I've worked at has practiced what I call "Card Driven Development". Card Driven Development (CDD) is an umbrella term meant to encompass quite a few different development processes. The name comes from the use "cards" (digital or physical) found in the Scrum and Kanban processes as a means of organizing work, but CDD extends further than these two processes, encompasses formal or non-formal processes that have a few things in common. In fact, as I see CDD, some instances of Scrum and Kanban may in fact not be a CDD process, despite heavy use of cards.

CDD first is a way of approaching software development that involves a splitting of responsibilities. In CDD, there must be at least two groups, the first, often called "Engineering" is responsible for technical duties including writing code, maintaining code, and operational concerns like managing servers. The second group, often known as "Product" or informally "the business", is responsible for researching, detailing, and prioritizing what work needs to be done. Product gives work to Engineering, they prioritize what work will be done next, and they message out the status of the work to various interested parties.

This split in responsibility means that the day to day work accomplished by Engineering and Product looks very different. Engineering, when operating well, is about shipping working software to customers, where as Product's work is an act of delegation. This can often lead engineers to believe that Product does nothing, but this could not be further from the truth. Product's days are packed with work. Product's role involves being pulled in many directions, they must keep track of the work in progress, while continuously engaging with the various interested parties vying for their attention; attempting to get their parties particular needs worked on next. Product's work involves status updates, meetings, research, and above all else detailing and prioritizing work for Engineering.

## The Card

This last part is where the Card makes its appearance. The work needed to be done it is too large to write down and detail in its entirety. Even if this task could be achieved, it isn't desirable because by the time it were written down, the facts on the ground may have changed. So a system of dividing work is adopted. In CDD this system is the card.

Cards are a place to describe work that needs to be done and in what order it should be done in. Cards break work into small chunks, typically focused on functionality that some particular party would like. Cards serve as a meeting point for Product and Engineering. Product writes cards, prioritizes cards, and gives them to Engineering as work that needs to be done. Engineering then works in the order given by product. Sometimes this means taking multiple cards at a time and making a time commitment for their completion (often called a sprint). Other times cards are pulled in one by one as time and resources permit (this process is often referred to as a Kanban-style workflow).

As described here the card making process only involves Product. In reality, there is usually a collaboration between Product and Engineering around cards. Typically cards are reviewed and discussed before they ever are handed to an Engineer to be worked on. Often times this discussion process involves creating more cards that need to be completed before the card being discussed can be. Some of these cards may even be "technical cards", cards created and owned by Engineering. With the exception of these technical cards though, cards are ultimately owned by Product. Product has the final say in the priority of cards and also serves as the "acceptor" for the fact that the work described in cards has been accomplished.

The above is meant to serve as a neutral description of what is entailed by CDD. I imagine the process as I describe above will be familiar to many reading this. CDD is a process that many companies adopt and do so for good reason. But despite the best of intentions by companies that adopt CDD, it is ultimately a disastrous process that leads to some of the worst issues plaguing modern software development. My contention is that companies that adopt CDD will inevitably exacerbate these issues, leading to engineer dissatisfaction and ultimately decrease productivity.

## A Bit About Creating Software

Creating software is a complex task. Features, that may seem on the surface trivial, may involve multiple months of effort, minor modifications to an existing process may cause a cascade of required changes across many code bases, and seemingly innocent changes may introduce pernicious bugs. While there are most certainly ways to mitigate these problems, this is the reality the Software Engineer faces. The development of software does not exist in a vacuum, our new code must continue to work with old code, our legacy systems require continual maintenance, and the interactions between pieces of our system continues to grow in complexity. 

Any view about how creating software ought to be done needs a realistic picture of the constraints that Software Engineers face. The software creation process at any given time is constrained by all the decisions of past engineers who had a hand in building the software in question. But this set of decisions involves not only all engineers who have worked at the company, but also the authors of the libraries on which the software is built. The design decisions of past engineers provide deep constraints on how much effort a given change will take. The choice of a relational or non-relational datastore limits the sort of data-integrity constraints we can easily enforce, the library we have chosen for our frontend constrains our ability to support things like server side rendering that may be needed for SSO considerations, and the decision of how to split (or not) our application into services constrains our deployment and delivery strategy, just to name a few examples.

## The Problem with Card Driven Development

Card Driven Development, as I have defined it, is concerned primarily with a division of labor. But with this division of labor comes a division of knowledge. Engineering has knowledge of the software systems needed for the business to operate and Product has knowledge of the various interested parties desires. In themselves, these divisions aren't an issue, but as I hope to show the process of CDD limits the sharing of knowledge across these domains, causing issues for both the software being created and the larger goals of the business.

What precisely do I mean by CDD limiting knowledge? As I'm using this term it implies at least two things. First that the knowledge that is shared between Product and Engineering happens at the wrong level and in the wrong order, limiting the usefulness of the knowledge transfer. Second, that the sorts of knowledge shared between Product and Engineering allows neither to accomplish their job as well as they ought. The recipricol nature of this issue is incredibly important. While someone could questioning if the division between Product and Engineering is healthy at all, what I want to claim is that, even taking for granted the need for this split, CDD causes issues on both sides.

### Wrong Level, Wrong Order

What does it mean for knowledge to be shared on the Wrong Level and in the Wrong Order? Imagine you are a novice cook looking to tackle a recipe a bit above your skill level. You follow the instructions step by step diligently, spending close to an hour on prepping and cooking the ingredients and as you come to the end of the recipe it says, "To finish the dish, poach an egg and place it on top". You immediately become frustrated. While the recipe is telling you everything needed to make the dish, you have no idea how to poach an egg and even if you figure it out, poaching takes time and your dish is already complete.

