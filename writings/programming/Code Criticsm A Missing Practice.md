# Code Criticsm: A Missing Practice

Code is a remarkably aesthetic activity. When you first learn to program this fact might not be obvious. Most of your time will be spent figuring out how to tell the computer what you want it to do. But as you program more, this takes up less and less of your time. Instead you start asking yourself meta questions. Questions about code organization, code simplicity, potential future changes, understandability, flexibility, etc. When contemplating all these questions, you are not merely thinking about algorithms. You aren’t thinking performance. Instead you are going beyond the needs of the computer into the realm of taste, of judgement, of opinion. These topics are constantly on our minds, and yet where in the programming community are these topics fully discussed?

To be clear I don’t mean this issues are completely ignored, but rather than a full robust discussion, they are given dogmatic treatment. Countless books give you prescriptive advice on how you “ought” to code. They tell what “good” code amounts too. But this is precisely not what I’m after. We do not need more rote memorization of a series a best practices, nor a list of patterns you ought to apply, we need to have a better understanding of the aesthetic dimensions of code.

## Structural Beauty

Let me be clear, when I am talking of aesthetic dimensions of code I am not talking about the text itself. Reformatting code does not make it more beautiful in this sense (though that isn’t to say formatting has zero role to play). What I am focusing on instead are the structural choices we make with our code. Some code is strikingly minimal, direct, and transparent, yet perhaps rigid and inflexible. Other code is highly structured, predictable, and regimented, yet perhaps overly verbose and baroque. Yet still, other code is sparse, indirect, and flexible, yet perhaps opaque and hard to trace.

These are all styles that some programmer or other prefers. While some programmers might consider one style or another bad, none of these styles are examples of clearly bad code, code that no one would want to claim as their own. Doubtless if you have explored many codebases, you can think about which ones fit which style here. (Not that this list is exhaustive). More than that, I’m sure you can think of programmers you know and identify which styles they prefer.

And yet, what are the names for these styles? What code bases are exemplars of these styles? How can I go study a particular style and learn to do it well? What are the limitations of a given style? What values does this style convey? What problems are particularly suited to a particular style? Does style actually have any effect on solving various types of problems?

These are all questions to which the programming community has not turned its attention. These are all questions to which there are no resources to turn to. We have neglected style, we have neglected studying our own works in depth. But why exactly? What has kept us from this critical work? What has kept us from identifying style, creating movements, and understanding better the way we code?

## The Beginnings of Code Criticism

I’m not sure I have the answers to these questions other than to point to our collective unease with the subjective. Our belief that anything that is good or true can be quantified. This vestige of the long dead logical positivism still has its hold on us. But we can ignore this. Forge forward, begin a new project built on the assumption of subjectivity, of taste, of style. We can recognize what we already practice, that we all have ways of writing code that differ.

Starting from this point we can begin developing the practice of Code Criticism. I suggest two things we need to jump this program, 1) the beginnings of a shared vocabulary of style and 2)  example close readings of programs. If we are going to develop any ideas about what code criticism looks like, what its forms ought to be, what theories about it we ought to accept, we need to start by attempting it. Practice almost always precedes theory.

And yet, I admit that this task if a rather difficult one. Codebases are large things. They are, like paintings, non-linear in presentation. A codebase proper includes not only its current code, but also its history. Ultimately we need code criticism that can scale to the size of our codebases. But this is the goal, not the starting point. We must instead start with something manageable. But regardless of where we start, we need this reflection, we need a vocabulary to talk about styles of code. We need criticism to help us navigate what styles we want. We need criticism to truly understand our craft. We need criticism to spur us on. To help us see where programming can go, to invite new styles, and perhaps no ways of programming.

