# The Striving Programmer

Programming is an odd activity. It tends to alienate you. Your head is filled with endless words that to “normal” people are meaningless. The moments that bring you joy seem unimportant, and insignificant when you attempt to explain them to others. Whether its drawing that first triangle on the screen, getting a *different* error message, or finally being able to recreate that bug one out of every 1000 tries “consistently”, the activity you are engaged in isn’t relatable to many of the people around you.

When people ask me what I do and I answer software engineer, I often joke that “I have the job that doesn’t start conversations”. It’s a good way to end the awkward silence. But I think this strangeness of programming stretches beyond this insider/outsider distinction. It isn’t only those outside that can find our activities weird, we often do as well.

## The Achievers

Now that might actually sound strange to some of you. There is a group of programmers I call the achievers. This isn’t meant as a value judgment, they just are those who focus on achieving some end for which they truly care about. Think about the indie hackers who makes a beautiful well crafted mac app. Or the indie game developer who has dedicated time into crafting an experience that players can sink themselves into.

It is hard to find the activities of these programmers “weird” at least from the inside. Perhaps we consider them dedicated. But their aims are clearly at something meaningful. They are looking to create something in the world. Things that others will use. Perhaps you are one of them. Maybe you haven’t quite gotten there, you don’t have any hit app. But you are constantly building something, hoping that others will use it and enjoy it.

Then there are those of us who have nothing but a [junk drawer](https://github.com/jimmyhmiller/Playground) of code to show for all their years of programming. Why program if we are not building anything for anyone?

## The Point of Programming

I want to make a claim that I hope is rather contentious.

> Programming isn’t about making working software. It isn’t about solving problems for others. Programming isn’t about anything.

As far back as I can think about my own programming journey, this would have resonated with me. Yet it has taken me years to come to realize and accept it. How could programming not be about making working software or solving people’s problems? This is precisely what we are paid to do. I think this the point we need to start with. Isn’t programming just that thing people pay me for?

## Capitalism and Code

When I started programming I was kid. I had no idea that people got paid to program, let alone how much they got paid. This idea persisted even once I graduated high school. I knew at that point people got paid to code, but I just assumed that what I did was different in kind from what they did. It’s strange to look back at all those years of coding, most of which has been lost to time. I didn’t know about git till much to late. I didn’t think any of the code I made mattered. But there is something there in that early code I still love. The lack of incentives.

Writing code for a living tends to incentive one to write code that looks quite bit different from the code they’d write on their own. There is no one way to characterize all code written for a living, but if we are look for a paradigm example, we need not look any further than enterprise Java. Could enterprise Java exist if no one was paid to write it? It seems doubtful.

Somewhere along the I (and I’m hoping some of you too) forgot about this distinction between the values I hold for my “work” code and the values I hold for code generally. Does my code need to be able to pass code review? Do my comments need to be professional? Or can I scatter long winded TODO comments and musings through out my code? Should I reinvent the wheel or use something off the shelf? My value structure had been warped. For good reason.

Jobs have a tendency to change our values by changing our incentives. I learned not to use certain advance features or patterns because my teammates might not understand. I learned not to reinvent the wheel, because someone down the road might not be able to maintain it. These practices reflected this set of pragmatic values I had come to hold, mostly by seeing them violated. They are (I think) a good set of values that leads to better code in a business setting. But are they anything more than instrumentally good? Is there any reason to hold them outside “the business”?

## Escaping the Office

When you spend 8 hours a day slinging code. it is very hard not to let that activity invade your values you generally hold. But it can also be very frustrating not to inject those values in. I know that many people who’ve worked with me have seen that frustration. I want code to be better. I have lots of opinion on what makes for good code. When I see a codebase that isn’t what it ought to be, it feels like an injustice. It feels wrong in some deep way. But this path is a dangerous path, at least for me.

Once you begin injecting those values you hold outside the office into the office, things get a bit messy. First, you may find yourself at odds with your coworkers. Typically the views we hold outside the office have some tension with those inside. We may value consistency more or less than those around us. We may want to rewrite code that is working, but could be better. We might want to care about performance at the expense of some other cared about metric. For good reasons, our coworkers will resist these changes.

But this is the least of our dangers. Once we begin down this path, only destruction follows. We begin to see it isn’t merely programming in the small that fails to live up to our values, but the whole system. Why are we doing all these things so inefficiently? Why are we stuck with these old technologies? Why can’t we have more performant software? Why even write this stuff at all?

## Striving in Games

What exactly does it mean to be a Striving Programmer. Well, this is a term I’ve adapted from the wonderful book “Games: Agency as Art” by C. Thi Nguyen. Here Nguyen distinction two kinds of players who play games “achievement players” and “striving players”. An achievement player is looking to win. That is their true end. They may want to win for various reasons, money, fame, bragging rights, insecurity, whatever else. But winning matters to them.

The striving player on the other hand takes a different attitude. The striving player is playing the game for the experience of playing the game. But in order to have that experience, they must adopt the goal of winning. Winning isn’t their ultimate goal, it is playing the game and being absorbed in that experience. In order to truly enjoy they game, they need to play to win, but winning doesn’t have independent value outside of the game itself.

Nguyen talks about sports he plays with his wife as exercise. They are both equally good at the game and both strive to win. It makes for very exciting, fun matches. But imagine someone at his gym is a profession in that sport and offers to personally train him. If winning is Nguyen’s goal, shouldn’t he take them up on the offer? But he clearly would not want to, as it would ruin the fun exercise he is having competing against is wife.

## Striving in Programming

I think it is exactly this striving attitude that I’m offering as a way of being a programmer. This isn’t to say being an achiever is wrong. In fact, that would be a very hard thing to argue. All I want to offer is that it is possible to be a Striving Programmer and that it might suit some of you better than the alternatives.

So how do we strive in programming? We adopt the same attitude the striving player does. We adopt ends, not as our true ends, but as ends for a time, in a context. These ends are those that, as we program we truly try to achieve, but they are ends that are disposable. Ends that are subordinate to our true ends. Ends we adopt in order to have an experience rather than being an end in themselves.