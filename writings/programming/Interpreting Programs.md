# Interpreting Programs

James Grimmelmann’s recent article entitled “The Structure and Legal Interpretation of Computer Programs” offers a unique, erudite discussion on the multiple layers of meaning contained in a programs text. Perhaps layer isn’t even the right word here as it implies some sort of hierarchical ordering. Instead Grimmelmann offers us multiple ways in which to consider a programs meaning. Enlightening though Grimmelmann’s article is, I want to turn my attention instead to Marieke Huisman’s reply to the article. Here we find an exemplar work in the kind of rationality found not only in computer science departments, but that has also invaded popular programming culture.

> First of all, the paper introduces several ways to look at the meaning of a computer program. However, in computer science, the meaning of a program is a well defined concept: it is what is defined as the formal semantics of the program. Formal program semantics defines the behaviour of a program in terms of a mathematical object. All other ways that can be used to describe the meaning of a program, need to be equivalent to, or can be derived from this formal semantics. If there is a discrepancy between those, then normally the formal semantics is considered to be the ground truth.

Perhaps if you have not read Grimmelmann’s article, you will not appreciate how stark the constrast is. In fact, given this reply, I think anyone would be safe in concluding that Grimmelmann had simply missed the fact that formal semantics exists. Nothing could be further from the truth. Grimmelmann’s article carefully walks us through three ways we might understand the meaning of a program text. Each method accounting for flaws in the previous. These three methods are “naive functional meaning”, “literal functional meaning”, and “ordinary functional meaning”. Husiman’s assertion that formal semantics (and she later adds formal specifications) are definitive of the meaning of a program text fails to grapple at all with complications Grimmelmann introducing as he motivates the move from “literal functional meaning” to “ordinary functional meaning”.

Now of course, one way of taking Huisman’s statements is obviously true. Computer science does indeed consider the formal semantics of a program to be its meaning. As a statement of fact, this is above reproach. But this was not the point of Grimmelmann’s paper. The inquiry was not into how computer scientists in fact believe they ascribe meaning, but instead how we ought to ascribe meaning to a program text. Is a formal semantics an adequate way to describe meaning to a program text? Grimmelmann gives us convincing reasons to think it is quite a bit more complicated than that.

But this article isn’t meant to enumerate those reasons. Rehashing Grimmelmann’s wonderful paper would serve nobody. What I want to do is two things, first consider Huisman’s reply not in its contents, but as an exemplar of a certain kind of response that has come to typify programming discourse. Second, explore the ways in which this approach limits our thinking and causes us to not understand our own craft.

## Thin Rationality

In many ways it is quite hard to critique Huisman’s reply. Nothing she says in the reply is incorrect. She begins with her statement about formal semantics and continues to enumerate properties like parallelism, exceptions, and out memory errors that cause it to be difficult to specify programs formally. She ends her reply with a call to increase the use of formal specification for programs as it provides certain mathematical benefits. As a stand alone piece, it is just the humdrum of an academic formalist. But when we consider the rhetorical picture as whole, the reply is set in stark constrast.

In Grimmelmann’s original article, he motivates the move from literal functional meaning to ordinary functional meaning by discussing the complications bugs bring to programs. Under what criteria can we consider program behavior a bug? Is it in constrast to the specification? What if the specification is unclear? Is it authorial intent? What if multiple authors are involved? Ultimately, he shows that these notions depend on the community in much the same way that natural language does. Huisman chooses not to engage in any of this.

Huisman’s discussion of bugs simply separates “what” is computed from “how” it is computed. Where the “what” is about the specification. But that is the very point Grimmelmann is concerned with. Can a specification be wrong? It is clear it can. Imagine a specification for python, where due to an oversight, a new feature introduced would cause a backwards incompatible change. This was not caught before the amendment was accepted. Would we now say that the specification can’t be wrong and therefore the behavior is not a bug? Of course not, but if the specification *is* the meaning of the program, how could that not be the conclusion?

Huisman’s side stepping of the very issue at hand is a perfect example of the sort of thin rationality we in computing love. When faced with ambiguity, we choose to define our way out of it. What is the meaning of a program? Whatever we choose for it to be. So used to crafting the reality by which our programs operate, we believe they are shielded from the world. How could a programs meaning be ambiguous? Ambiguity is something we do not countenance.

### Through thick and thin

Why do I call this attitude “thin” rationality? Well it is constrast to a thick notion. Thick and thin have been used to describe various phenomenon, but I think most instructive here is the distinction between thick and thin rules. Thick rules anticipate exceptions, they require intelligent execution of the rules, allowing the rule following to interpret and decide to follow them or not. Thin rules are the simple “if then” of programming. They are rules without exceptions. Consider the rules of chess a thin rule in chess is how the pieces move. A thick rule includes ways to play, situations you may find yourself in, and guides for how to deal with them.

Our programming culture is full of thin rules. Never inherit more than 2 levels deep. Functions should be no more than 20 lines. Don’t use `var` in javascript. But the thinness goes beyond rules into our very way of thinking. Grimmelmann has offered us a thick conception of programming meaning. It allows for exceptions, for ambiguity for complications. There is no decision procedure we can follow to determine the meaning of a program.

Each time we are met with this ambiguity, with thick conceptions, we replace them with thin ones. In fact, I am sure some readers right now are thinking, “Is there truly a difference between thick and thin? Isn’t that just the difference between a simple program and a more complicated one?” This alone should show us how much this though process has invaded our minds.

## Resisting Reality

It is this thin conception of rationality, the implicit belief that whatever we can make sense of can be codified, automated, and put in terms of “if-then” that has caused our culture to be so bland. It is this attitude that we see in the hacker news comment section. It is this attitude that creates the toxic crypto culture. The cyber-liberatarian utopia just is the thin-relationization of society. No longer do we need ambiguous human institutions, we have clear, percise laws of cyberspace.

But in this very conceit lies our own undoing. We ourselves do not actually operate as explanable, thinly conceived reasoners. We have embodied knowledge, we make intuitive leaps, we use rules of thumb, we have taste. Even in our programming efforts, we are more than simple rules. We are more than stipulations.

So why when faced with the ambiguity of meaning in a program do we merely resort to stipulation? Perhaps we just view this as a our proper domain. What we are concerned with are programs and programs can have a well defined meaning. Why wouldn’t we give them that if we can? Well, it depends on our concerns. Do we want to investigate programs in their entirety? Do we want to understanding programming from all angles, to understand the truth of our discipline?

Perhaps the answer is no. Perhaps all we want to do is play the academic or industry game. To accept the framing our social structures have given us. Is it our concern if there is some other way to understand programs? Is it our concern that programs are in fact more than just technical artifacts and include the social? Maybe we just don’t care.

## A Call for Thick Rationality

If I’m honest I find it incredibly saddening that we have outsourced our discussion of these more ambiguous aspects of computation to the social sciences and law. Grimmelmann’s analysis of program meaning is incredibly enlightening but lacks a view from the inside. Programs are internally rich with meaning, conflict of intentions abound, bugs often appear at these boundaries. A programs meaning is often dependent on its history, what was this program in reaction to? A program does have a meaning that involves its function, but it also contains concepts that aren’t immediately apparent from its behavior.

We have created artifacts ripe for study. We have before us a human creation of great complexity and ambiguity and yet we choose to ignore it. If we attend to this complexity at all it is only in the form of empirical study, a very unenlighting approach to the fundamentals of our endeavors. We live in this place of meaning ambiguity, in a place of process ambiguity. We have not examined our practices or our concepts to find the thick notions underlying them. Instead we tell ourselves the lie that stipulation is enough. If we are to ever understand what we do, we must give this up.