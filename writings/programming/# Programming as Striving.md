# Programming as Striving

Peter Naur in his essay “Programming as Theory Building” offered us an analysis of what programming is. Perhaps analysis isn’t quite the right term. What Naur offered was not critieria jointly necessary and sufficient for an activity to count as programming. In fact, it is hard to know what to make of Naur’s characterization. In one guise he seems to be offering a necessary criteria. Programming must be theory building in order to properly be the activity it is. On this reading ChatGPT cannot program. But on another reading, Naur is merely giving us a lense through which to view programming. Programming *as* theory building is asking us to take this view and see what follows.

I want to be a bit more explicit in what I propose here. I am attempting neither of Naur putative projects here, though my project may find a kinship with the latter reading of Naur. Instead I want to talk about a particular way of interpreting our activity of programming. Or perhaps I want to offer an attitude one can take when programming. To put it another way, Naur explores what programming is, I want to explore what programming can mean.

## The Meaning of a Program or the Meaning of Programming

Our project might easily be confused with a similar sounding project namely: what is the meaning of a program?  While an important project in its own light, we will not endorse any answer to that problem here, but it might be illustrative question to begin with as a means of clarify what is meant by our project.

What are we looking for when we inquire into the “meaning” of a program? Well, much like when we are interpreting a prose text, we are trying to make the text intelligible. One answer to this question in programming is to assign some form of semantics to the structures in our program. Given this semantic, we can claim that the “meaning” of a program just is the value this semantic picks out when applied to our program. If we have an operational semantic, it might be a series of state transformations, if we have a denotational semantic, the meaning may consist in some well defined mathematical object.

This notion of meaning is rather narrow. It is useful in all sorts of formal settings, but it clearly does not exhaust what is meant by “meaning” of a program. Consider a court attempting to understand if a program constitutes fraud. Assigning a semantic to the program text hardly helps in that effort. But even in more mundane cases of every day development, formal notions of meaning are not enough. What exactly the “meaning” of a program is, is a large undertaking. (For an exploration of this in the legal context see Grimmelmann).

The notion we are exploring of “meaning” is even more expansive. In asking what a program means we are asking something analogous to its “linguistic” meaning. For our purposes, we are instead looking for something a bit more personal. How can one find “meaning” in the act of programming itself, or to put it another way: What is the point of the activity of programming? Where does the act of programming get its worth? What are (should be) our motivations for programming?

## Instrumentalism

This task may seem a fools errand. There is no “meaning” to programming. Just as there is no “meaning” to life. If this were our project, it would indeed seem worthless. What I want to argue here is not that all acts of programming have some ultimate end, I am instead offering a way in which people can ascribe meaning to their acts of programming. But that is not quite right either. What I want to claim is that there is a legitimate way of finding meaning in programming that might, at first blush, not seem legitimate. This is what I call the *striving* approach to programming. Or to put it negatively the *anti-instrumental* approach to programming.

What does it mean for an approach to finding meaning in programming to be legitimate? This is a difficult question. It might seem that given there is not one right and true way of finding meaning in programming, that all methods of finding meaning in programming are legitmate. But a moments reflection finds that this is clearly not true. Imagine Bob has decided to program because he believes that programming will make him a more desirable romantic partner, for anyone he happens to talk to. Bob begins programming and finds his meaning in the fact that as he learns more and more esoteric features of C++ his romantic desirablity increases. Clearly Bob has made a mistake somewhere along the way.

But it isn’t merely unrealistic examples like this which may be illegitimate. Perhaps one finds meaning in programming because they believe they are creating good effects in the world. For example, they believe that their program will create better economic circumstances for the disadvantaged. Perhaps instead a their program actually creates a worse economic situation for the disadvantaged and in turn destroys the environment by that vast amount of computing resources it uses. (See cryptocurrency)

But let’s ignore these specific examples and be a bit more abstract. I think most people implicitly believe something like the following: Programming is about creating some program P and through the running of P, we achieve some good G; this G is the meaning of our activity. This might seem all a bit too vague. So let’s fill in the details. Perhaps you are creating a program to help disadvantaged people find needed resources. People using your program allows them to find the need resources. Perhaps you create an open source program that allows other people to achieve their ends, your good is the fact that you are helping them achieve there good. Or perhaps you create a program for a company that allows yourself to be paid and have money for your family. The exact way in which these indirect effects tie up might be a bit complicated. But the point is that in all of them the meaning you derive from program is derivative from some other good.

This sort of instrumental view is, I believe, implicit in almost all discussions (direct or indirect) about the meaning of programming. Programmers are supposed to make something that will be used by others. Our job is to make and build and for others to use what we make or build. Perhaps some of our programs won’t be used because we make them to learn, but even here, the learning is merely a means to get to the point where we can make a program others will use. My goal here is to show you a way to find meaning in programming that does not rely on this sort of instrumental good.

## Anti-instrumentalism

How could programming find meaning without appealing to any instrumental good? How can our activity have value if it isn't providing good in the world? This is precisely the difficult question we must uncover. In fact, in our modern way of discussing goods, it is hard to even talk about. What makes art good? The enjoyment it brings to its viewers. Why do you read? Because I learn things I might be able to use later. Or because it helps me relax. How can anything be meaningful if it isn't causing good effects?

I don't have the space to defend this view here. I will merely take it for granted that this is a coherent concept. I can find meaning in reading without appealing to any particular good. My relationship with a signifcant other can be meaningful apart from the goods it creates in my life. That isn’t to say these activities don’t also have good side effects, just that the meaning I find in them need not appeal to those goods.

But merely stating this does not seem to be enough. If I am going to defend an anti-instrumental view of programming, don’t I need to provide some reason to think such concept is viable? I do think I have this burden. But rather than atttempt a direct defense, we will defend it indirectly.

### Two ways to play games

In “Games: Agency as Art”, C. Thi Nguyen explores two kinds of attitudes players can take towards a game. A player may be an achievement player, playing with winning as their true end. Perhaps they are playing in a tournament aiming to win money, or the olympics to win a medal, or simply with a group of friends for bragging rights. Regardless, the player has set their true end to be to win the game. Nguyen contrasts this with the Striving player. A Striving player does not have winning as their true end. Instead, winning is goal they take only as a means of playing the game. In the play frame, they want to win. Their actions in the game are those that will hopefully cause them to win. But winning isn’t taken as their ultimate end.

Any one who has played enough board games can relate to this distinction. There is always that one friend in the group who is an achievement player while the rest of the group is simply striving. Or perhaps there is that player who is neither. They don’t want to win, even in the striving sense and drag out the game, or simply troll others. (If you don’t recognize either of these kinds of people, you might want to look at yourself). There is of course nothing wrong with playing to achieve, but there is also nothing wrong with striving.

When one plays a game with a striving attitude, they aren’t doing so because they believe winning the game will provide them some good. Instead they are playing with the experience that striving brings. There is a certain kind of experience that games bring that cannot be achieved without the adopting of winning as an end. This is what the striving player is after.

### Programming as Striving

I believe this same kind of striving attitude can be applied to programming without any loss. There are those who program for the end it brings. They want to create the program they build. They want to be paid for their work. They want others to use their software. Whatever the motivation, their ultimate end is the creation of the program. They truly care about creating that program.

Just as the striving player wants to win only in the play frame, the striving programmer only wants to create they program in the “programming frame”. Creating a program isn’t the ultimately end of the striving programmer, simply the aim the take on to have the experience of building that program. It is only by adopting that end that they can have a certain sort of experience. 

## How does striving differ at all?

