# Conceptual Engineering and Programming

It is almost a truism that code isn't written *just* for the computer, it is written for other humans to understand as well. But what does this truism amount to? Typically it means that we ought to leave comments, we ought to name functions well, we should try not to be too clever with our code, and all sorts of other advice people generally give about writing good code. My aim is to show that this sort of advice sells our programs short, it leaves out a crucial function that our code serves and an activitity that we as programmers are constantly engaged in (even if we aren't aware of it). This is the role of Conceptual Engineer.

Conceptual Engineering here is not meant to be synonymous with software engineering. Conceptual Engineering is the process of creating and refining concepts and advocating that others adopt these concepts. Engaging in conceptual engineering is a process of trying to fix language, of trying to provide others with a new way to think about problems. Looking at the history of programming, we can see all sorts of examples of conceptual engineering, for instance, the creation of OOP. Creating OOP was not about writing some program or other; it was creating a new way of viewing programs. Programs viewed through the OO lense consist of objects that pass messages to one another. Under OOP communication is computation.

But software doesn't have a lock on conceptual engineering, it exists across disciplines. Einstien's redefinition of simultaneity to be perspective relative, Frege's notion of Sense, Raphael Lemkin's coining of the word Genocide. In some of these cases the meanings of old words are modulated to provide new meanings, in others, words are created to capture a particular concept. But all of these cases have something in common, they are attempts to change the way people approach certain questions and problems. Conceptual Engineering attempts to change the meaning of words in certain contexts, sometimes expounding on them, other times changing them entirely, but always with a certain aim in mind.

But clearly the activities we undertake in our day job are not that of creating a new programming paradigm or a new scientific theory. So in what way does the average programmer perform the role of conceptual engineer? My contention is that the whole process of building a code base is the process of conceptual engineering. Building a code base involves the building of a conceptual vocabulary, of explicating the relationships between the various words, and modulating their meanings through the ways in which we employ them. And further, that paying careful attention to this process can lead us to better code, code that does communicate to humans, not because the code employs words in their original meanings, but because by its nature it refines them and argues for this new perspective.

## Conceptual Engineering a Code Base

The process of conceptual engineering looks quite a bit like coding. Conceptual Engineering isn't some upfront design process, it isn't building a bunch of UML diagrams, it is a way of seeing our code base. Whether we intend it or not, people will infer meanings about the words in codebase by the way we use them, by the way we structure elements of our programs, and by the way we arrange its various parts. Conceptual Engineering is the process of considering what effects these elements will have. To see this, lets start with an example.

### Users, Customers, Third Party Providers, and Support

Imagine that in our business domain we have three different types of users of our system. First there are our customers, the people who pay us for the service we provide. We provide them an interface that gives the information they need and allows them to update the information that is important for their business. We also have third party providers. These are not people who directly use our system for their work, instead they are inputting data into our system for use by our customers. Finally we have our own internal support people. They have an administration interface and are able to make changes that are needed on a customer or third party provider's behalf.

How should we represent these uses cases in code? Do all of these different people, with different uses of our system, count as "Users"? Should we represent them in the same way or should they be separate concepts? How should these concepts be related to each other? For many coming from an OO background the word inheritance might come to mind. Let's look at what advice Martin Folwer in his book refactoring on when to "Extract a Superclass" to understand the wrong way to approach this problem.

> Duplicate code is one of the principal bad things in systems. If you say things in multiple places, then when it comes time to change what you say, you have more things to change than you should. One form of duplicate code is two classes that do similar things in the same way or similar things in different ways. Objects provide a built-in mechanism to simplify this situation with inheritance. 

In the context Fowler is talking about refactoring, but you can imagine the same advice in the context of creating code. If we want to know should we represent customers, third party providers, and support people using some common superclass, we could ask "Will we have lots of duplicate code if we don't?". I think this advice is thinking on the exact wrong level. What our code looks like is not the determining factor for how to represent our concepts. Instead we ask what we want to communicate, choose our representation, and ensure that our code reinforces this choice.

### Choosing Representations

Code duplication is bad or good depending our context and purposes. Perhaps we know that in the future these uses cases will diverge considerably. Perhaps we know that some use case will be removed in the near term future. Or maybe, we are going to be splitting this single application into multiple smaller applications. Here code deduplication cuts against our purposes, inhibiting us, rather than enabling us. But we have to not only consider our purposes, but those other developers who find themselves in our code base. Those who lack context, who do not know the plans we have for the future, or do not understand our business domain or the purpose and scope of this application.

The way we choose to represent users in this system will communicate to these new developers (by new I mean new to this code base not how long they've been programming). They will learn which parts are related in what ways by the names we give things and by the structures we place them in. We must consider the purposes of our code, the potential changes it may have, as well as the biases and purposes of other developers who approach our code. This will determine what structure our representation should take. But not only this, it will determine when/how to change this representation. If the purposes of parts of our system differ, our representations will change as well.

This advice is in many ways unsatisfying as it does not lend itself to some definite criteria or rule of thumb. There is a tendency to reduce our code to something that is merely an artifact, something that given the right application of the right rules will be good. But this isn't the way code is. Code contains in it the intentions of the people who wrote it. It exists in an ever changing context as a tool for communication. 

### Bring Back the Concepts

We have considered what criteria we ought to use for representing our notion of user, but how does this relate to conceptual engineering. Well, our choosing of a structure is a mental act, we consider the purposes and plans involved in the lifetime of this project as best we can and decide on a representation. Now we must encode and communicate those choices in code. To do this we must choose names for the concepts we are going to represent. If we are going to successfully communicate these concepts through our code, we must utilize them properly in our codebase.

Let's try to make things concrete. Perhaps we've decided that for our purposes Customers, Third Party Providers, and Support People are actually distinct concepts. That despite these being general "users" of our system, they do not truly belong to the same category. We can now imagine all sorts of ways that we will fail to communicate this to new developers who look at our code base. If we are in an OO language, making these three concepts share a common base class will allow programmers to easily conflate these three distinct concepts. In a dynamic language, if we have a function that only works properly for Customers but we call it `performActionForUser` we are inviting people to conflate yet again.

Perhaps things are a bit more complicated than this. Maybe there are "healthy" conflations and "unhealthy" ones. When it comes to authorization, it is healthy to conflate this concepts. We may have a generic system of authorization that is agnostic to what sort of things it is checking authorization for. But maybe for billing, conflating these notions would be unhealthy. First most obviously, Support People shouldn't be billed but perhaps as well our Customers and  Third Party Providers may have very different ways they are billed. Customers may be usage based, whereas our Third Party Providers have a negotiated flat rate. 

This is where commitment to communication becomes increasingly important. The techniques and choices we make we will be particular our context as well as our language. But I will try to sketch ideas here of ways to approach this. First, we can separate our code in a way that makes this clear. By that I don't necessarily mean go and make a ton of classes and modules. I mean ensure that if someone is asking a question about Customers, they don't have to wade through a bunch of Third Party Provider code to try extract out what is going on. A guiding principle here is thinking about our code as an information repository and consider how quickly someone could answer their question by looking at your code.

We can also come up with our own terms for things that aren't necessarily entities in our domain. Perhaps we want to talk about people who use our system who do not work for us. Maybe these are "external users" or "end users". Perhaps Customers is actually quite a bit more complicated than what I've given here and that while it useful to talk about Customers, some subset might actually have something in common with Third Party Providers. In all these cases, we have consider the names we call these things and then ensure to use them in ways that correspond to their concepts.

### Out of the Domain

Now what I've been talking about here could be called domain modeling, but I want to be clear that this is merely an example of Conceptual Engineering, not its sum and total. There is also conceptual work that exists outside our domain and is instead only the purview of the code. A classic example is [MVC](https://blog.codinghorror.com/understanding-model-view-controller/). MVC is an attempt at conceptual engineering that tells us we ought think about any bit of our code as belonging to either the Model, the View, or the Controller. Think about code you have worked with that bought into the MVC model. Did it stay true to that model? Was there a clear separation between these various features? If so, that code base might count as a successful instance of conceptual engineering.

Our code base contains these same sorts of concepts. Perhaps we are adopting an existing pattern like MVC or creating our own way of organizing things. Regardless, we must take care to communicate these patterns successfully. When we talk about leaky abstractions, this is almost always what we are talking, unsuccessful attempts at conceptual engineering. The leaks can be caused in two ways that we often conflate. The first is what we take ourselves to mean by leaky abstractions, some concept isn't complete, it doesn't cover the cases it is attempting to cover, and considerations outside the concept becoming increasingly important and threaten to distablize the code. The second sort is more subtle. Is MVC a leaky abstraction? In some code bases it certainly feels that way. But this isn't because of MVC itself, but rather because the developers working on it aren't fully convinced of the MVC approach. The task of conceptual engineering is both in establishing concepts and in persuading others to adopt them, failing to accomplish this latter half can leak to code chalk full of leaky abstractions.

## Persuasion and Conceptual Engineering

Persuasion is the most difficult aspect of attempting conceptual engineering. Given a large enough group of people, there will be differing opinions of how things ought to be, different warring conceptual organizing principles fighting for control. This is why code bases written primarily by a handful of programmers are cleaner than those written by large groups. This is why microservices have emerged as a fix to organizational issues rather than merely technical ones. Changing the way people think about the code they are writing is a difficult task. Convincing people of anything is difficult. There are no arguments, on any topic, that every rational person will accept. Our views on any topic are intertwined with our views on other positions we hold and on the relative weight we place on each. If we are going to be successful conceptual engineers we cannot ignore this complexity.

I say all of this to make clear one thing, a conceptual argument is not an argument about the technical, objective merits of a given solution. Arguing that your solution runs faster, is fewer lines of code, can scale better, etc will not always convince people your solution is better. This can be incredibly frustrating and it is easy to paint those who disagree as being irrational. Considering these disagreements through the lens of conceptual engineering helps us understand where the disagreement occurs and lets us understand how those who disagree are well within their rights.

### What is at Stake?

Technical arguments don't live isolation. Perhaps you are convinced of the merits of functional programming and your coworkers are staunchly on the side of OO. Talking about the ability to reason about your code, the dangers of side effects, and the benefits of purity for things like concurrency are unlikely to convince anyone. What is at stake is not the technical merits of one technique over another, it is a conflict over what is the best way to conceptualize the work you are doing. Changing from OO to FP isn't a matter of just changing code, it is a matter of changing the way we think and see to world.

Understanding this can help us take the long view when it comes to making technical changes. People must be convinced that our concepts are comprehensible and that they will serve their purposes well. In order to do this technical arguments are not enough. People are not worried about the technical merits of your solution. They are worried about the unknown, the parts they don't understand, the gaps that may exist that they can't see. When employing new concepts, we can't predict the outcomes of them. We can't understand where they may lead until we embody them, until they are shown to us.

### Convincing Well

Convincing people is a difficult task, but once we've properly placed what it is we are trying to convince them of, things do become easier. Our task is convince others not that our solution is better, but that adopting our conceptual vocabulary will help them achieve their goals. How can we do this? By employing these concepts consistently and pointing out where our concepts can help them. As an all too brief example, imagine that you are trying to convince a coworker that functions should be pure, rather than going on about their merits, talk to them about them in context. Perhaps you are helping them debug some narly bug that at the end of the day was caused by mutation. Talk about it, show them how had we modelled things immutably, this bug would not have been possible. Only when people see our concepts in action will they be convinced of their cogency.

## Becoming a Better Conceputal Engineer

We have looked at a few ways Conceptual Engineering plays a role in our code bases. While we have stayed at a thousand foot view, I hope that the examples here have shown its broader applicability. Conceptual Engineering is a process we are engaged in whether we are aware of this or not. We are constantly attempting to transform discourse, transform the way a problem is thought of. How can we be better at this? First, we can begin by practicing consistently employing concepts in a code base. We can start a code base with the intent of exercising a particular concept. To see a great example of this, check out Steve Losh's [List Out of Lambda](http://stevelosh.com/blog/2013/03/list-out-of-lambda/). Finally, something I've found personally useful is reading Analytic Philosophy. Analytic Philosophy is British and American philosophy that focuses both on rigour and clarity. It is in many ways a study in conceptual engineering. If we as programmers are to becoming better at this task, perhaps we should learn from those who have been doing it for much longer.

## Notes to Self

Not bad, but doesn't flow as well. Need to define good sections