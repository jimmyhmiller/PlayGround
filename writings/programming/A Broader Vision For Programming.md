# A Broader Vision For Programming

There is a flurry of activity, mostly by academics and hobbyists, exploring the future of programming. These explorations often follow broad themes. There are those who are interested in making programming more inclusive, by changing what it means to program. These include movements like, no-code, low-code and more broadly, end-user programming. There are those who seek to change the tooling around programming, general, ridding our selfs of text files. The most prominent of these are structural editing and visual programming. I find these approaches to the future of programming to be incredibly interesting avenues to explore and full of useful lessons. Yet at the same time I don't see them solving the issues I have. In this blogpost I want to talk about the problems I face as engineer and explore some potential solutions. (Need better intro)

## Programming is not Primarily a Making Activity

> A second reason why modern software is dominated by mechanical metaphors is that, for the people who create software, the computer *is* a machine. The programmer lives in manipulation mode; she drives her computer as if it were a car. Thus, she inadvertently produces software that must be operated like a machine, even if it is *used* as a newspaper or book. - Bret Victor "Magic Ink"

In Bret Victor's fanastic essay Magic Ink, he explains why mechanical metaphors rule end user software. As progammers we think about computers as machines. We are the ones building software. We are the ones constructing things. We are the ones driving the mechanical machine. This mode of interacting with computer leaks into our construction of programs for end-users, but it also leaks into our software for other programmers. We have taken this one aspect of programming and set it as primary. Even as we look at these future of programming projects, we can see that this thinking prevades every thing we do. Programming is about creation, so how can we make the creation process better?

Focusing on construction is completely natural. At the end of the day, software must be written if we are going to program. Yet, as a professional programmer, it is rarely the constructing of the program that is difficult. Certainly, there are language features or lack there of, that get in our way. There are the occasional algorithms that require some thought. There are things that are repeatitive and full of boilerplate that we'd like to get rid. All of this is true and yet in my experience, these things add up to very little of the difficulty in programming.

More often than not, the difficult part of programming something is fitting your new code into an existing structure. Programming is not like constructing a building or a bridge, nor is it even like remodeling. Programming is much more akin to Constitutional Law. As software engineers, we step into code bases with long histories. Even in relatively new codebases, there is a vast history of intentional acts by other people that restrict our actions. Every decision by a past programmer has some impact on what is easy for me to do today and what is difficult. It has an influence on how we write future code. Code bases are large books full of rules, precedence, and implict arguments that we must work to understand. Only once we understand them can we begin to figure out how our contribution fits.

## Tools for Reconstructing History

On this view of programming. Programming in existing system is primarily a task of historical investigation. Understanding the past decisions of our software enables us to make future change. We spend a ton of time trying to understand not what our software does on some line of code, but why are software is the way it is. What problem was it trying to solve at the time? What constraints did it have? What older versions of the software was this code written in contrast to? Were there painpoints or failures that made us avoid something that seems like the more obvious solution? All of these questions are things we must ask and answer in order to know how to truly evolve out codebase to where we want it to be.

What tools do we have for understanding the history of software? Code comments, external documentation, and git history? Are there any others? Do our languages or programming systems put thought into providing these features? Would we better understand the history of our software, the context of its creation, the views of those that created it, if we moved to no code, low code, structural or visual programming? Do these initiatives make any impact in these areas? If we are to improve programming, this is a problem we must address. We must develop tools that allow us explore these historical circumstances. Tools that help us to reconstruct the purposes of our software that are implicit in their structure.

### Is History Recoverable?

The sort of history we are interested in recovering is not a list of facts or a list of decisions. Lists of facts are of course useful for our endeavor, but their existence isn't our end goal. The history we seek is not a set of objective observations, but rather a critical, biased approach. An approach that looks to make sense out of the facts, that aims to understand them in some framework in order to accomplish the tasks needed for the maintanence and modification of the system. This sort of history is what Peter Naur called a "Theory".  I have [written previously](/incommunicability) about Naur's radical thesis that communicating a theory of a programming is strictly impossible. Since this is the case, isn't what we are attempting to achieve here, recovering the history of a program so that we can know its theory also impossible? Simply put yes.

> A very important consequence of the Theory Building View is that program revival, that is reestablishing the theory of a program merely from the documentation, is strictly impossible. Lest this consequence may seem unreasonable it may be noted that the need for revival of an entirely dead program probably will rarely arise, since it is hardly conceivable that the revival would be assigned to new programmers without at least some knowledge of the theory had by the original team. Even so the Theory Building View suggests strongly that program revival should only be attempted in exceptional situations and with full awareness that it is at best costly, and may lead to a revived theory that differs from the one originally had by the program authors and so may contain discrepancies with the program text.

We can never reconstruct the original theory of a program, it is inextricably connected with the creators of the codebase. And yet, we find ourselves have to work on codebases all the time where the original authors are gone. Yes, our codebases might not be 100% dead, we often know some little bit about the theory the original creators had. But far too little for what we need to accomplish. So we must shift our focus away from trying to recover the original theory, to instead coming up with our own theory. This is exactly what we are doing when we work with "legacy code". Naur writes about exactly what this process will look like.

> The point is that building a theory to fit and support an existing program text is a difficult, frustrating, and time consuming activity. The new programmer is likely to feel torn between loyalty to the existing program text, with whatever obscurities and weaknesses it may contain, and the new theory that he or she has to build up, and which, for better or worse, most likely will differ from the original theory behind the program text.

How can we make this process less frustrating? How can we allow programmers to build up a theory about an existing system faster? How can we make sure that we reduce the impendance mismatch between the old theory and the new? These are the things our tools and techniques must support.

### The First Steps

Tools for documenting software are focused exclusively on communicating with others. This means that when documentation exists, it can communicate things like intent in prose to others. But it also means that if past people didn't decide to document their code, these tools are completely useless for an individual. More than, communicating your thoughts with others is much harder than communicating with yourself. Where are our tools for documenting code for personal use? Why do our languages not accommodate this?

