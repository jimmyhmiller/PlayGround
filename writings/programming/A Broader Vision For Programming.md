# A Broader Vision For Programming

There is a flurry of activity, mostly by academics and hobbyists, exploring the future of programming. These explorations often follow broad themes. There are those who are interested in making programming more inclusive, by changing what it means to program. These include movements like, no-code, low-code and more broadly, end-user programming. There are those who seek to change the tooling around programming, general, ridding our selfs of text files. The most prominent of these are structural editing and visual programming. I find these approaches to the future of programming to be incredibly interesting avenues to explore and full of useful lessons. Yet at the same time I don't see them solving the issues I have. In this blogpost I want to talk about the problems I face as engineer and explore some potential solutions.

## Programming is not Primarily a Making Activity

> A second reason why modern software is dominated by mechanical metaphors is that, for the people who create software, the computer *is* a machine. The programmer lives in manipulation mode; she drives her computer as if it were a car. Thus, she inadvertently produces software that must be operated like a machine, even if it is *used* as a newspaper or book. - Bret Victor "Magic Ink"

In Bret Victor's fanastic essay Magic Ink, he explains why mechanical metaphors rule end user software. As progammers we think about computers as machines. We are the ones building software. We are the ones constructing things. We are the ones driving the mechanical machine. This mode of interacting with computer leaks into our construction of programs for end-users, but it also leaks into our software for other programmers. We have taken this one aspect of programming and set it as primary. Even as we look at these future of programming projects, we can see that this thinking prevades every thing we do. Programming is about creation, so how can we make the creation process better?

Focusing on construction is completely natural. At the end of the day, software must be written if we are going to program, so we must have a story around. And yet, as a professional programmer, it is rarely the constructing of the program that is difficult. Certainly, there are language features or lack there of that get in our way. There are the occasional algorithms that require some thought. There are things that are repeatitive and full of boilerplate that we'd like to get rid. All of this is true and yet in my experience, these things add up to very little of the difficulty in programming.

More often than not, the difficult part of programming something is fitting your new code into an existing structure. Programming is not like constructing a building or a bridge, nor is it even like remodeling. Programming is much more akin to Constitutional Law. As software engineers, we step into code bases with long histories. Even in relatively new codebases, there is a vast history of intentional acts by other people that restrict our actions. Every decision by a past programmer has some impact on what is easy for me to do today and what is difficult. It has an influence on how we write future code. Code bases are large books full of rules, precedence, and implict arguments that we must work to understand. Only once we understand them can we begin to figure out how our contribution fits.

## Tools for Reconstructing History

On this view of programming. Programming in existing system is primarily a task of historical investigation. Understanding the past decisions of our software enables us to make future change. We spend a ton of time trying to undertand not what our software does on some line of code, but why are software is the way it is. What problem was it trying to solve at the time? What constraints did it have? What older versions of the software was this code written in contrast to? Where there painpoints or failures that made us avoid something that seems like the more obvious solution? All of these questions are things we must ask and answer in order to know how to truly evolve out codebase ot where we want it to be.

What tools do we have for understanding the history of software? Code comments, external documentation, and git history? Are there any others? Do our languages or programming systems put thought into providing these features? Would we better understand the history of our software, the context of its creation, the views of those that created it, if we moved to no code, low code, structure programming or visual programming? Do these initiatives make any impact in these areas? If we are to improve programming, this is a problem we must address. We must develop tools that allow us explore these historical circumstances. Tools that help us to reconstruct the purposes of our software that are implicit in their structure.