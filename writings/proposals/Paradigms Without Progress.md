# Paradigms Without Progress: Kuhnian Reflections on Programming Practice

## Abstract

Borrowing from Thomas Kuhn's definition of a paradigm, Robert Floyd introduced the notion of a programming paradigm in his 1978 Turing Award acceptance speech. Ever since, this idea has infected the software world, becoming an organizing principle for jobs, conferences, and research. But further than that, it has become a ground for interminable debate and disagreement. 

In order to help us understand this unfortunate situation, we will explore Thomas Kuhn's notion of a paradigm. Kuhn's paradigm is much richer than our ordinary everyday understanding; it is not merely a way of approaching problems, but is itself the system in which problems are made intelligible. We will discover the ways in which paradigm is apt for discussing the activities of the software world, and the ways in which our usage of the word deviates from its history. We will then explore these insights showing how they might apply in specific circumstances not typically considered. Finally, we will talk about philosophy's place in computer science's practice and possible avenues for further exploration.

## What you will learn

We will not focus on the substance of debate between the various partisans of programming paradigms (object oriented, functional, and imperative being the most popular). Nor will we try to bridge the gap, finding some synthesis to make all parties agree. Instead we will explore the philosophy of science background that gave rise to these ideas. Focusing primarily on Thomas Kuhn, we will explore the notion of a paradigm and the ways in which paradigms are created, maintained, and discarded. 

Next we will evalute the ways in which our usage of paradigm aligns with Kuhn's. We will consider the ways in which this alignment impacts these programming paradigms debates and further consider Kuhn's notion of incommensurability. Can we borrow insights from the history of science to better understand our own practices? Can find a compelling reason for why these interminable debates seem to plague the software world at large? Next, we will consider ways in which our usage of paradigm diverge from that of Kuhn and consider other areas of software practice where Kuhn's ideas may apply more directly.

Finally we will consider philosophy's impact on programming. Setting aside the ever popular discussions around Artificial Intelligence, we will begin by exploring how philosophy shaped foundational elements of computer science. We will explore under appreciated applications, especially those insights from Turing Award winner Peter Naur. Finally, we will look at areas where further insights may be gained in the future.