<!DOCTYPE html>
<html>
<head>
    <title>Array Alignment Test</title>
    <style>
        body { margin: 0; padding: 20px; font-family: monospace; font-size: 11px; }
        #log { white-space: pre; }
    </style>
</head>
<body>
    <h1>Array Alignment Test</h1>
    <div id="log"></div>

    <script type="module">
        const log = document.getElementById('log');
        function addLog(msg) {
            log.textContent += msg + '\n';
            console.log(msg);
        }

        async function testLayout(testName, shaderCode, quadData, description) {
            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice();

            const module = device.createShaderModule({ code: shaderCode });
            const layout = device.createBindGroupLayout({
                entries: [
                    { binding: 0, visibility: GPUShaderStage.VERTEX, buffer: { type: 'read-only-storage' } }
                ]
            });

            const pipeline = device.createRenderPipeline({
                layout: device.createPipelineLayout({ bindGroupLayouts: [layout] }),
                vertex: { module, entryPoint: 'vs_main' },
                fragment: { module, entryPoint: 'fs_main', targets: [{ format: 'bgra8unorm' }] },
                primitive: { topology: 'triangle-strip' },
            });

            const quadBuffer = device.createBuffer({
                size: quadData.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
            });
            device.queue.writeBuffer(quadBuffer, 0, quadData);

            const bindGroup = device.createBindGroup({
                layout,
                entries: [{ binding: 0, resource: { buffer: quadBuffer } }]
            });

            const texture = device.createTexture({
                size: { width: 400, height: 400 },
                format: 'bgra8unorm',
                usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
            });

            const encoder = device.createCommandEncoder();
            const renderPass = encoder.beginRenderPass({
                colorAttachments: [{
                    view: texture.createView(),
                    clearValue: { r: 0, g: 0, b: 1, a: 1 },
                    loadOp: 'clear',
                    storeOp: 'store',
                }],
            });

            renderPass.setPipeline(pipeline);
            renderPass.setBindGroup(0, bindGroup);
            renderPass.draw(4, 1, 0, 0);
            renderPass.end();

            const bytesPerRow = Math.ceil(400 * 4 / 256) * 256;
            const buffer = device.createBuffer({
                size: bytesPerRow * 400,
                usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
            });

            encoder.copyTextureToBuffer({ texture }, { buffer, bytesPerRow }, { width: 400, height: 400 });
            device.queue.submit([encoder.finish()]);

            await buffer.mapAsync(GPUMapMode.READ);
            const data = new Uint8Array(buffer.getMappedRange());

            const idx = 200 * bytesPerRow + 200 * 4;
            const r = data[idx + 2];
            const b = data[idx + 0];

            buffer.unmap();

            const pass = r > 200 && b < 50;
            addLog(`${testName}: ${pass ? '✅' : '❌'} (R=${r} B=${b})`);
            addLog(`  ${description}`);
            addLog(`  Data: ${quadData.length} floats = ${quadData.byteLength} bytes\n`);
            return pass;
        }

        async function main() {
            if (!navigator.gpu) {
                addLog('❌ WebGPU not supported');
                return;
            }

            addLog('=== Testing Array Alignment in Background ===\n');

            // Test 1: Background with array but NO gradient_angle before it
            await testLayout(
                'Test 1: Background with colors array (simplified)',
                `
struct Bounds { origin: vec2<f32>, size: vec2<f32>, }
struct Hsla { h: f32, s: f32, l: f32, a: f32, }
struct LinearColorStop { color: Hsla, percentage: f32, }
struct Background {
    tag: u32,
    color_space: u32,
    solid: Hsla,
    colors: array<LinearColorStop, 2>,
}
struct Quad { order: u32, border_style: u32, bounds: Bounds, content_mask: Bounds, background: Background, }
@group(0) @binding(0) var<storage, read> quads: array<Quad>;
@vertex fn vs_main(@builtin(vertex_index) vid: u32) -> @builtin(position) vec4<f32> {
    let uv = vec2<f32>(f32(vid & 1u), 0.5 * f32(vid & 2u));
    let pos = uv * quads[0].bounds.size + quads[0].bounds.origin;
    let ndc = pos / vec2<f32>(400.0) * vec2<f32>(2.0, -2.0) + vec2<f32>(-1.0, 1.0);
    return vec4<f32>(ndc, 0.0, 1.0);
}
@fragment fn fs_main() -> @location(0) vec4<f32> { return vec4<f32>(1.0, 0.0, 0.0, 1.0); }
`,
                new Float32Array([
                    0, 0,                    // order, border_style
                    100, 100, 200, 200,      // bounds
                    0, 0, 400, 400,          // content_mask
                    0, 0,                    // PADDING (offset 40 -> 48)
                    // Background at offset 48
                    0, 0,                    // tag, color_space (offset 48)
                    0, 1, 0.5, 1,           // solid HSLA (offset 56)
                    // colors array needs 16-byte alignment, starts at offset 72
                    // colors[0]
                    0, 0, 0, 0,             // color Hsla
                    0,                       // percentage
                    0, 0, 0,                 // padding to 32-byte stride
                    // colors[1]
                    0, 0, 0, 0,             // color Hsla
                    0,                       // percentage
                    0, 0, 0,                 // padding to 32-byte stride
                ]),
                'Background at offset 48, no gradient_angle field, array at offset 72'
            );

            // Test 2: Full Background struct as in real code
            await testLayout(
                'Test 2: Full Background with gradient_angle',
                `
struct Bounds { origin: vec2<f32>, size: vec2<f32>, }
struct Hsla { h: f32, s: f32, l: f32, a: f32, }
struct LinearColorStop { color: Hsla, percentage: f32, }
struct Background {
    tag: u32,
    color_space: u32,
    solid: Hsla,
    gradient_angle: f32,
    colors: array<LinearColorStop, 2>,
    pad: u32,
}
struct Quad { order: u32, border_style: u32, bounds: Bounds, content_mask: Bounds, background: Background, }
@group(0) @binding(0) var<storage, read> quads: array<Quad>;
@vertex fn vs_main(@builtin(vertex_index) vid: u32) -> @builtin(position) vec4<f32> {
    let uv = vec2<f32>(f32(vid & 1u), 0.5 * f32(vid & 2u));
    let pos = uv * quads[0].bounds.size + quads[0].bounds.origin;
    let ndc = pos / vec2<f32>(400.0) * vec2<f32>(2.0, -2.0) + vec2<f32>(-1.0, 1.0);
    return vec4<f32>(ndc, 0.0, 1.0);
}
@fragment fn fs_main() -> @location(0) vec4<f32> { return vec4<f32>(1.0, 0.0, 0.0, 1.0); }
`,
                new Float32Array([
                    0, 0,                    // order, border_style
                    100, 100, 200, 200,      // bounds
                    0, 0, 400, 400,          // content_mask
                    0, 0,                    // PADDING (offset 40 -> 48)
                    // Background at offset 48
                    0, 0,                    // tag, color_space (offset 48)
                    0, 1, 0.5, 1,           // solid HSLA (offset 56)
                    0,                       // gradient_angle (offset 72)
                    0,                       // padding to align colors to 16-byte (offset 76 -> 80)
                    // colors array at offset 80
                    // colors[0]
                    0, 0, 0, 0,             // color Hsla
                    0,                       // percentage
                    0, 0, 0,                 // padding to 32-byte stride
                    // colors[1]
                    0, 0, 0, 0,             // color Hsla
                    0,                       // percentage
                    0, 0, 0,                 // padding to 32-byte stride
                    // pad
                    0,
                    // padding to 16-byte multiple
                    0, 0, 0,
                ]),
                'Full Background: gradient_angle at 72, padding at 76, colors at 80'
            );

            // Test 3: Let's try WITHOUT padding after gradient_angle
            await testLayout(
                'Test 3: No padding after gradient_angle',
                `
struct Bounds { origin: vec2<f32>, size: vec2<f32>, }
struct Hsla { h: f32, s: f32, l: f32, a: f32, }
struct LinearColorStop { color: Hsla, percentage: f32, }
struct Background {
    tag: u32,
    color_space: u32,
    solid: Hsla,
    gradient_angle: f32,
    colors: array<LinearColorStop, 2>,
    pad: u32,
}
struct Quad { order: u32, border_style: u32, bounds: Bounds, content_mask: Bounds, background: Background, }
@group(0) @binding(0) var<storage, read> quads: array<Quad>;
@vertex fn vs_main(@builtin(vertex_index) vid: u32) -> @builtin(position) vec4<f32> {
    let uv = vec2<f32>(f32(vid & 1u), 0.5 * f32(vid & 2u));
    let pos = uv * quads[0].bounds.size + quads[0].bounds.origin;
    let ndc = pos / vec2<f32>(400.0) * vec2<f32>(2.0, -2.0) + vec2<f32>(-1.0, 1.0);
    return vec4<f32>(ndc, 0.0, 1.0);
}
@fragment fn fs_main() -> @location(0) vec4<f32> { return vec4<f32>(1.0, 0.0, 0.0, 1.0); }
`,
                new Float32Array([
                    0, 0,                    // order, border_style
                    100, 100, 200, 200,      // bounds
                    0, 0, 400, 400,          // content_mask
                    0, 0,                    // PADDING (offset 40 -> 48)
                    // Background at offset 48
                    0, 0,                    // tag, color_space
                    0, 1, 0.5, 1,           // solid HSLA
                    0,                       // gradient_angle
                    // NO padding - colors starts immediately at offset 76
                    // colors[0]
                    0, 0, 0, 0,             // color Hsla
                    0,                       // percentage
                    0, 0, 0,                 // padding to 32-byte stride
                    // colors[1]
                    0, 0, 0, 0,             // color Hsla
                    0,                       // percentage
                    0, 0, 0,                 // padding to 32-byte stride
                    // pad
                    0,
                    // padding to 16-byte multiple
                    0, 0, 0,
                ]),
                'No padding after gradient_angle - colors at offset 76 (NOT 16-byte aligned!)'
            );
        }

        main();
    </script>
</body>
</html>
