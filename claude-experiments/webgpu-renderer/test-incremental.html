<!DOCTYPE html>
<html>
<head>
    <title>Incremental Field Test</title>
    <style>
        body { margin: 0; padding: 20px; font-family: monospace; font-size: 11px; }
        #log { white-space: pre; }
    </style>
</head>
<body>
    <h1>Incremental Field Test</h1>
    <div id="log"></div>

    <script type="module">
        const log = document.getElementById('log');
        function addLog(msg) {
            log.textContent += msg + '\n';
            console.log(msg);
        }

        async function testLayout(testName, shaderCode, quadData) {
            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice();

            const module = device.createShaderModule({ code: shaderCode });
            const layout = device.createBindGroupLayout({
                entries: [
                    { binding: 0, visibility: GPUShaderStage.VERTEX, buffer: { type: 'read-only-storage' } }
                ]
            });

            const pipeline = device.createRenderPipeline({
                layout: device.createPipelineLayout({ bindGroupLayouts: [layout] }),
                vertex: { module, entryPoint: 'vs_main' },
                fragment: { module, entryPoint: 'fs_main', targets: [{ format: 'bgra8unorm' }] },
                primitive: { topology: 'triangle-strip' },
            });

            const quadBuffer = device.createBuffer({
                size: quadData.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
            });
            device.queue.writeBuffer(quadBuffer, 0, quadData);

            const bindGroup = device.createBindGroup({
                layout,
                entries: [{ binding: 0, resource: { buffer: quadBuffer } }]
            });

            const texture = device.createTexture({
                size: { width: 400, height: 400 },
                format: 'bgra8unorm',
                usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
            });

            const encoder = device.createCommandEncoder();
            const renderPass = encoder.beginRenderPass({
                colorAttachments: [{
                    view: texture.createView(),
                    clearValue: { r: 0, g: 0, b: 1, a: 1 },
                    loadOp: 'clear',
                    storeOp: 'store',
                }],
            });

            renderPass.setPipeline(pipeline);
            renderPass.setBindGroup(0, bindGroup);
            renderPass.draw(4, 1, 0, 0);
            renderPass.end();

            const bytesPerRow = Math.ceil(400 * 4 / 256) * 256;
            const buffer = device.createBuffer({
                size: bytesPerRow * 400,
                usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
            });

            encoder.copyTextureToBuffer({ texture }, { buffer, bytesPerRow }, { width: 400, height: 400 });
            device.queue.submit([encoder.finish()]);

            await buffer.mapAsync(GPUMapMode.READ);
            const data = new Uint8Array(buffer.getMappedRange());

            const idx = 200 * bytesPerRow + 200 * 4;
            const r = data[idx + 2];
            const b = data[idx + 0];

            buffer.unmap();

            const pass = r > 200 && b < 50;
            addLog(`${testName}: ${pass ? '✅' : '❌'} (R=${r} B=${b}) - ${quadData.length} floats`);
            return pass;
        }

        async function main() {
            if (!navigator.gpu) {
                addLog('❌ WebGPU not supported');
                return;
            }

            addLog('=== Incremental Field Test ===\n');

            // Test 1: Just bounds (works, we know this)
            await testLayout(
                'Test 1: order + border_style + bounds',
                `
struct Bounds { origin: vec2<f32>, size: vec2<f32>, }
struct Quad { order: u32, border_style: u32, bounds: Bounds, }
@group(0) @binding(0) var<storage, read> quads: array<Quad>;
@vertex fn vs_main(@builtin(vertex_index) vid: u32) -> @builtin(position) vec4<f32> {
    let uv = vec2<f32>(f32(vid & 1u), 0.5 * f32(vid & 2u));
    let pos = uv * quads[0].bounds.size + quads[0].bounds.origin;
    let ndc = pos / vec2<f32>(400.0) * vec2<f32>(2.0, -2.0) + vec2<f32>(-1.0, 1.0);
    return vec4<f32>(ndc, 0.0, 1.0);
}
@fragment fn fs_main() -> @location(0) vec4<f32> { return vec4<f32>(1.0, 0.0, 0.0, 1.0); }
`,
                new Float32Array([0, 0, 100, 100, 200, 200])
            );

            // Test 2: Add content_mask (still simple)
            await testLayout(
                'Test 2: + content_mask',
                `
struct Bounds { origin: vec2<f32>, size: vec2<f32>, }
struct Quad { order: u32, border_style: u32, bounds: Bounds, content_mask: Bounds, }
@group(0) @binding(0) var<storage, read> quads: array<Quad>;
@vertex fn vs_main(@builtin(vertex_index) vid: u32) -> @builtin(position) vec4<f32> {
    let uv = vec2<f32>(f32(vid & 1u), 0.5 * f32(vid & 2u));
    let pos = uv * quads[0].bounds.size + quads[0].bounds.origin;
    let ndc = pos / vec2<f32>(400.0) * vec2<f32>(2.0, -2.0) + vec2<f32>(-1.0, 1.0);
    return vec4<f32>(ndc, 0.0, 1.0);
}
@fragment fn fs_main() -> @location(0) vec4<f32> { return vec4<f32>(1.0, 0.0, 0.0, 1.0); }
`,
                new Float32Array([0, 0, 100, 100, 200, 200, 0, 0, 400, 400])
            );

            // Test 3: Add Background with minimal fields (no array)
            await testLayout(
                'Test 3: + Background (no arrays)',
                `
struct Bounds { origin: vec2<f32>, size: vec2<f32>, }
struct Hsla { h: f32, s: f32, l: f32, a: f32, }
struct Background { tag: u32, color_space: u32, solid: Hsla, }
struct Quad { order: u32, border_style: u32, bounds: Bounds, content_mask: Bounds, background: Background, }
@group(0) @binding(0) var<storage, read> quads: array<Quad>;
@vertex fn vs_main(@builtin(vertex_index) vid: u32) -> @builtin(position) vec4<f32> {
    let uv = vec2<f32>(f32(vid & 1u), 0.5 * f32(vid & 2u));
    let pos = uv * quads[0].bounds.size + quads[0].bounds.origin;
    let ndc = pos / vec2<f32>(400.0) * vec2<f32>(2.0, -2.0) + vec2<f32>(-1.0, 1.0);
    return vec4<f32>(ndc, 0.0, 1.0);
}
@fragment fn fs_main() -> @location(0) vec4<f32> { return vec4<f32>(1.0, 0.0, 0.0, 1.0); }
`,
                new Float32Array([
                    0, 0,                    // order, border_style
                    100, 100, 200, 200,      // bounds
                    0, 0, 400, 400,          // content_mask
                    // Background starts here - offset 40 (not 16-byte aligned!)
                    0, 0,                    // tag, color_space
                    0, 1, 0.5, 1,           // solid HSLA (RED)
                ])
            );

            // Test 4: Same as Test 3 but with explicit padding before Background
            await testLayout(
                'Test 4: + Background WITH padding',
                `
struct Bounds { origin: vec2<f32>, size: vec2<f32>, }
struct Hsla { h: f32, s: f32, l: f32, a: f32, }
struct Background { tag: u32, color_space: u32, solid: Hsla, }
struct Quad { order: u32, border_style: u32, bounds: Bounds, content_mask: Bounds, background: Background, }
@group(0) @binding(0) var<storage, read> quads: array<Quad>;
@vertex fn vs_main(@builtin(vertex_index) vid: u32) -> @builtin(position) vec4<f32> {
    let uv = vec2<f32>(f32(vid & 1u), 0.5 * f32(vid & 2u));
    let pos = uv * quads[0].bounds.size + quads[0].bounds.origin;
    let ndc = pos / vec2<f32>(400.0) * vec2<f32>(2.0, -2.0) + vec2<f32>(-1.0, 1.0);
    return vec4<f32>(ndc, 0.0, 1.0);
}
@fragment fn fs_main() -> @location(0) vec4<f32> { return vec4<f32>(1.0, 0.0, 0.0, 1.0); }
`,
                new Float32Array([
                    0, 0,                    // order, border_style
                    100, 100, 200, 200,      // bounds
                    0, 0, 400, 400,          // content_mask
                    0, 0,                    // PADDING to align Background to 48
                    0, 0,                    // tag, color_space (now at offset 48)
                    0, 1, 0.5, 1,           // solid HSLA (RED)
                ])
            );

            addLog('\n=== Analysis ===');
            addLog('If Test 3 passes: WGSL adds padding automatically');
            addLog('If Test 4 passes: We need explicit padding');
            addLog('If both fail: Background alignment != 16 bytes');
        }

        main();
    </script>
</body>
</html>
