<!DOCTYPE html>
<html>
<head>
    <title>Test With/Without Transform</title>
    <style>
        body { margin: 0; padding: 20px; font-family: monospace; font-size: 11px; }
        #log { white-space: pre; }
    </style>
</head>
<body>
    <h1>Test With/Without Transform</h1>
    <div id="log"></div>

    <script type="module">
        const log = document.getElementById('log');
        function addLog(msg) {
            log.textContent += msg + '\n';
            console.log(msg);
        }

        async function testQuadRendering(testName, applyTransform, quadData) {
            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice();

            // Load shaders
            const commonResp = await fetch('/src/shaders/common.wgsl');
            const common = await commonResp.text();

            const quadResp = await fetch('/src/shaders/quad.wgsl');
            let quad = await quadResp.text();

            // Modify vertex shader to optionally skip transform
            if (!applyTransform) {
                quad = quad.replace(
                    'let position = apply_transform(local_position, quad.transform);',
                    'let position = local_position; // SKIPPED TRANSFORM FOR TEST'
                );
            }

            const shaderCode = common + '\n' + quad;
            const module = device.createShaderModule({ code: shaderCode });

            const layout = device.createBindGroupLayout({
                entries: [
                    { binding: 0, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: 'uniform' } },
                    { binding: 1, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: 'read-only-storage' } }
                ]
            });

            const pipeline = device.createRenderPipeline({
                layout: device.createPipelineLayout({ bindGroupLayouts: [layout] }),
                vertex: { module, entryPoint: 'vs_main' },
                fragment: { module, entryPoint: 'fs_main', targets: [{ format: 'bgra8unorm' }] },
                primitive: { topology: 'triangle-strip' },
            });

            const uniformData = new Float32Array([400, 400, 1, 0]);
            const uniformBuffer = device.createBuffer({
                size: 16,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            });
            device.queue.writeBuffer(uniformBuffer, 0, uniformData);

            const quadBuffer = device.createBuffer({
                size: quadData.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
            });
            device.queue.writeBuffer(quadBuffer, 0, quadData);

            const bindGroup = device.createBindGroup({
                layout,
                entries: [
                    { binding: 0, resource: { buffer: uniformBuffer } },
                    { binding: 1, resource: { buffer: quadBuffer } }
                ]
            });

            const texture = device.createTexture({
                size: { width: 400, height: 400 },
                format: 'bgra8unorm',
                usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
            });

            const encoder = device.createCommandEncoder();
            const renderPass = encoder.beginRenderPass({
                colorAttachments: [{
                    view: texture.createView(),
                    clearValue: { r: 0, g: 0, b: 1, a: 1 },
                    loadOp: 'clear',
                    storeOp: 'store',
                }],
            });

            renderPass.setPipeline(pipeline);
            renderPass.setBindGroup(0, bindGroup);
            renderPass.draw(4, 1, 0, 0);
            renderPass.end();

            const bytesPerRow = Math.ceil(400 * 4 / 256) * 256;
            const buffer = device.createBuffer({
                size: bytesPerRow * 400,
                usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
            });

            encoder.copyTextureToBuffer({ texture }, { buffer, bytesPerRow }, { width: 400, height: 400 });
            device.queue.submit([encoder.finish()]);

            await buffer.mapAsync(GPUMapMode.READ);
            const data = new Uint8Array(buffer.getMappedRange());

            const idx = 200 * bytesPerRow + 200 * 4;
            const r = data[idx + 2];
            const b = data[idx + 0];

            buffer.unmap();

            const pass = r > 200 && b < 50;
            addLog(`${testName}: ${pass ? '✅ PASS' : '❌ FAIL'} (R=${r} B=${b})`);
            return pass;
        }

        async function main() {
            if (!navigator.gpu) {
                addLog('❌ WebGPU not supported');
                return;
            }

            addLog('=== Testing With/Without Transform ===\n');

            // Common quad data (62 floats - WITH explicit padding)
            const quadData = new Float32Array(62);
            let i = 0;
            quadData[i++] = 0; quadData[i++] = 0; // order, border_style
            quadData[i++] = 100; quadData[i++] = 100; quadData[i++] = 200; quadData[i++] = 200; // bounds
            quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 400; quadData[i++] = 400; // content_mask
            quadData[i++] = 0; quadData[i++] = 0; // EXPLICIT padding before Background
            // Background (28 floats)
            quadData[i++] = 0; quadData[i++] = 0; // tag, color_space
            quadData[i++] = 0; quadData[i++] = 1; quadData[i++] = 0.5; quadData[i++] = 1; // solid
            quadData[i++] = 0; quadData[i++] = 0; // gradient_angle, padding
            quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0;
            quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; // colors[0]
            quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0;
            quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; // colors[1]
            quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; // pad + padding
            quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; // border_color
            quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; // corner_radii
            quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; // border_widths
            quadData[i++] = 1; quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 1; // transform
            quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0;
            quadData[i++] = 1; quadData[i++] = 0; // opacity, pad

            addLog(`Quad data: ${i} floats = ${quadData.byteLength} bytes\n`);

            await testQuadRendering('Test 1: WITHOUT transform', false, quadData);
            await testQuadRendering('Test 2: WITH transform', true, quadData);

            addLog('\n=== Analysis ===');
            addLog('If Test 1 passes but Test 2 fails: Transform reading is broken');
            addLog('If both fail: Earlier fields are misaligned');
        }

        main();
    </script>
</body>
</html>
