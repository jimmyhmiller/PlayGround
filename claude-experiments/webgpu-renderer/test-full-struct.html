<!DOCTYPE html>
<html>
<head>
    <title>Full Quad Struct Test</title>
    <style>
        body { margin: 0; padding: 20px; font-family: monospace; font-size: 11px; }
        #log { white-space: pre; }
    </style>
</head>
<body>
    <h1>Full Quad Struct Test</h1>
    <div id="log"></div>

    <script type="module">
        const log = document.getElementById('log');
        function addLog(msg) {
            log.textContent += msg + '\n';
            console.log(msg);
        }

        async function testFullQuad() {
            if (!navigator.gpu) {
                addLog('❌ WebGPU not supported');
                return;
            }

            addLog('=== Testing Full Quad Struct from common.wgsl ===\n');

            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice();

            // Load the actual shaders - both common and quad
            const commonResp = await fetch('/src/shaders/common.wgsl');
            const common = await commonResp.text();

            const quadResp = await fetch('/src/shaders/quad.wgsl');
            const quad = await quadResp.text();

            const quadShaderCode = common + '\n' + quad;

            const module = device.createShaderModule({ code: quadShaderCode });
            const info = await module.getCompilationInfo();

            if (info.messages.length > 0) {
                addLog('Shader compilation messages:');
                info.messages.forEach(m => {
                    addLog(`  ${m.type}: ${m.message} (line ${m.lineNum})`);
                });
                if (info.messages.some(m => m.type === 'error')) {
                    addLog('\n❌ Shader compilation failed');
                    return;
                }
            } else {
                addLog('✅ Shader compiled successfully\n');
            }

            const layout = device.createBindGroupLayout({
                entries: [
                    { binding: 0, visibility: GPUShaderStage.VERTEX, buffer: { type: 'uniform' } },
                    { binding: 1, visibility: GPUShaderStage.VERTEX, buffer: { type: 'read-only-storage' } }
                ]
            });

            const pipeline = device.createRenderPipeline({
                layout: device.createPipelineLayout({ bindGroupLayouts: [layout] }),
                vertex: { module, entryPoint: 'vs_main' },
                fragment: { module, entryPoint: 'fs_main', targets: [{ format: 'bgra8unorm' }] },
                primitive: { topology: 'triangle-strip' },
            });

            addLog('✅ Pipeline created\n');

            // Create the quad data WITHOUT explicit padding (60 floats)
            // WGSL will add padding automatically!
            const quadData = new Float32Array(60);
            let i = 0;

            // order, border_style
            quadData[i++] = 0; quadData[i++] = 0;

            // bounds
            quadData[i++] = 100; quadData[i++] = 100; quadData[i++] = 200; quadData[i++] = 200;

            // content_mask
            quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 400; quadData[i++] = 400;

            // NO EXPLICIT PADDING - let WGSL add it automatically!

            // Background (28 floats)
            quadData[i++] = 0; quadData[i++] = 0; // tag, color_space
            quadData[i++] = 0; quadData[i++] = 1; quadData[i++] = 0.5; quadData[i++] = 1; // solid
            quadData[i++] = 0; // gradient_angle
            quadData[i++] = 0; // padding
            // colors[0]
            quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0;
            quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0;
            // colors[1]
            quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0;
            quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0;
            // pad + padding
            quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0;

            // border_color
            quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0;

            // corner_radii
            quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0;

            // border_widths
            quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0;

            // transform
            quadData[i++] = 1; quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 1;
            quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0;

            // opacity, pad
            quadData[i++] = 1; quadData[i++] = 0;

            addLog(`Created quad data: ${i} floats = ${quadData.byteLength} bytes`);
            addLog(`Bounds at indices 2-5: [${quadData[2]}, ${quadData[3]}, ${quadData[4]}, ${quadData[5]}]\n`);

            const uniformData = new Float32Array([400, 400, 1, 0]);
            const uniformBuffer = device.createBuffer({
                size: 16,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            });
            device.queue.writeBuffer(uniformBuffer, 0, uniformData);

            const quadBuffer = device.createBuffer({
                size: quadData.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
            });
            device.queue.writeBuffer(quadBuffer, 0, quadData);

            const bindGroup = device.createBindGroup({
                layout,
                entries: [
                    { binding: 0, resource: { buffer: uniformBuffer } },
                    { binding: 1, resource: { buffer: quadBuffer } }
                ]
            });

            const texture = device.createTexture({
                size: { width: 400, height: 400 },
                format: 'bgra8unorm',
                usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
            });

            const encoder = device.createCommandEncoder();
            const renderPass = encoder.beginRenderPass({
                colorAttachments: [{
                    view: texture.createView(),
                    clearValue: { r: 0, g: 0, b: 1, a: 1 },
                    loadOp: 'clear',
                    storeOp: 'store',
                }],
            });

            renderPass.setPipeline(pipeline);
            renderPass.setBindGroup(0, bindGroup);
            renderPass.draw(4, 1, 0, 0);
            renderPass.end();

            const bytesPerRow = Math.ceil(400 * 4 / 256) * 256;
            const buffer = device.createBuffer({
                size: bytesPerRow * 400,
                usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
            });

            encoder.copyTextureToBuffer({ texture }, { buffer, bytesPerRow }, { width: 400, height: 400 });
            device.queue.submit([encoder.finish()]);

            await buffer.mapAsync(GPUMapMode.READ);
            const data = new Uint8Array(buffer.getMappedRange());

            const idx = 200 * bytesPerRow + 200 * 4;
            const r = data[idx + 2];
            const g = data[idx + 1];
            const b = data[idx + 0];

            buffer.unmap();

            addLog(`\nCenter pixel: R=${r} G=${g} B=${b}`);

            if (r > 200 && b < 50) {
                addLog('\n✅ SUCCESS: Full Quad struct with 60 floats works!');
                addLog('    WGSL automatically adds padding - no explicit padding needed!');
            } else {
                addLog('\n❌ FAIL: Quad not rendering with 60-float layout');
            }
        }

        testFullQuad().catch(err => addLog('ERROR: ' + err.message));
    </script>
</body>
</html>
