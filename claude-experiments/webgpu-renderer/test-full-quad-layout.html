<!DOCTYPE html>
<html>
<head>
    <title>Test Full Quad Layout</title>
    <style>
        body { margin: 0; padding: 20px; font-family: monospace; font-size: 12px; }
        #log { white-space: pre; }
    </style>
</head>
<body>
    <h1>Full Quad Layout Test</h1>
    <div id="log"></div>

    <script type="module">
        const log = document.getElementById('log');
        function addLog(msg) {
            log.textContent += msg + '\n';
            console.log(msg);
        }

        async function testFullQuad() {
            addLog('=== Testing Full Quad Layout ===\n');

            if (!navigator.gpu) {
                addLog('❌ WebGPU not supported');
                return;
            }

            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice();

            // Test WITHOUT explicit padding before Background
            const testWithoutPadding = async () => {
                addLog('TEST 1: Without explicit padding before Background (60 floats)');

                const shader = await (await fetch('/src/shaders/common.wgsl')).text() + '\n' + await (await fetch('/src/shaders/quad.wgsl')).text();
                const module = device.createShaderModule({ code: shader });

                const layout = device.createBindGroupLayout({
                    entries: [
                        { binding: 0, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: 'uniform' } },
                        { binding: 1, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: 'read-only-storage' } }
                    ]
                });

                const pipeline = device.createRenderPipeline({
                    layout: device.createPipelineLayout({ bindGroupLayouts: [layout] }),
                    vertex: { module, entryPoint: 'vs_main' },
                    fragment: { module, entryPoint: 'fs_main', targets: [{ format: 'bgra8unorm' }] },
                    primitive: { topology: 'triangle-strip' },
                });

                // Create quad: 60 floats WITHOUT padding before Background
                const quadData = new Float32Array(60);
                let i = 0;

                // order, borderStyle
                quadData[i++] = 0;
                quadData[i++] = 0;

                // bounds: (100, 100, 200, 200)
                quadData[i++] = 100; quadData[i++] = 100; quadData[i++] = 200; quadData[i++] = 200;

                // contentMask: (0, 0, 400, 400)
                quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 400; quadData[i++] = 400;

                // NO PADDING HERE (let WGSL add it automatically)

                // Background: tag=0, colorSpace=0
                quadData[i++] = 0; quadData[i++] = 0;

                // solid: HSLA(0, 1, 0.5, 1) = RED
                quadData[i++] = 0; quadData[i++] = 1; quadData[i++] = 0.5; quadData[i++] = 1;

                // gradient_angle
                quadData[i++] = 0;

                // padding to align colors array (1 float)
                quadData[i++] = 0;

                // colors[0]: Hsla + percentage + 3 floats padding (8 floats total)
                quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; // Hsla
                quadData[i++] = 0; // percentage
                quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; // padding

                // colors[1]: Hsla + percentage + 3 floats padding (8 floats total)
                quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; // Hsla
                quadData[i++] = 0; // percentage
                quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; // padding

                // pad + 3 floats padding to round to 112 bytes (4 floats total)
                quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0;

                // borderColor
                quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0;

                // cornerRadii
                quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0;

                // borderWidths
                quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0;

                // transform (identity)
                quadData[i++] = 1; quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 1;
                quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0;

                // opacity, pad
                quadData[i++] = 1; quadData[i++] = 0;

                addLog(`  Created ${i} floats = ${quadData.byteLength} bytes`);

                const uniformData = new Float32Array([400, 400, 1, 0]);
                const uniformBuffer = device.createBuffer({
                    size: 16,
                    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
                });
                device.queue.writeBuffer(uniformBuffer, 0, uniformData);

                const quadBuffer = device.createBuffer({
                    size: quadData.byteLength,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                });
                device.queue.writeBuffer(quadBuffer, 0, quadData);

                const bindGroup = device.createBindGroup({
                    layout,
                    entries: [
                        { binding: 0, resource: { buffer: uniformBuffer } },
                        { binding: 1, resource: { buffer: quadBuffer } }
                    ]
                });

                const texture = device.createTexture({
                    size: { width: 400, height: 400 },
                    format: 'bgra8unorm',
                    usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
                });

                const encoder = device.createCommandEncoder();
                const renderPass = encoder.beginRenderPass({
                    colorAttachments: [{
                        view: texture.createView(),
                        clearValue: { r: 0, g: 0, b: 1, a: 1 },
                        loadOp: 'clear',
                        storeOp: 'store',
                    }],
                });

                renderPass.setPipeline(pipeline);
                renderPass.setBindGroup(0, bindGroup);
                renderPass.draw(4, 1, 0, 0);
                renderPass.end();

                const bytesPerRow = Math.ceil(400 * 4 / 256) * 256;
                const buffer = device.createBuffer({
                    size: bytesPerRow * 400,
                    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
                });

                encoder.copyTextureToBuffer({ texture }, { buffer, bytesPerRow }, { width: 400, height: 400 });
                device.queue.submit([encoder.finish()]);

                await buffer.mapAsync(GPUMapMode.READ);
                const data = new Uint8Array(buffer.getMappedRange());

                const idx = 200 * bytesPerRow + 200 * 4;
                const result = {
                    r: data[idx + 2],
                    g: data[idx + 1],
                    b: data[idx + 0]
                };

                addLog(`  Center pixel: R=${result.r} G=${result.g} B=${result.b}`);
                buffer.unmap();

                return result.r > 200 && result.b < 50;
            };

            const testWithPadding = async () => {
                addLog('\nTEST 2: With explicit 2-float padding before Background (62 floats)');

                const shader = await (await fetch('/src/shaders/common.wgsl')).text() + '\n' + await (await fetch('/src/shaders/quad.wgsl')).text();
                const module = device.createShaderModule({ code: shader });

                const layout = device.createBindGroupLayout({
                    entries: [
                        { binding: 0, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: 'uniform' } },
                        { binding: 1, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: 'read-only-storage' } }
                    ]
                });

                const pipeline = device.createRenderPipeline({
                    layout: device.createPipelineLayout({ bindGroupLayouts: [layout] }),
                    vertex: { module, entryPoint: 'vs_main' },
                    fragment: { module, entryPoint: 'fs_main', targets: [{ format: 'bgra8unorm' }] },
                    primitive: { topology: 'triangle-strip' },
                });

                // Create quad: 62 floats WITH padding before Background
                const quadData = new Float32Array(62);
                let i = 0;

                // order, borderStyle
                quadData[i++] = 0;
                quadData[i++] = 0;

                // bounds: (100, 100, 200, 200)
                quadData[i++] = 100; quadData[i++] = 100; quadData[i++] = 200; quadData[i++] = 200;

                // contentMask: (0, 0, 400, 400)
                quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 400; quadData[i++] = 400;

                // EXPLICIT 2-float padding before Background (offset 40 -> 48)
                quadData[i++] = 0; quadData[i++] = 0;

                // Background: tag=0, colorSpace=0
                quadData[i++] = 0; quadData[i++] = 0;

                // solid: HSLA(0, 1, 0.5, 1) = RED
                quadData[i++] = 0; quadData[i++] = 1; quadData[i++] = 0.5; quadData[i++] = 1;

                // gradient_angle
                quadData[i++] = 0;

                // padding to align colors array (1 float)
                quadData[i++] = 0;

                // colors[0]: Hsla + percentage + 3 floats padding (8 floats total)
                quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; // Hsla
                quadData[i++] = 0; // percentage
                quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; // padding

                // colors[1]: Hsla + percentage + 3 floats padding (8 floats total)
                quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; // Hsla
                quadData[i++] = 0; // percentage
                quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; // padding

                // pad + 3 floats padding to round to 112 bytes (4 floats total)
                quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0;

                // borderColor
                quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0;

                // cornerRadii
                quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0;

                // borderWidths
                quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0;

                // transform (identity)
                quadData[i++] = 1; quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 1;
                quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0; quadData[i++] = 0;

                // opacity, pad
                quadData[i++] = 1; quadData[i++] = 0;

                addLog(`  Created ${i} floats = ${quadData.byteLength} bytes`);

                const uniformData = new Float32Array([400, 400, 1, 0]);
                const uniformBuffer = device.createBuffer({
                    size: 16,
                    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
                });
                device.queue.writeBuffer(uniformBuffer, 0, uniformData);

                const quadBuffer = device.createBuffer({
                    size: quadData.byteLength,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                });
                device.queue.writeBuffer(quadBuffer, 0, quadData);

                const bindGroup = device.createBindGroup({
                    layout,
                    entries: [
                        { binding: 0, resource: { buffer: uniformBuffer } },
                        { binding: 1, resource: { buffer: quadBuffer } }
                    ]
                });

                const texture = device.createTexture({
                    size: { width: 400, height: 400 },
                    format: 'bgra8unorm',
                    usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
                });

                const encoder = device.createCommandEncoder();
                const renderPass = encoder.beginRenderPass({
                    colorAttachments: [{
                        view: texture.createView(),
                        clearValue: { r: 0, g: 0, b: 1, a: 1 },
                        loadOp: 'clear',
                        storeOp: 'store',
                    }],
                });

                renderPass.setPipeline(pipeline);
                renderPass.setBindGroup(0, bindGroup);
                renderPass.draw(4, 1, 0, 0);
                renderPass.end();

                const bytesPerRow = Math.ceil(400 * 4 / 256) * 256;
                const buffer = device.createBuffer({
                    size: bytesPerRow * 400,
                    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
                });

                encoder.copyTextureToBuffer({ texture }, { buffer, bytesPerRow }, { width: 400, height: 400 });
                device.queue.submit([encoder.finish()]);

                await buffer.mapAsync(GPUMapMode.READ);
                const data = new Uint8Array(buffer.getMappedRange());

                const idx = 200 * bytesPerRow + 200 * 4;
                const result = {
                    r: data[idx + 2],
                    g: data[idx + 1],
                    b: data[idx + 0]
                };

                addLog(`  Center pixel: R=${result.r} G=${result.g} B=${result.b}`);
                buffer.unmap();

                return result.r > 200 && result.b < 50;
            };

            const test1Pass = await testWithoutPadding();
            const test2Pass = await testWithPadding();

            addLog('\n=== RESULTS ===');
            addLog(`Test 1 (no padding): ${test1Pass ? '✅ PASS' : '❌ FAIL'}`);
            addLog(`Test 2 (with padding): ${test2Pass ? '✅ PASS' : '❌ FAIL'}`);

            if (test2Pass) {
                addLog('\n✅ The 62-float layout with explicit padding IS CORRECT!');
            } else if (test1Pass) {
                addLog('\n✅ The 60-float layout without explicit padding IS CORRECT!');
                addLog('   WGSL is adding padding automatically - JS should NOT add it.');
            } else {
                addLog('\n❌ Neither layout works - deeper issue exists');
            }
        }

        testFullQuad();
    </script>
</body>
</html>
