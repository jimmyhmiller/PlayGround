#!/usr/bin/env node

import { readFileSync, writeFileSync } from 'fs';
import { join } from 'path';

const MANIFEST_PATH = './tests/fixtures/ion-examples/manifest.json';
const TEST_OUTPUT_PATH = './tests/ion_examples_comprehensive.rs';

console.log('ðŸ“– Reading manifest...');
const manifest = JSON.parse(readFileSync(MANIFEST_PATH, 'utf-8'));

console.log(`Found ${manifest.length} test cases`);

// Group by file
const byFile = {};
for (const entry of manifest) {
  if (!byFile[entry.baseName]) {
    byFile[entry.baseName] = [];
  }
  byFile[entry.baseName].push(entry);
}

console.log(`Organized into ${Object.keys(byFile).length} files`);

// Generate test file
let testCode = `// AUTO-GENERATED by generate-test-suite.mjs
// DO NOT EDIT - regenerate with: node generate-test-suite.mjs

use iongraph_rust::*;
use std::fs;

/// Helper function to compare SVGs and provide detailed diff on failure
fn compare_svgs(ts_svg: &str, rust_svg: &str, test_name: &str) {
    if ts_svg == rust_svg {
        return; // Test passes
    }

    // Find first difference
    let ts_lines: Vec<&str> = ts_svg.lines().collect();
    let rust_lines: Vec<&str> = rust_svg.lines().collect();

    eprintln!("\\n=== DIFFERENCE FOUND in {} ===", test_name);
    eprintln!("TypeScript lines: {}", ts_lines.len());
    eprintln!("Rust lines: {}", rust_lines.len());

    // Find first differing line
    for (i, (ts_line, rust_line)) in ts_lines.iter().zip(rust_lines.iter()).enumerate() {
        if ts_line != rust_line {
            eprintln!("\\nFirst difference at line {}:", i + 1);
            eprintln!("TS:   {}", ts_line);
            eprintln!("Rust: {}", rust_line);

            // Show character-by-character difference
            for (j, (ts_char, rust_char)) in ts_line.chars().zip(rust_line.chars()).enumerate() {
                if ts_char != rust_char {
                    eprintln!("  First char diff at column {}: '{}' vs '{}'", j, ts_char, rust_char);
                    break;
                }
            }
            break;
        }
    }

    panic!("SVG outputs are NOT identical for {}!", test_name);
}

`;

// Generate tests organized by file
for (const [baseName, entries] of Object.entries(byFile)) {
  testCode += `\n// ========================================\n`;
  testCode += `// ${baseName}.json (${entries.length} tests)\n`;
  testCode += `// ========================================\n\n`;

  for (const entry of entries) {
    const testName = `${baseName}_func${entry.funcIndex}_pass${entry.passIndex}`;
    const safeName = testName.replace(/-/g, '_');

    testCode += `#[test]\n`;
    testCode += `fn test_${safeName}() {\n`;
    testCode += `    let test_name = "${testName}";\n`;
    testCode += `    let ts_svg_path = "tests/fixtures/ion-examples/${entry.fixtureName}";\n`;
    testCode += `    let json_path = "ion-examples/${entry.file}";\n`;
    testCode += `\n`;
    testCode += `    // Read TypeScript fixture\n`;
    testCode += `    let ts_svg = fs::read_to_string(ts_svg_path)\n`;
    testCode += `        .expect(&format!("Failed to read TS fixture: {}", ts_svg_path));\n`;
    testCode += `\n`;
    testCode += `    // Parse JSON and generate Rust SVG\n`;
    testCode += `    let json_str = fs::read_to_string(json_path)\n`;
    testCode += `        .expect(&format!("Failed to read JSON: {}", json_path));\n`;
    testCode += `    let ion_json: IonJSON = serde_json::from_str(&json_str)\n`;
    testCode += `        .expect("Failed to parse JSON");\n`;
    testCode += `\n`;
    testCode += `    let func = &ion_json.functions[${entry.funcIndex}];\n`;
    testCode += `    let pass = func.passes[${entry.passIndex}].clone();\n`;
    testCode += `\n`;
    testCode += `    let mut graph = Graph::new(Vec2::new(5000.0, 5000.0), pass);\n`;
    testCode += `    let rust_svg = graph.render_svg();\n`;
    testCode += `\n`;
    testCode += `    // Compare\n`;
    testCode += `    compare_svgs(&ts_svg, &rust_svg, test_name);\n`;
    testCode += `}\n\n`;
  }
}

// Write test file
writeFileSync(TEST_OUTPUT_PATH, testCode);

console.log(`âœ“ Generated ${manifest.length} tests in ${TEST_OUTPUT_PATH}`);
console.log('\nTest organization:');
for (const [baseName, entries] of Object.entries(byFile)) {
  console.log(`  ${baseName}: ${entries.length} tests`);
}
