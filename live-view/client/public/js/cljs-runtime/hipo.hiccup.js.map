{"version":3,"sources":["hipo/hiccup.cljc"],"mappings":"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","names":["hipo.hiccup/id-separator","hipo.hiccup/class-separator","hipo.hiccup/default-namespaces","hipo.hiccup/key->namespace","s","m","or__4126__auto__","cljs.core.get","hipo.hiccup/parse-tag-name","i","cljs.core.subs","j","hipo.hiccup/parse-id","hipo.hiccup/parse-classes","cs","hipo.hiccup/literal?","o","hipo.hiccup/node","v","cljs.core.nth","hipo.hiccup/keyns","h","cljs.core/namespace","hipo.hiccup/tag","cljs.core/name","hipo.hiccup/attributes","n","id","m?","cljs.core/map?","and__4115__auto__","cljs.core/contains?","cljs.core.ex_info","cljs.core.merge","temp__5733__auto__","c","hipo.hiccup/children","cljs.core/count","cljs.core.subvec","js/Error","hipo.hiccup/flattened?","cljs.core/vector?","cljs.core/empty?","cljs.core._EQ_","this__4369__auto__","writer__4370__auto__","opt__4371__auto__","cljs.core/-write","hipo.hiccup/Sentinel","hipo.hiccup/->Sentinel","hipo.hiccup/sentinel","hipo.hiccup/conjs!","cljs.core/seq","f","cljs.core/first","cljs.core.conj_BANG_","cljs.core/rest","%","hipo.hiccup/flatten-children","acc","cljs.core/transient","cljs.core/persistent!","cljs.core/seq?","hipo.hiccup/listener-name?","hipo.hiccup/listener-name->event-name","hipo.hiccup/classes","cljs.core.keep","cljs.core/identity","clojure.string/trim","clojure.string.join"],"sourcesContent":["(ns hipo.hiccup\n  (:require [clojure.string :as string]))\n\n(def ^:private id-separator \"#\")\n(def ^:private class-separator \".\")\n\n(def ^:private default-namespaces {\"svg\" \"http://www.w3.org/2000/svg\"\n                                   \"xlink\" \"http://www.w3.org/1999/xlink\"})\n\n(defn key->namespace\n  [s m]\n  (if s\n    (or (get (:namespaces m) s) (get default-namespaces s))))\n\n(defn parse-tag-name\n  [s]\n  (let [i (.indexOf s id-separator)]\n    (if (pos? i)\n      (subs s 0 i)\n      (let [j (.indexOf s class-separator)]\n        (if (pos? j)\n          (subs s 0 j)\n          s)))))\n\n(defn parse-id\n  [s]\n  (let [i (.indexOf s id-separator)]\n    (if (pos? i)\n      (let [j (.indexOf s class-separator)]\n        (if (pos? j)\n          (subs s (inc i) j)\n          (subs s (inc i)))))))\n\n(defn parse-classes\n  [s]\n  (let [i (.indexOf s class-separator)]\n    (if (pos? i); First locate the class part\n      (let [cs (subs s (inc i))]\n        (loop [s cs] ; Then convert from 'a.b.c' to 'a b c'\n          (let [i (.indexOf s class-separator)]\n            (if (pos? i)\n              ; Replace with string in a loop is more efficient than replace with global regex\n              (recur (.replace s class-separator \" \"))\n              s)))))))\n\n(defn literal?\n  [o]\n  (or (string? o) (number? o) (true? o) (false? o)))\n\n(defn node\n  [v]\n  (nth v 0))\n\n(defn keyns\n  [h]\n  (namespace (node h)))\n\n(defn tag\n  [v]\n  (parse-tag-name (name (node v))))\n\n(defn attributes\n  [v]\n  (if v\n    (let [n (name (node v))\n          id (parse-id n)\n          cs (parse-classes n)\n          m? (nth v 1 nil)]\n      (if (map? m?)\n        (if (and id (contains? m? :id))\n          (throw (ex-info \"Cannot define id multiple times\" {}))\n          (if (or id cs)\n            (merge m? (if id {:id id}) (if cs {:class (if-let [c (:class m?)] (if cs (str cs \" \" c) (str c)) cs)}))\n            m?))\n        (if (or id cs)\n          {:id id :class cs})))))\n\n(defn children\n  [v]\n  (let [i (if (map? (nth v 1 nil)) 2 1)]\n    (if (> (count v) i)\n      (subvec v i))))\n\n(defn flattened?\n  [v]\n  {:pre [(or (nil? v) (vector? v))]}\n  (if (empty? v)\n    true\n    (let [c (dec (count v))]\n      (loop [i 0]\n        (let [o (nth v i)]\n          (if (or (literal? o) (vector? o))\n            (if (= c i)\n              true\n              (recur (inc i)))\n            false))))))\n\n(deftype Sentinel [])\n(def ^:private sentinel (Sentinel.))\n\n(defn conjs!\n  [v s]\n  (if (seq s)\n    (recur (let [f (first s)] (if (or (literal? f) (vector? f)) (conj! v f) (conjs! v f))) (rest s))\n    v))\n\n(defn flatten-children\n  [v]\n  {:pre [(or (nil? v) (vector? v))]\n   :post [(or (nil? v) (vector? v))]}\n  (if (flattened? v)\n    v\n    (loop [acc (transient [])\n           v v]\n      (let [f (nth v 0 sentinel)]\n        (if (identical? sentinel f)\n          (persistent! acc)\n          (recur\n            (cond\n              (seq? f) (conjs! acc f)\n              (not (nil? f)) (conj! acc f)\n              :else acc)\n            (subvec v 1)))))))\n\n(defn listener-name?\n  [s]\n  #?(:clj (.startsWith s \"on-\"))\n  #?(:cljs (identical? 0 (.indexOf s \"on-\"))))\n\n(defn listener-name->event-name\n  [s]\n  (if (listener-name? s)\n    (subs s 3)))\n\n(defn classes\n  [s]\n  (let [s (keep identity s)]\n    (if-not (empty? s)\n      (string/trim (string/join \" \" s)))))\n"]}