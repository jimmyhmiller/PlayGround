// ---------------------------------------------------------------------------
// Resolve pass â€” verify all names resolve to known items, locals, or builtins
// ---------------------------------------------------------------------------

use ast::Option;
use ast::Span;
use ast::Module;
use ast::Item;
use ast::FnDecl;
use ast::ExternFnDecl;
use ast::StructDecl;
use ast::EnumDecl;
use ast::EnumVariant;
use ast::EnumVariantKind;
use ast::UseDecl;
use ast::LinkDecl;
use ast::Field;
use ast::Param;
use ast::Block;
use ast::Stmt;
use ast::Expr;
use ast::Literal;
use ast::BinaryOp;
use ast::UnaryOp;
use ast::Type;
use ast::Pattern;
use ast::MatchArm;
use ast::PatternField;
use ast::StructLitField;
use ast::ItemEntry;
use ast::VariantMapEntry;

use vec::Vec;
use vec::vec_new;
use vec::vec_len;
use vec::vec_push;
use vec::vec_get;
use vec::vec_push_str;
use vec::vec_get_str;
use vec::vec_push_item;
use vec::vec_get_item;
use vec::vec_push_vec;
use vec::vec_get_vec;
use vec::vec_get_module;
use vec::vec_get_field;
use vec::vec_get_param;
use vec::vec_get_variant;
use vec::vec_get_type;
use vec::vec_get_expr;
use vec::vec_get_arm;
use vec::vec_get_stmt;
use vec::vec_get_pfield;
use vec::vec_get_slfield;
use vec::vec_set_len;

// resolve-specific vec aliases
fn vec_push_ientry(v: Vec, item: ItemEntry) -> I64 { vec_push(v, item) }
fn vec_get_ientry(v: Vec, index: I64) -> ItemEntry { vec_get(v, index) }
fn vec_push_ventry(v: Vec, item: VariantMapEntry) -> I64 { vec_push(v, item) }
fn vec_get_ventry(v: Vec, index: I64) -> VariantMapEntry { vec_get(v, index) }

use string::string_eq;
use string::string_concat;
use io::print_str_stderr;
use io::exit_process;

// Item kind constants (same as qualify.lang)
fn IK_STRUCT() -> I64 { 1 }
fn IK_ENUM() -> I64 { 2 }
fn IK_FN() -> I64 { 3 }
fn IK_EXTERN_FN() -> I64 { 4 }

// ---------------------------------------------------------------------------
// Resolver state
// ---------------------------------------------------------------------------

struct Resolver {
    items: Vec,
    enum_variants: Vec,
    scope: Vec,
    errors: Vec
}

// ---------------------------------------------------------------------------
// Utility functions
// ---------------------------------------------------------------------------

fn path_to_string(path: Vec) -> String {
    let len: I64 = vec_len(path);
    if len == 0 { return ""; };
    let mut result: String = vec_get_str(path, 0);
    let mut i: I64 = 1;
    while i < len {
        result = string_concat(result, string_concat("::", vec_get_str(path, i)));
        i = i + 1;
    };
    result
}

fn full_item_name(module_path: Vec, name: String) -> String {
    if vec_len(module_path) == 0 { name }
    else { string_concat(path_to_string(module_path), string_concat("::", name)) }
}

fn is_builtin_type(name: String) -> Bool {
    if string_eq(name, "I8") == 1 { return true; };
    if string_eq(name, "I16") == 1 { return true; };
    if string_eq(name, "I32") == 1 { return true; };
    if string_eq(name, "I64") == 1 { return true; };
    if string_eq(name, "U8") == 1 { return true; };
    if string_eq(name, "U16") == 1 { return true; };
    if string_eq(name, "U32") == 1 { return true; };
    if string_eq(name, "U64") == 1 { return true; };
    if string_eq(name, "F32") == 1 { return true; };
    if string_eq(name, "F64") == 1 { return true; };
    if string_eq(name, "Bool") == 1 { return true; };
    if string_eq(name, "Unit") == 1 { return true; };
    if string_eq(name, "String") == 1 { return true; };
    false
}

fn resolve_error(r: Resolver, msg: String) -> I64 {
    vec_push_str(r.errors, msg);
    0
}

// ---------------------------------------------------------------------------
// Item & variant map lookups (linear scan)
// ---------------------------------------------------------------------------

fn items_contains(items: Vec, name: String) -> Bool {
    let len: I64 = vec_len(items);
    let mut i: I64 = 0;
    while i < len {
        let entry: ItemEntry = vec_get_ientry(items, i);
        if string_eq(entry.name, name) == 1 { return true; };
        i = i + 1;
    };
    false
}

fn items_get_kind(items: Vec, name: String) -> I64 {
    let len: I64 = vec_len(items);
    let mut i: I64 = 0;
    while i < len {
        let entry: ItemEntry = vec_get_ientry(items, i);
        if string_eq(entry.name, name) == 1 { return entry.kind; };
        i = i + 1;
    };
    0
}

fn variant_exists(enum_variants: Vec, enum_name: String, variant_name: String) -> Bool {
    let len: I64 = vec_len(enum_variants);
    let mut i: I64 = 0;
    while i < len {
        let entry: VariantMapEntry = vec_get_ventry(enum_variants, i);
        if string_eq(entry.enum_name, enum_name) == 1 {
            if string_eq(entry.variant_name, variant_name) == 1 { return true; };
        };
        i = i + 1;
    };
    false
}

// ---------------------------------------------------------------------------
// Scope (same approach as qualify.lang locals)
// ---------------------------------------------------------------------------

fn scope_push(r: Resolver) -> I64 { vec_push_vec(r.scope, vec_new()); 0 }

fn scope_pop(r: Resolver) -> I64 {
    let len: I64 = vec_len(r.scope);
    if len > 0 {
        // Drop last frame by reducing length
        // We reuse vec_set_len-style: just push/pop approach
        // Actually we don't have vec_set_len declared here, let's just use it
        scope_set_len(r.scope, len - 1);
    };
    0
}

fn scope_set_len(v: Vec, new_len: I64) -> I64 {
    vec_set_len(v, new_len); 0
}

fn scope_insert(r: Resolver, name: String) -> I64 {
    let len: I64 = vec_len(r.scope);
    if len > 0 { vec_push_str(vec_get_vec(r.scope, len - 1), name); };
    0
}

fn scope_contains(r: Resolver, name: String) -> Bool {
    let num_frames: I64 = vec_len(r.scope);
    let mut fi: I64 = num_frames - 1;
    while fi >= 0 {
        let frame: Vec = vec_get_vec(r.scope, fi);
        let frame_len: I64 = vec_len(frame);
        let mut j: I64 = 0;
        while j < frame_len {
            if string_eq(vec_get_str(frame, j), name) == 1 { return true; };
            j = j + 1;
        };
        fi = fi - 1;
    };
    false
}

// ---------------------------------------------------------------------------
// enum_path_and_variant: split path into (enum_name, variant_name)
//   e.g. ["Foo", "Bar"] -> enum_name="Foo", variant="Bar"
// ---------------------------------------------------------------------------

fn enum_path_str(path: Vec) -> String {
    let len: I64 = vec_len(path);
    if len < 2 { return ""; };
    let enum_path: Vec = vec_new();
    let mut i: I64 = 0;
    while i < len - 1 { vec_push_str(enum_path, vec_get_str(path, i)); i = i + 1; };
    path_to_string(enum_path)
}

fn variant_name_from_path(path: Vec) -> String {
    let len: I64 = vec_len(path);
    if len < 1 { return ""; };
    vec_get_str(path, len - 1)
}

// ---------------------------------------------------------------------------
// Phase 1: Collect global items
// ---------------------------------------------------------------------------

fn collect_items(modules: Vec) -> Vec {
    let items: Vec = vec_new();
    let num_modules: I64 = vec_len(modules);
    let mut mi: I64 = 0;
    while mi < num_modules {
        let m: Module = vec_get_module(modules, mi);
        let mod_path: Vec = m.path;
        let num_items: I64 = vec_len(m.items);
        let mut ii: I64 = 0;
        while ii < num_items {
            let item: Item = vec_get_item(m.items, ii);
            match item {
                Item::FnItem { decl } => {
                    let full: String = full_item_name(mod_path, decl.name);
                    vec_push_ientry(items, ItemEntry { name: full, kind: IK_FN() });
                },
                Item::StructItem { decl } => {
                    let full: String = full_item_name(mod_path, decl.name);
                    vec_push_ientry(items, ItemEntry { name: full, kind: IK_STRUCT() });
                },
                Item::EnumItem { decl } => {
                    let full: String = full_item_name(mod_path, decl.name);
                    vec_push_ientry(items, ItemEntry { name: full, kind: IK_ENUM() });
                },
                Item::ExternFnItem { decl } => {
                    let full: String = full_item_name(mod_path, decl.name);
                    vec_push_ientry(items, ItemEntry { name: full, kind: IK_EXTERN_FN() });
                },
                Item::UseItem { decl } => {},
                Item::LinkItem { decl } => {}
            };
            ii = ii + 1;
        };
        mi = mi + 1;
    };
    items
}

// ---------------------------------------------------------------------------
// Phase 2: Collect enum variants
// ---------------------------------------------------------------------------

fn collect_enum_variants(modules: Vec) -> Vec {
    let variants: Vec = vec_new();
    let num_modules: I64 = vec_len(modules);
    let mut mi: I64 = 0;
    while mi < num_modules {
        let m: Module = vec_get_module(modules, mi);
        let mod_path: Vec = m.path;
        let num_items: I64 = vec_len(m.items);
        let mut ii: I64 = 0;
        while ii < num_items {
            let item: Item = vec_get_item(m.items, ii);
            match item {
                Item::EnumItem { decl } => {
                    let enum_name: String = full_item_name(mod_path, decl.name);
                    let num_variants: I64 = vec_len(decl.variants);
                    let mut vi: I64 = 0;
                    while vi < num_variants {
                        let v: EnumVariant = vec_get_variant(decl.variants, vi);
                        vec_push_ventry(variants, VariantMapEntry { enum_name: enum_name, variant_name: v.name });
                        vi = vi + 1;
                    };
                },
                _ => {}
            };
            ii = ii + 1;
        };
        mi = mi + 1;
    };
    variants
}

// ---------------------------------------------------------------------------
// Type resolution
// ---------------------------------------------------------------------------

fn resolve_type_params_contains(tp: Vec, name: String) -> Bool {
    let len: I64 = vec_len(tp);
    let mut i: I64 = 0;
    while i < len {
        if string_eq(vec_get_str(tp, i), name) == 1 { return true; };
        i = i + 1;
    };
    false
}

fn resolve_type(r: Resolver, ty: Type, type_params: Vec) -> I64 {
    match ty {
        Type::PathType { path, type_args } => {
            if vec_len(path) == 1 {
                let name: String = vec_get_str(path, 0);
                if is_builtin_type(name) {
                    resolve_type_args(r, type_args, type_params);
                    return 0;
                };
                if resolve_type_params_contains(type_params, name) {
                    resolve_type_args(r, type_args, type_params);
                    return 0;
                };
            };
            let key: String = path_to_string(path);
            if items_contains(r.items, key) == false {
                resolve_error(r, string_concat("unknown type '", string_concat(key, "'")));
            };
            resolve_type_args(r, type_args, type_params);
        },
        Type::RawPtrType { inner } => { resolve_type(r, inner, type_params); },
        Type::TupleType { types } => {
            let num: I64 = vec_len(types);
            let mut i: I64 = 0;
            while i < num { resolve_type(r, vec_get_type(types, i), type_params); i = i + 1; };
        }
    };
    0
}

fn resolve_type_args(r: Resolver, type_args: Vec, type_params: Vec) -> I64 {
    let num: I64 = vec_len(type_args);
    let mut i: I64 = 0;
    while i < num { resolve_type(r, vec_get_type(type_args, i), type_params); i = i + 1; };
    0
}

// Helper to resolve fields' types
fn resolve_fields_types(r: Resolver, fields: Vec, type_params: Vec) -> I64 {
    let num: I64 = vec_len(fields);
    let mut i: I64 = 0;
    while i < num {
        let f: Field = vec_get_field(fields, i);
        resolve_type(r, f.ty, type_params);
        i = i + 1;
    };
    0
}

// Helper to resolve params' types
fn resolve_params_types(r: Resolver, params: Vec, type_params: Vec) -> I64 {
    let num: I64 = vec_len(params);
    let mut i: I64 = 0;
    while i < num {
        let p: Param = vec_get_param(params, i);
        resolve_type(r, p.ty, type_params);
        i = i + 1;
    };
    0
}

// ---------------------------------------------------------------------------
// Block resolution
// ---------------------------------------------------------------------------

fn resolve_block(r: Resolver, block: Block) -> I64 {
    scope_push(r);
    let num_stmts: I64 = vec_len(block.stmts);
    let mut si: I64 = 0;
    while si < num_stmts {
        let stmt: Stmt = vec_get_stmt(block.stmts, si);
        match stmt {
            Stmt::ExprStmt { expr, span } => { resolve_expr(r, expr); },
            Stmt::ReturnStmt { value, span } => {
                match value {
                    Option::Some { value: rv } => { resolve_expr(r, rv); },
                    Option::None {} => {}
                };
            }
        };
        si = si + 1;
    };
    match block.tail {
        Option::Some { value: tail_expr } => { resolve_expr(r, tail_expr); },
        Option::None {} => {}
    };
    scope_pop(r);
    0
}

// ---------------------------------------------------------------------------
// Expression resolution
// ---------------------------------------------------------------------------

fn resolve_expr(r: Resolver, expr: Expr) -> I64 {
    match expr {
        Expr::LetExpr { name, mutable, ty, value, span } => {
            match ty {
                Option::Some { value: t } => { resolve_type(r, t, vec_new()); },
                Option::None {} => {}
            };
            resolve_expr(r, value);
            scope_insert(r, name);
        },
        Expr::IfExpr { cond, then_branch, else_branch, span } => {
            resolve_expr(r, cond);
            resolve_block(r, then_branch);
            match else_branch {
                Option::Some { value: eb } => { resolve_block(r, eb); },
                Option::None {} => {}
            };
        },
        Expr::WhileExpr { cond, body, span } => {
            resolve_expr(r, cond);
            resolve_block(r, body);
        },
        Expr::MatchExpr { scrutinee, arms, span } => {
            resolve_expr(r, scrutinee);
            let num_arms: I64 = vec_len(arms);
            let mut ai: I64 = 0;
            while ai < num_arms {
                let arm: MatchArm = vec_get_arm(arms, ai);
                scope_push(r);
                resolve_pattern(r, arm.pattern);
                resolve_expr(r, arm.body);
                scope_pop(r);
                ai = ai + 1;
            };
        },
        Expr::AssignExpr { target, value, span } => {
            resolve_expr(r, target);
            resolve_expr(r, value);
        },
        Expr::BinaryExpr { op, left, right, span } => {
            resolve_expr(r, left);
            resolve_expr(r, right);
        },
        Expr::UnaryExpr { op, operand, span } => {
            resolve_expr(r, operand);
        },
        Expr::CallExpr { callee, args, span } => {
            resolve_expr(r, callee);
            let num_args: I64 = vec_len(args);
            let mut ai: I64 = 0;
            while ai < num_args { resolve_expr(r, vec_get_expr(args, ai)); ai = ai + 1; };
        },
        Expr::FieldExpr { base, name, span } => {
            resolve_expr(r, base);
        },
        Expr::PathExpr { path, span } => {
            resolve_value_path(r, path, span, false);
        },
        Expr::StructLitExpr { path, fields, span } => {
            resolve_struct_lit_path(r, path, span);
            let num_fields: I64 = vec_len(fields);
            let mut fi: I64 = 0;
            while fi < num_fields {
                let sf: StructLitField = vec_get_slfield(fields, fi);
                resolve_expr(r, sf.value);
                fi = fi + 1;
            };
        },
        Expr::TupleExpr { items, span } => {
            let num_items: I64 = vec_len(items);
            let mut ii: I64 = 0;
            while ii < num_items { resolve_expr(r, vec_get_expr(items, ii)); ii = ii + 1; };
        },
        Expr::LitExpr { lit, span } => {},
        Expr::BlockExpr { block } => { resolve_block(r, block); },
        Expr::BreakExpr { span } => {},
        Expr::ContinueExpr { span } => {}
    };
    0
}

// ---------------------------------------------------------------------------
// Pattern resolution
// ---------------------------------------------------------------------------

fn resolve_pattern(r: Resolver, pat: Pattern) -> I64 {
    match pat {
        Pattern::WildcardPat { span } => {},
        Pattern::PathPat { path, span } => { resolve_value_path(r, path, span, true); },
        Pattern::StructPat { path, fields, span } => {
            resolve_value_path(r, path, span, true);
            let num_fields: I64 = vec_len(fields);
            let mut fi: I64 = 0;
            while fi < num_fields {
                let pf: PatternField = vec_get_pfield(fields, fi);
                match pf.binding {
                    Option::Some { value: binding } => { scope_insert(r, binding); },
                    Option::None {} => {}
                };
                fi = fi + 1;
            };
        }
    };
    0
}

// ---------------------------------------------------------------------------
// Path resolution
// ---------------------------------------------------------------------------

fn resolve_value_path(r: Resolver, path: Vec, span: Span, in_pattern: Bool) -> I64 {
    let len: I64 = vec_len(path);
    if len == 0 { return 0; };

    // Multi-segment: check enum variant first
    if len >= 2 {
        let en: String = enum_path_str(path);
        let vn: String = variant_name_from_path(path);
        if variant_exists(r.enum_variants, en, vn) { return 0; };
    };

    // Single-segment: check scope, items, builtins
    if len == 1 {
        let name: String = vec_get_str(path, 0);
        if scope_contains(r, name) { return 0; };
        if items_contains(r.items, name) { return 0; };
        if is_builtin_type(name) { return 0; };
        if in_pattern {
            resolve_error(r, string_concat("unresolved pattern '", string_concat(name, "'")));
        } else {
            resolve_error(r, string_concat("unresolved value '", string_concat(name, "'")));
        };
        return 0;
    };

    // Multi-segment: check items map
    let key: String = path_to_string(path);
    if items_contains(r.items, key) { return 0; };
    resolve_error(r, string_concat("unresolved path '", string_concat(key, "'")));
    0
}

fn resolve_struct_lit_path(r: Resolver, path: Vec, span: Span) -> I64 {
    let len: I64 = vec_len(path);
    if len == 0 { return 0; };

    let key: String = path_to_string(path);
    let kind: I64 = items_get_kind(r.items, key);

    // Direct struct literal
    if kind == IK_STRUCT() { return 0; };

    // Could be an enum variant with struct fields
    if len >= 2 {
        let en: String = enum_path_str(path);
        let vn: String = variant_name_from_path(path);
        let ek: I64 = items_get_kind(r.items, en);
        if ek == IK_ENUM() {
            if variant_exists(r.enum_variants, en, vn) == false {
                resolve_error(r, string_concat("unknown enum variant '", string_concat(vn, "'")));
            };
            return 0;
        };
        resolve_error(r, string_concat("'", string_concat(en, "' is not an enum")));
        return 0;
    };

    resolve_error(r, string_concat("'", string_concat(key, "' is not a struct")));
    0
}

// ---------------------------------------------------------------------------
// Module resolution
// ---------------------------------------------------------------------------

fn resolve_module(r: Resolver, m: Module) -> I64 {
    let empty_tp: Vec = vec_new();
    let num_items: I64 = vec_len(m.items);
    let mut ii: I64 = 0;
    while ii < num_items {
        let item: Item = vec_get_item(m.items, ii);
        match item {
            Item::StructItem { decl } => {
                resolve_fields_types(r, decl.fields, decl.type_params);
            },
            Item::EnumItem { decl } => {
                let num_variants: I64 = vec_len(decl.variants);
                let mut vi: I64 = 0;
                while vi < num_variants {
                    let variant: EnumVariant = vec_get_variant(decl.variants, vi);
                    match variant.kind {
                        EnumVariantKind::UnitKind {} => {},
                        EnumVariantKind::TupleKind { types } => {
                            let num_types: I64 = vec_len(types);
                            let mut ti: I64 = 0;
                            while ti < num_types { resolve_type(r, vec_get_type(types, ti), decl.type_params); ti = ti + 1; };
                        },
                        EnumVariantKind::StructKind { fields } => {
                            resolve_fields_types(r, fields, decl.type_params);
                        }
                    };
                    vi = vi + 1;
                };
            },
            Item::FnItem { decl } => {
                resolve_params_types(r, decl.params, empty_tp);
                resolve_type(r, decl.ret_type, empty_tp);
                scope_push(r);
                let num_params: I64 = vec_len(decl.params);
                let mut pi: I64 = 0;
                while pi < num_params {
                    let p: Param = vec_get_param(decl.params, pi);
                    scope_insert(r, p.name);
                    pi = pi + 1;
                };
                resolve_block(r, decl.body);
                scope_pop(r);
            },
            Item::ExternFnItem { decl } => {
                resolve_params_types(r, decl.params, empty_tp);
                resolve_type(r, decl.ret_type, empty_tp);
            },
            Item::UseItem { decl } => {},
                Item::LinkItem { decl } => {}
        };
        ii = ii + 1;
    };
    0
}

// ---------------------------------------------------------------------------
// Entry point
// ---------------------------------------------------------------------------

fn resolve_modules(modules: Vec) -> I64 {
    let items: Vec = collect_items(modules);
    let enum_variants: Vec = collect_enum_variants(modules);
    let errors: Vec = vec_new();

    let num_modules: I64 = vec_len(modules);
    let mut mi: I64 = 0;
    while mi < num_modules {
        let m: Module = vec_get_module(modules, mi);
        let scope: Vec = vec_new();
        vec_push_vec(scope, vec_new());
        let r: Resolver = Resolver {
            items: items, enum_variants: enum_variants,
            scope: scope, errors: errors
        };
        resolve_module(r, m);
        mi = mi + 1;
    };

    let num_errors: I64 = vec_len(errors);
    if num_errors > 0 {
        let mut ei: I64 = 0;
        while ei < num_errors {
            print_str_stderr(string_concat("resolve error: ", vec_get_str(errors, ei)));
            ei = ei + 1;
        };
        exit_process(1);
    };
    0
}
