// ---------------------------------------------------------------------------
// AST node types for the bootstrap parser
// ---------------------------------------------------------------------------

use vec::Vec;

// Generic option type
enum Option<T> {
    Some { value: T },
    None {}
}

// Span
struct Span {
    start: I64,
    end: I64
}

// Module
struct Module {
    path: Vec,
    items: Vec
}

// Items
enum Item {
    FnItem { decl: FnDecl },
    StructItem { decl: StructDecl },
    EnumItem { decl: EnumDecl },
    ExternFnItem { decl: ExternFnDecl },
    UseItem { decl: UseDecl },
    LinkItem { decl: LinkDecl }
}

struct FnDecl {
    name: String,
    params: Vec,
    ret_type: Type,
    body: Block,
    span: Span
}

struct ExternFnDecl {
    name: String,
    params: Vec,
    varargs: Bool,
    ret_type: Type,
    span: Span
}

struct StructDecl {
    name: String,
    type_params: Vec,
    fields: Vec,
    span: Span
}

struct EnumDecl {
    name: String,
    type_params: Vec,
    variants: Vec,
    span: Span
}

struct EnumVariant {
    name: String,
    kind: EnumVariantKind,
    span: Span
}

enum EnumVariantKind {
    UnitKind {},
    TupleKind { types: Vec },
    StructKind { fields: Vec }
}

struct UseDecl {
    path: Vec,
    span: Span
}

struct LinkDecl {
    lib: String,
    span: Span
}

// Fields & params
struct Field {
    name: String,
    ty: Type,
    span: Span
}

struct Param {
    name: String,
    ty: Type,
    span: Span
}

// Block
struct Block {
    stmts: Vec,
    tail: Option<Expr>,
    span: Span
}

// Statements
enum Stmt {
    ExprStmt { expr: Expr, span: Span },
    ReturnStmt { value: Option<Expr>, span: Span }
}

// Expressions
enum Expr {
    LetExpr { name: String, mutable: Bool, ty: Option<Type>, value: Expr, span: Span },
    IfExpr { cond: Expr, then_branch: Block, else_branch: Option<Block>, span: Span },
    WhileExpr { cond: Expr, body: Block, span: Span },
    MatchExpr { scrutinee: Expr, arms: Vec, span: Span },
    AssignExpr { target: Expr, value: Expr, span: Span },
    BinaryExpr { op: BinaryOp, left: Expr, right: Expr, span: Span },
    UnaryExpr { op: UnaryOp, operand: Expr, span: Span },
    CallExpr { callee: Expr, args: Vec, span: Span },
    FieldExpr { base: Expr, name: String, span: Span },
    PathExpr { path: Vec, span: Span },
    StructLitExpr { path: Vec, fields: Vec, span: Span },
    TupleExpr { items: Vec, span: Span },
    LitExpr { lit: Literal, span: Span },
    BlockExpr { block: Block },
    BreakExpr { span: Span },
    ContinueExpr { span: Span }
}

// Literal
enum Literal {
    IntLiteral { text: String },
    FloatLiteral { text: String },
    StrLiteral { text: String },
    BoolLiteral { value: Bool },
    CharLiteral { value: I64 },
    UnitLiteral {}
}

// Operators
enum BinaryOp {
    Add {},
    Sub {},
    Mul {},
    Div {},
    Rem {},
    Eq {},
    NotEq {},
    Lt {},
    LtEq {},
    Gt {},
    GtEq {},
    AndAnd {},
    OrOr {}
}

enum UnaryOp {
    Neg {},
    Not {}
}

// Types
enum Type {
    PathType { path: Vec, type_args: Vec },
    RawPtrType { inner: Type },
    TupleType { types: Vec }
}

// Patterns
enum Pattern {
    WildcardPat { span: Span },
    PathPat { path: Vec, span: Span },
    StructPat { path: Vec, fields: Vec, span: Span }
}

// Match arm
struct MatchArm {
    pattern: Pattern,
    body: Expr,
    span: Span
}

// Pattern field
struct PatternField {
    name: String,
    binding: Option<String>,
    span: Span
}

// Struct literal field
struct StructLitField {
    name: String,
    value: Expr
}

// Qualify pass helper types
struct ItemEntry {
    name: String,
    kind: I64
}

struct UseEntry {
    alias: String,
    path: Vec
}

// Resolve pass helper types
struct VariantMapEntry {
    enum_name: String,
    variant_name: String
}

// ---------------------------------------------------------------------------
// Typecheck pass types
// ---------------------------------------------------------------------------

// Internal type representation (18 variants)
enum Ty {
    TyI8 {},
    TyI16 {},
    TyI32 {},
    TyI64 {},
    TyU8 {},
    TyU16 {},
    TyU32 {},
    TyU64 {},
    TyF32 {},
    TyF64 {},
    TyBool {},
    TyUnit {},
    TyString {},
    TyRawPtr { inner: Ty },
    TyStruct { name: String, type_args: Vec },
    TyEnum { name: String, type_args: Vec },
    TyTuple { items: Vec },
    TyParam { name: String }
}

struct TypeField {
    name: String,
    ty: Ty
}

struct SubstEntry {
    name: String,
    ty: Ty
}

enum VariantDef {
    VUnit {},
    VTuple { types: Vec },
    VStruct { fields: Vec }
}

struct VariantDefEntry {
    name: String,
    def: VariantDef
}

struct StructMapEntry {
    name: String,
    type_params: Vec,
    fields: Vec
}

struct EnumMapEntry {
    name: String,
    type_params: Vec,
    variants: Vec
}

struct FnMapEntry {
    name: String,
    params: Vec,
    ret: Ty,
    varargs: Bool
}

struct LocalEntry {
    name: String,
    ty: Ty
}

// ---------------------------------------------------------------------------
// Codegen pass types
// ---------------------------------------------------------------------------

// All structs include name so we can store them directly in vecs and
// do linear-search lookups without needing separate "Named" wrapper types.

struct CgFieldLayout {
    name: String,
    type_name: String,
    index: I64,
    is_ptr: Bool,
    llvm_ty: RawPointer<I8>,
    lang_ty_tag: I64
}

struct CgStructLayout {
    name: String,
    field_count: I64,
    ptr_field_count: I64,
    type_id: I64,
    fields: Vec
}

struct CgVariantFieldLayout {
    name: String,
    type_name: String,
    is_ptr: Bool,
    field_index: I64,
    llvm_ty: RawPointer<I8>,
    lang_ty_tag: I64
}

struct CgVariantLayout {
    name: String,
    tag: I64,
    fields: Vec
}

struct CgEnumLayout {
    name: String,
    field_count: I64,
    ptr_field_count: I64,
    type_id: I64,
    variants: Vec
}

struct CgLocal {
    name: String,
    type_name: String,
    ptr: RawPointer<I8>,
    ty: RawPointer<I8>,
    lang_ty_tag: I64,
    is_gc_ref: Bool
}

struct CgFnEntry {
    name: String,
    fn_val: RawPointer<I8>,
    fn_ty: RawPointer<I8>
}

struct LoopEntry {
    cond_bb: RawPointer<I8>,
    break_bb: RawPointer<I8>
}
