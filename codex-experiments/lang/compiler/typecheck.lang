// ---------------------------------------------------------------------------
// Typecheck pass â€” verify types of all expressions
// ---------------------------------------------------------------------------

use ast::Option;
use ast::Span;
use ast::Module;
use ast::Item;
use ast::FnDecl;
use ast::ExternFnDecl;
use ast::StructDecl;
use ast::EnumDecl;
use ast::EnumVariant;
use ast::EnumVariantKind;
use ast::Field;
use ast::Param;
use ast::Block;
use ast::Stmt;
use ast::Expr;
use ast::Literal;
use ast::BinaryOp;
use ast::UnaryOp;
use ast::Type;
use ast::Pattern;
use ast::MatchArm;
use ast::PatternField;
use ast::StructLitField;
use ast::Ty;
use ast::TypeField;
use ast::SubstEntry;
use ast::VariantDef;
use ast::VariantDefEntry;
use ast::StructMapEntry;
use ast::EnumMapEntry;
use ast::FnMapEntry;
use ast::LocalEntry;

use vec::Vec;
use vec::vec_new;
use vec::vec_len;
use vec::vec_push;
use vec::vec_get;
use vec::vec_set_len;
use vec::vec_push_str;
use vec::vec_get_str;
use vec::vec_get_module;
use vec::vec_get_item;
use vec::vec_get_field;
use vec::vec_get_param;
use vec::vec_get_variant;
use vec::vec_get_type;
use vec::vec_get_expr;
use vec::vec_get_arm;
use vec::vec_get_stmt;
use vec::vec_get_pfield;
use vec::vec_get_slfield;
use vec::vec_get_vec;

// typecheck-specific vec aliases
fn vec_push_ty(v: Vec, item: Ty) -> I64 { vec_push(v, item) }
fn vec_get_ty(v: Vec, index: I64) -> Ty { vec_get(v, index) }
fn vec_push_smentry(v: Vec, item: StructMapEntry) -> I64 { vec_push(v, item) }
fn vec_get_smentry(v: Vec, index: I64) -> StructMapEntry { vec_get(v, index) }
fn vec_push_ementry(v: Vec, item: EnumMapEntry) -> I64 { vec_push(v, item) }
fn vec_get_ementry(v: Vec, index: I64) -> EnumMapEntry { vec_get(v, index) }
fn vec_push_fnentry(v: Vec, item: FnMapEntry) -> I64 { vec_push(v, item) }
fn vec_get_fnentry(v: Vec, index: I64) -> FnMapEntry { vec_get(v, index) }
fn vec_push_vdentry(v: Vec, item: VariantDefEntry) -> I64 { vec_push(v, item) }
fn vec_get_vdentry(v: Vec, index: I64) -> VariantDefEntry { vec_get(v, index) }
fn vec_push_subst(v: Vec, item: SubstEntry) -> I64 { vec_push(v, item) }
fn vec_get_subst(v: Vec, index: I64) -> SubstEntry { vec_get(v, index) }
fn vec_push_local(v: Vec, item: LocalEntry) -> I64 { vec_push(v, item) }
fn vec_get_local(v: Vec, index: I64) -> LocalEntry { vec_get(v, index) }
fn vec_push_tfield(v: Vec, item: TypeField) -> I64 { vec_push(v, item) }
fn vec_get_tfield(v: Vec, index: I64) -> TypeField { vec_get(v, index) }

use string::string_eq;
use string::string_concat;
use string::string_from_i64;
use string::string_parse_i64;
use io::print_str_stderr;
use io::exit_process;

// ---------------------------------------------------------------------------
// TypeEnv and TypeChecker structs
// ---------------------------------------------------------------------------

struct TypeEnv {
    structs: Vec,
    enums: Vec,
    fns: Vec,
    extern_fns: Vec,
    struct_names: Vec,
    enum_names: Vec
}

struct TypeChecker {
    env: TypeEnv,
    locals: Vec,
    return_type: Ty,
    errors: Vec,
    loop_depth: I64
}

// ---------------------------------------------------------------------------
// Utility: path and name helpers
// ---------------------------------------------------------------------------

fn path_to_string(path: Vec) -> String {
    let len: I64 = vec_len(path);
    if len == 0 { return ""; };
    let mut result: String = vec_get_str(path, 0);
    let mut i: I64 = 1;
    while i < len {
        result = string_concat(result, string_concat("::", vec_get_str(path, i)));
        i = i + 1;
    };
    result
}

fn full_item_name(module_path: Vec, name: String) -> String {
    if vec_len(module_path) == 0 { name }
    else { string_concat(path_to_string(module_path), string_concat("::", name)) }
}

fn enum_path_str(path: Vec) -> String {
    let len: I64 = vec_len(path);
    if len < 2 { return ""; };
    let ep: Vec = vec_new();
    let mut i: I64 = 0;
    while i < len - 1 { vec_push_str(ep, vec_get_str(path, i)); i = i + 1; };
    path_to_string(ep)
}

fn variant_name_from_path(path: Vec) -> String {
    let len: I64 = vec_len(path);
    if len < 1 { return ""; };
    vec_get_str(path, len - 1)
}

fn expr_span(expr: Expr) -> Span {
    match expr {
        Expr::LetExpr { name, mutable, ty, value, span } => { span },
        Expr::IfExpr { cond, then_branch, else_branch, span } => { span },
        Expr::WhileExpr { cond, body, span } => { span },
        Expr::MatchExpr { scrutinee, arms, span } => { span },
        Expr::AssignExpr { target, value, span } => { span },
        Expr::BinaryExpr { op, left, right, span } => { span },
        Expr::UnaryExpr { op, operand, span } => { span },
        Expr::CallExpr { callee, args, span } => { span },
        Expr::FieldExpr { base, name, span } => { span },
        Expr::PathExpr { path, span } => { span },
        Expr::StructLitExpr { path, fields, span } => { span },
        Expr::TupleExpr { items, span } => { span },
        Expr::LitExpr { lit, span } => { span },
        Expr::BlockExpr { block } => { block.span },
        Expr::BreakExpr { span } => { span },
        Expr::ContinueExpr { span } => { span }
    }
}

fn str_vec_contains(v: Vec, s: String) -> Bool {
    let len: I64 = vec_len(v);
    let mut i: I64 = 0;
    while i < len {
        if string_eq(vec_get_str(v, i), s) == 1 { return true; };
        i = i + 1;
    };
    false
}

// ---------------------------------------------------------------------------
// Builtin type helpers
// ---------------------------------------------------------------------------

fn is_builtin_type_name(name: String) -> Bool {
    if string_eq(name, "I8") == 1 { return true; };
    if string_eq(name, "I16") == 1 { return true; };
    if string_eq(name, "I32") == 1 { return true; };
    if string_eq(name, "I64") == 1 { return true; };
    if string_eq(name, "U8") == 1 { return true; };
    if string_eq(name, "U16") == 1 { return true; };
    if string_eq(name, "U32") == 1 { return true; };
    if string_eq(name, "U64") == 1 { return true; };
    if string_eq(name, "F32") == 1 { return true; };
    if string_eq(name, "F64") == 1 { return true; };
    if string_eq(name, "Bool") == 1 { return true; };
    if string_eq(name, "Unit") == 1 { return true; };
    if string_eq(name, "String") == 1 { return true; };
    false
}

fn name_to_builtin_ty(name: String) -> Ty {
    if string_eq(name, "I8") == 1 { return Ty::TyI8 {}; };
    if string_eq(name, "I16") == 1 { return Ty::TyI16 {}; };
    if string_eq(name, "I32") == 1 { return Ty::TyI32 {}; };
    if string_eq(name, "I64") == 1 { return Ty::TyI64 {}; };
    if string_eq(name, "U8") == 1 { return Ty::TyU8 {}; };
    if string_eq(name, "U16") == 1 { return Ty::TyU16 {}; };
    if string_eq(name, "U32") == 1 { return Ty::TyU32 {}; };
    if string_eq(name, "U64") == 1 { return Ty::TyU64 {}; };
    if string_eq(name, "F32") == 1 { return Ty::TyF32 {}; };
    if string_eq(name, "F64") == 1 { return Ty::TyF64 {}; };
    if string_eq(name, "Bool") == 1 { return Ty::TyBool {}; };
    if string_eq(name, "Unit") == 1 { return Ty::TyUnit {}; };
    if string_eq(name, "String") == 1 { return Ty::TyString {}; };
    Ty::TyUnit {}
}

// ---------------------------------------------------------------------------
// Type predicates
// ---------------------------------------------------------------------------

fn is_int_ty(ty: Ty) -> Bool {
    match ty {
        Ty::TyI8 {} => { true },
        Ty::TyI16 {} => { true },
        Ty::TyI32 {} => { true },
        Ty::TyI64 {} => { true },
        Ty::TyU8 {} => { true },
        Ty::TyU16 {} => { true },
        Ty::TyU32 {} => { true },
        Ty::TyU64 {} => { true },
        _ => { false }
    }
}

fn is_float_ty(ty: Ty) -> Bool {
    match ty {
        Ty::TyF32 {} => { true },
        Ty::TyF64 {} => { true },
        _ => { false }
    }
}

fn is_numeric_ty(ty: Ty) -> Bool {
    if is_int_ty(ty) { true }
    else { is_float_ty(ty) }
}

// ---------------------------------------------------------------------------
// Type equality
// ---------------------------------------------------------------------------

fn ty_eq(a: Ty, b: Ty) -> Bool {
    match a {
        Ty::TyI8 {} => { match b { Ty::TyI8 {} => { true }, _ => { false } } },
        Ty::TyI16 {} => { match b { Ty::TyI16 {} => { true }, _ => { false } } },
        Ty::TyI32 {} => { match b { Ty::TyI32 {} => { true }, _ => { false } } },
        Ty::TyI64 {} => { match b { Ty::TyI64 {} => { true }, _ => { false } } },
        Ty::TyU8 {} => { match b { Ty::TyU8 {} => { true }, _ => { false } } },
        Ty::TyU16 {} => { match b { Ty::TyU16 {} => { true }, _ => { false } } },
        Ty::TyU32 {} => { match b { Ty::TyU32 {} => { true }, _ => { false } } },
        Ty::TyU64 {} => { match b { Ty::TyU64 {} => { true }, _ => { false } } },
        Ty::TyF32 {} => { match b { Ty::TyF32 {} => { true }, _ => { false } } },
        Ty::TyF64 {} => { match b { Ty::TyF64 {} => { true }, _ => { false } } },
        Ty::TyBool {} => { match b { Ty::TyBool {} => { true }, _ => { false } } },
        Ty::TyUnit {} => { match b { Ty::TyUnit {} => { true }, _ => { false } } },
        Ty::TyString {} => { match b { Ty::TyString {} => { true }, _ => { false } } },
        Ty::TyRawPtr { inner } => {
            match b {
                Ty::TyRawPtr { inner: bi } => { ty_eq(inner, bi) },
                _ => { false }
            }
        },
        Ty::TyStruct { name, type_args } => {
            match b {
                Ty::TyStruct { name: bn, type_args: ba } => {
                    if string_eq(name, bn) == 0 { return false; };
                    tys_eq(type_args, ba)
                },
                _ => { false }
            }
        },
        Ty::TyEnum { name, type_args } => {
            match b {
                Ty::TyEnum { name: bn, type_args: ba } => {
                    if string_eq(name, bn) == 0 { return false; };
                    tys_eq(type_args, ba)
                },
                _ => { false }
            }
        },
        Ty::TyTuple { items } => {
            match b {
                Ty::TyTuple { items: bi } => { tys_eq(items, bi) },
                _ => { false }
            }
        },
        Ty::TyParam { name } => {
            match b {
                Ty::TyParam { name: bn } => { string_eq(name, bn) == 1 },
                _ => { false }
            }
        }
    }
}

fn tys_eq(a: Vec, b: Vec) -> Bool {
    let la: I64 = vec_len(a);
    let lb: I64 = vec_len(b);
    if la != lb { return false; };
    let mut i: I64 = 0;
    while i < la {
        let ta: Ty = vec_get_ty(a, i);
        let tb: Ty = vec_get_ty(b, i);
        if ty_eq(ta, tb) == false { return false; };
        i = i + 1;
    };
    true
}

// ---------------------------------------------------------------------------
// Map lookups (linear scan)
// ---------------------------------------------------------------------------

fn env_get_struct(env: TypeEnv, name: String) -> StructMapEntry {
    let len: I64 = vec_len(env.structs);
    let mut i: I64 = 0;
    while i < len {
        let e: StructMapEntry = vec_get_smentry(env.structs, i);
        if string_eq(e.name, name) == 1 { return e; };
        i = i + 1;
    };
    StructMapEntry { name: "", type_params: vec_new(), fields: vec_new() }
}

fn env_has_struct(env: TypeEnv, name: String) -> Bool {
    let e: StructMapEntry = env_get_struct(env, name);
    string_eq(e.name, "") == 0
}

fn env_get_enum(env: TypeEnv, name: String) -> EnumMapEntry {
    let len: I64 = vec_len(env.enums);
    let mut i: I64 = 0;
    while i < len {
        let e: EnumMapEntry = vec_get_ementry(env.enums, i);
        if string_eq(e.name, name) == 1 { return e; };
        i = i + 1;
    };
    EnumMapEntry { name: "", type_params: vec_new(), variants: vec_new() }
}

fn env_has_enum(env: TypeEnv, name: String) -> Bool {
    let e: EnumMapEntry = env_get_enum(env, name);
    string_eq(e.name, "") == 0
}

fn env_get_fn(env: TypeEnv, name: String) -> FnMapEntry {
    let len: I64 = vec_len(env.fns);
    let mut i: I64 = 0;
    while i < len {
        let e: FnMapEntry = vec_get_fnentry(env.fns, i);
        if string_eq(e.name, name) == 1 { return e; };
        i = i + 1;
    };
    FnMapEntry { name: "", params: vec_new(), ret: Ty::TyUnit {}, varargs: false }
}

fn env_has_fn(env: TypeEnv, name: String) -> Bool {
    let e: FnMapEntry = env_get_fn(env, name);
    string_eq(e.name, "") == 0
}

fn env_get_extern_fn(env: TypeEnv, name: String) -> FnMapEntry {
    let len: I64 = vec_len(env.extern_fns);
    let mut i: I64 = 0;
    while i < len {
        let e: FnMapEntry = vec_get_fnentry(env.extern_fns, i);
        if string_eq(e.name, name) == 1 { return e; };
        i = i + 1;
    };
    FnMapEntry { name: "", params: vec_new(), ret: Ty::TyUnit {}, varargs: false }
}

fn env_has_extern_fn(env: TypeEnv, name: String) -> Bool {
    let e: FnMapEntry = env_get_extern_fn(env, name);
    string_eq(e.name, "") == 0
}

fn variant_get(variants: Vec, name: String) -> VariantDefEntry {
    let len: I64 = vec_len(variants);
    let mut i: I64 = 0;
    while i < len {
        let e: VariantDefEntry = vec_get_vdentry(variants, i);
        if string_eq(e.name, name) == 1 { return e; };
        i = i + 1;
    };
    VariantDefEntry { name: "", def: VariantDef::VUnit {} }
}

fn variant_has(variants: Vec, name: String) -> Bool {
    let e: VariantDefEntry = variant_get(variants, name);
    string_eq(e.name, "") == 0
}

fn subst_get(map: Vec, name: String) -> Ty {
    let len: I64 = vec_len(map);
    let mut i: I64 = 0;
    while i < len {
        let e: SubstEntry = vec_get_subst(map, i);
        if string_eq(e.name, name) == 1 { return e.ty; };
        i = i + 1;
    };
    Ty::TyParam { name: name }
}

// ---------------------------------------------------------------------------
// Type lowering: AST Type -> Ty
// ---------------------------------------------------------------------------

fn lower_type(ty: Type, struct_names: Vec, enum_names: Vec, type_params: Vec) -> Ty {
    match ty {
        Type::PathType { path, type_args } => {
            if vec_len(path) == 1 {
                let name: String = vec_get_str(path, 0);
                if is_builtin_type_name(name) { return name_to_builtin_ty(name); };
                if str_vec_contains(type_params, name) { return Ty::TyParam { name: name }; };
            };
            let key: String = path_to_string(path);
            let lowered_args: Vec = lower_type_list(type_args, struct_names, enum_names, type_params);
            if str_vec_contains(enum_names, key) {
                return Ty::TyEnum { name: key, type_args: lowered_args };
            };
            Ty::TyStruct { name: key, type_args: lowered_args }
        },
        Type::RawPtrType { inner } => {
            Ty::TyRawPtr { inner: lower_type(inner, struct_names, enum_names, type_params) }
        },
        Type::TupleType { types } => {
            Ty::TyTuple { items: lower_type_list(types, struct_names, enum_names, type_params) }
        }
    }
}

fn lower_type_list(types: Vec, struct_names: Vec, enum_names: Vec, type_params: Vec) -> Vec {
    let result: Vec = vec_new();
    let len: I64 = vec_len(types);
    let mut i: I64 = 0;
    while i < len {
        let t: Type = vec_get_type(types, i);
        vec_push_ty(result, lower_type(t, struct_names, enum_names, type_params));
        i = i + 1;
    };
    result
}

fn lower_type_env(ty: Type, env: TypeEnv, type_params: Vec) -> Ty {
    lower_type(ty, env.struct_names, env.enum_names, type_params)
}

// ---------------------------------------------------------------------------
// Substitution
// ---------------------------------------------------------------------------

fn substitute(ty: Ty, map: Vec) -> Ty {
    if vec_len(map) == 0 { return ty; };
    match ty {
        Ty::TyParam { name } => { subst_get(map, name) },
        Ty::TyStruct { name, type_args } => {
            Ty::TyStruct { name: name, type_args: substitute_list(type_args, map) }
        },
        Ty::TyEnum { name, type_args } => {
            Ty::TyEnum { name: name, type_args: substitute_list(type_args, map) }
        },
        Ty::TyRawPtr { inner } => {
            Ty::TyRawPtr { inner: substitute(inner, map) }
        },
        Ty::TyTuple { items } => {
            Ty::TyTuple { items: substitute_list(items, map) }
        },
        _ => { ty }
    }
}

fn substitute_list(tys: Vec, map: Vec) -> Vec {
    let result: Vec = vec_new();
    let len: I64 = vec_len(tys);
    let mut i: I64 = 0;
    while i < len {
        let t: Ty = vec_get_ty(tys, i);
        vec_push_ty(result, substitute(t, map));
        i = i + 1;
    };
    result
}

fn build_subst_map(type_params: Vec, type_args: Vec) -> Vec {
    let map: Vec = vec_new();
    let len: I64 = vec_len(type_params);
    let arg_len: I64 = vec_len(type_args);
    let mut i: I64 = 0;
    while i < len {
        if i < arg_len {
            let a: Ty = vec_get_ty(type_args, i);
            vec_push_subst(map, SubstEntry { name: vec_get_str(type_params, i), ty: a });
        };
        i = i + 1;
    };
    map
}

// ---------------------------------------------------------------------------
// Build type environment from modules
// ---------------------------------------------------------------------------

fn build_env(modules: Vec) -> TypeEnv {
    let struct_names: Vec = vec_new();
    let enum_names: Vec = vec_new();
    let structs: Vec = vec_new();
    let enums: Vec = vec_new();
    let fns: Vec = vec_new();
    let extern_fns: Vec = vec_new();

    // Pass 1: collect struct/enum names
    let num_modules: I64 = vec_len(modules);
    let mut mi: I64 = 0;
    while mi < num_modules {
        let m: Module = vec_get_module(modules, mi);
        let mod_path: Vec = m.path;
        let num_items: I64 = vec_len(m.items);
        let mut ii: I64 = 0;
        while ii < num_items {
            let item: Item = vec_get_item(m.items, ii);
            match item {
                Item::StructItem { decl } => {
                    vec_push_str(struct_names, full_item_name(mod_path, decl.name));
                },
                Item::EnumItem { decl } => {
                    vec_push_str(enum_names, full_item_name(mod_path, decl.name));
                },
                _ => {}
            };
            ii = ii + 1;
        };
        mi = mi + 1;
    };

    // Pass 2: build full info
    mi = 0;
    while mi < num_modules {
        let m: Module = vec_get_module(modules, mi);
        let mod_path: Vec = m.path;
        let num_items: I64 = vec_len(m.items);
        let mut ii: I64 = 0;
        while ii < num_items {
            let item: Item = vec_get_item(m.items, ii);
            match item {
                Item::StructItem { decl } => {
                    let tp: Vec = decl.type_params;
                    let fields: Vec = vec_new();
                    let num_fields: I64 = vec_len(decl.fields);
                    let mut fi: I64 = 0;
                    while fi < num_fields {
                        let f: Field = vec_get_field(decl.fields, fi);
                        let fty: Ty = lower_type(f.ty, struct_names, enum_names, tp);
                        vec_push_tfield(fields, TypeField { name: f.name, ty: fty });
                        fi = fi + 1;
                    };
                    let sname: String = full_item_name(mod_path, decl.name);
                    vec_push_smentry(structs, StructMapEntry { name: sname, type_params: tp, fields: fields });
                },
                Item::EnumItem { decl } => {
                    let tp: Vec = decl.type_params;
                    let variants: Vec = vec_new();
                    let num_variants: I64 = vec_len(decl.variants);
                    let mut vi: I64 = 0;
                    while vi < num_variants {
                        let v: EnumVariant = vec_get_variant(decl.variants, vi);
                        match v.kind {
                            EnumVariantKind::UnitKind {} => {
                                vec_push_vdentry(variants, VariantDefEntry { name: v.name, def: VariantDef::VUnit {} });
                            },
                            EnumVariantKind::TupleKind { types } => {
                                let vtypes: Vec = lower_type_list(types, struct_names, enum_names, tp);
                                vec_push_vdentry(variants, VariantDefEntry { name: v.name, def: VariantDef::VTuple { types: vtypes } });
                            },
                            EnumVariantKind::StructKind { fields } => {
                                let vfields: Vec = vec_new();
                                let num_sf: I64 = vec_len(fields);
                                let mut sfi: I64 = 0;
                                while sfi < num_sf {
                                    let sf: Field = vec_get_field(fields, sfi);
                                    let sfty: Ty = lower_type(sf.ty, struct_names, enum_names, tp);
                                    vec_push_tfield(vfields, TypeField { name: sf.name, ty: sfty });
                                    sfi = sfi + 1;
                                };
                                vec_push_vdentry(variants, VariantDefEntry { name: v.name, def: VariantDef::VStruct { fields: vfields } });
                            }
                        };
                        vi = vi + 1;
                    };
                    let ename: String = full_item_name(mod_path, decl.name);
                    vec_push_ementry(enums, EnumMapEntry { name: ename, type_params: tp, variants: variants });
                },
                Item::FnItem { decl } => {
                    let empty_tp: Vec = vec_new();
                    let params: Vec = vec_new();
                    let num_params: I64 = vec_len(decl.params);
                    let mut pi: I64 = 0;
                    while pi < num_params {
                        let p: Param = vec_get_param(decl.params, pi);
                        vec_push_ty(params, lower_type(p.ty, struct_names, enum_names, empty_tp));
                        pi = pi + 1;
                    };
                    let ret: Ty = lower_type(decl.ret_type, struct_names, enum_names, empty_tp);
                    let fname: String = full_item_name(mod_path, decl.name);
                    vec_push_fnentry(fns, FnMapEntry { name: fname, params: params, ret: ret, varargs: false });
                },
                Item::ExternFnItem { decl } => {
                    let empty_tp: Vec = vec_new();
                    let eparams: Vec = vec_new();
                    let enum_ps: I64 = vec_len(decl.params);
                    let mut epi: I64 = 0;
                    while epi < enum_ps {
                        let ep: Param = vec_get_param(decl.params, epi);
                        vec_push_ty(eparams, lower_type(ep.ty, struct_names, enum_names, empty_tp));
                        epi = epi + 1;
                    };
                    let eret: Ty = lower_type(decl.ret_type, struct_names, enum_names, empty_tp);
                    let efname: String = full_item_name(mod_path, decl.name);
                    vec_push_fnentry(extern_fns, FnMapEntry { name: efname, params: eparams, ret: eret, varargs: decl.varargs });
                },
                Item::UseItem { decl } => {},
                Item::LinkItem { decl } => {}
            };
            ii = ii + 1;
        };
        mi = mi + 1;
    };

    TypeEnv {
        structs: structs, enums: enums, fns: fns, extern_fns: extern_fns,
        struct_names: struct_names, enum_names: enum_names
    }
}

// ---------------------------------------------------------------------------
// Scope management
// ---------------------------------------------------------------------------

fn tc_locals_push(tc: TypeChecker) -> I64 {
    vec_push(tc.locals, vec_new());
    0
}

fn tc_locals_pop(tc: TypeChecker) -> I64 {
    let len: I64 = vec_len(tc.locals);
    if len > 0 { vec_set_len(tc.locals, len - 1); };
    0
}

fn tc_locals_insert(tc: TypeChecker, name: String, ty: Ty) -> I64 {
    let len: I64 = vec_len(tc.locals);
    if len > 0 {
        let frame: Vec = vec_get_vec(tc.locals, len - 1);
        vec_push_local(frame, LocalEntry { name: name, ty: ty });
    };
    0
}

fn tc_locals_get(tc: TypeChecker, name: String) -> Ty {
    let num_frames: I64 = vec_len(tc.locals);
    let mut fi: I64 = num_frames - 1;
    while fi >= 0 {
        let frame: Vec = vec_get_vec(tc.locals, fi);
        let frame_len: I64 = vec_len(frame);
        let mut j: I64 = 0;
        while j < frame_len {
            let entry: LocalEntry = vec_get_local(frame, j);
            if string_eq(entry.name, name) == 1 { return entry.ty; };
            j = j + 1;
        };
        fi = fi - 1;
    };
    Ty::TyUnit {}
}

fn tc_locals_has(tc: TypeChecker, name: String) -> Bool {
    let num_frames: I64 = vec_len(tc.locals);
    let mut fi: I64 = num_frames - 1;
    while fi >= 0 {
        let frame: Vec = vec_get_vec(tc.locals, fi);
        let frame_len: I64 = vec_len(frame);
        let mut j: I64 = 0;
        while j < frame_len {
            let entry: LocalEntry = vec_get_local(frame, j);
            if string_eq(entry.name, name) == 1 { return true; };
            j = j + 1;
        };
        fi = fi - 1;
    };
    false
}

// ---------------------------------------------------------------------------
// Error reporting
// ---------------------------------------------------------------------------

fn tc_error(tc: TypeChecker, msg: String) -> I64 {
    vec_push_str(tc.errors, msg);
    0
}

fn ty_to_string(ty: Ty) -> String {
    match ty {
        Ty::TyI8 {} => { "I8" },
        Ty::TyI16 {} => { "I16" },
        Ty::TyI32 {} => { "I32" },
        Ty::TyI64 {} => { "I64" },
        Ty::TyU8 {} => { "U8" },
        Ty::TyU16 {} => { "U16" },
        Ty::TyU32 {} => { "U32" },
        Ty::TyU64 {} => { "U64" },
        Ty::TyF32 {} => { "F32" },
        Ty::TyF64 {} => { "F64" },
        Ty::TyBool {} => { "Bool" },
        Ty::TyUnit {} => { "Unit" },
        Ty::TyString {} => { "String" },
        Ty::TyRawPtr { inner } => { string_concat("RawPointer<", string_concat(ty_to_string(inner), ">")) },
        Ty::TyStruct { name, type_args } => { name },
        Ty::TyEnum { name, type_args } => { name },
        Ty::TyTuple { items } => { "(tuple)" },
        Ty::TyParam { name } => { name }
    }
}

fn is_raw_ptr_i8(t: Ty) -> Bool {
    match t {
        Ty::TyRawPtr { inner } => {
            match inner {
                Ty::TyI8 {} => { true },
                _ => { false }
            }
        },
        _ => { false }
    }
}

fn types_compatible(a: Ty, b: Ty) -> Bool {
    if is_raw_ptr_i8(a) {
        match b {
            Ty::TyStruct { name, type_args } => { return true; },
            Ty::TyEnum { name, type_args } => { return true; },
            Ty::TyRawPtr { inner } => { return true; },
            Ty::TyString {} => { return true; },
            _ => {}
        };
    };
    if is_raw_ptr_i8(b) {
        match a {
            Ty::TyStruct { name, type_args } => { return true; },
            Ty::TyEnum { name, type_args } => { return true; },
            Ty::TyRawPtr { inner } => { return true; },
            Ty::TyString {} => { return true; },
            _ => {}
        };
    };
    false
}

fn expect_type(tc: TypeChecker, expected: Ty, actual: Ty, msg: String) -> I64 {
    if ty_eq(expected, actual) == false {
        if types_compatible(expected, actual) == false {
            tc_error(tc, string_concat(msg, string_concat(": expected ", string_concat(ty_to_string(expected), string_concat(", got ", ty_to_string(actual))))));
        };
    };
    0
}

// ---------------------------------------------------------------------------
// Check block
// ---------------------------------------------------------------------------

fn check_block(tc: TypeChecker, block: Block, expected: Ty, has_expected: Bool) -> Ty {
    tc_locals_push(tc);
    let num_stmts: I64 = vec_len(block.stmts);
    let mut si: I64 = 0;
    while si < num_stmts {
        let stmt: Stmt = vec_get_stmt(block.stmts, si);
        match stmt {
            Stmt::ExprStmt { expr, span } => {
                check_expr(tc, expr, Ty::TyUnit {}, false);
            },
            Stmt::ReturnStmt { value, span } => {
                let ret_ty: Ty = tc.return_type;
                match value {
                    Option::Some { value: rv } => {
                        let ty: Ty = check_expr(tc, rv, ret_ty, true);
                        expect_type(tc, ret_ty, ty, "return type mismatch");
                    },
                    Option::None {} => {
                        expect_type(tc, ret_ty, Ty::TyUnit {}, "return type mismatch");
                    }
                };
            }
        };
        si = si + 1;
    };
    let result: Ty = match block.tail {
        Option::Some { value: tail_expr } => { check_expr(tc, tail_expr, expected, has_expected) },
        Option::None {} => { Ty::TyUnit {} }
    };
    if has_expected {
        expect_type(tc, expected, result, "block type mismatch");
    };
    tc_locals_pop(tc);
    result
}

// ---------------------------------------------------------------------------
// Check expression (main dispatch)
// ---------------------------------------------------------------------------

fn check_expr(tc: TypeChecker, expr: Expr, expected: Ty, has_expected: Bool) -> Ty {
    match expr {
        Expr::LetExpr { name, mutable, ty, value, span } => {
            match ty {
                Option::Some { value: annot } => {
                    let empty_tp: Vec = vec_new();
                    let annot_ty: Ty = lower_type_env(annot, tc.env, empty_tp);
                    let value_ty: Ty = check_expr(tc, value, annot_ty, true);
                    expect_type(tc, annot_ty, value_ty, "let type mismatch");
                    tc_locals_insert(tc, name, annot_ty);
                },
                Option::None {} => {
                    let value_ty: Ty = check_expr(tc, value, Ty::TyUnit {}, false);
                    tc_locals_insert(tc, name, value_ty);
                }
            };
            Ty::TyUnit {}
        },
        Expr::IfExpr { cond, then_branch, else_branch, span } => {
            let cond_ty: Ty = check_expr(tc, cond, Ty::TyBool {}, true);
            expect_type(tc, Ty::TyBool {}, cond_ty, "if condition must be Bool");
            let then_ty: Ty = check_block(tc, then_branch, expected, has_expected);
            match else_branch {
                Option::Some { value: eb } => {
                    let else_ty: Ty = check_block(tc, eb, expected, has_expected);
                    expect_type(tc, then_ty, else_ty, "if branch type mismatch");
                    then_ty
                },
                Option::None {} => { Ty::TyUnit {} }
            }
        },
        Expr::WhileExpr { cond, body, span } => {
            let cond_ty: Ty = check_expr(tc, cond, Ty::TyBool {}, true);
            expect_type(tc, Ty::TyBool {}, cond_ty, "while condition must be Bool");
            tc.loop_depth = tc.loop_depth + 1;
            check_block(tc, body, Ty::TyUnit {}, false);
            tc.loop_depth = tc.loop_depth - 1;
            Ty::TyUnit {}
        },
        Expr::MatchExpr { scrutinee, arms, span } => {
            let scrutinee_ty: Ty = check_expr(tc, scrutinee, Ty::TyUnit {}, false);
            let num_arms: I64 = vec_len(arms);
            let mut result_ty: Ty = Ty::TyUnit {};
            let mut has_result: Bool = false;
            let mut ai: I64 = 0;
            while ai < num_arms {
                let arm: MatchArm = vec_get_arm(arms, ai);
                tc_locals_push(tc);
                bind_pattern(tc, arm.pattern, scrutinee_ty);
                let arm_ty: Ty = check_expr(tc, arm.body, expected, has_expected);
                tc_locals_pop(tc);
                if has_result {
                    expect_type(tc, result_ty, arm_ty, "match arm type mismatch");
                } else {
                    result_ty = arm_ty;
                    has_result = true;
                };
                ai = ai + 1;
            };
            result_ty
        },
        Expr::AssignExpr { target, value, span } => {
            let target_ty: Ty = check_expr(tc, target, Ty::TyUnit {}, false);
            let value_ty: Ty = check_expr(tc, value, target_ty, true);
            expect_type(tc, target_ty, value_ty, "assignment type mismatch");
            Ty::TyUnit {}
        },
        Expr::BinaryExpr { op, left, right, span } => {
            let left_ty: Ty = check_expr(tc, left, Ty::TyUnit {}, false);
            let right_ty: Ty = check_expr(tc, right, left_ty, true);
            expect_type(tc, left_ty, right_ty, "binary operand type mismatch");
            match op {
                BinaryOp::Add {} => { check_numeric(tc, left_ty, "arithmetic operands must be numeric"); left_ty },
                BinaryOp::Sub {} => { check_numeric(tc, left_ty, "arithmetic operands must be numeric"); left_ty },
                BinaryOp::Mul {} => { check_numeric(tc, left_ty, "arithmetic operands must be numeric"); left_ty },
                BinaryOp::Div {} => { check_numeric(tc, left_ty, "arithmetic operands must be numeric"); left_ty },
                BinaryOp::Rem {} => {
                    if is_int_ty(left_ty) == false {
                        tc_error(tc, "remainder operands must be integer");
                    };
                    left_ty
                },
                BinaryOp::Eq {} => { Ty::TyBool {} },
                BinaryOp::NotEq {} => { Ty::TyBool {} },
                BinaryOp::Lt {} => { Ty::TyBool {} },
                BinaryOp::LtEq {} => { Ty::TyBool {} },
                BinaryOp::Gt {} => { Ty::TyBool {} },
                BinaryOp::GtEq {} => { Ty::TyBool {} },
                BinaryOp::AndAnd {} => {
                    expect_type(tc, Ty::TyBool {}, left_ty, "logical operands must be Bool");
                    Ty::TyBool {}
                },
                BinaryOp::OrOr {} => {
                    expect_type(tc, Ty::TyBool {}, left_ty, "logical operands must be Bool");
                    Ty::TyBool {}
                }
            }
        },
        Expr::UnaryExpr { op, operand, span } => {
            let ty: Ty = check_expr(tc, operand, Ty::TyUnit {}, false);
            match op {
                UnaryOp::Neg {} => {
                    check_numeric(tc, ty, "negation requires numeric operand");
                    ty
                },
                UnaryOp::Not {} => {
                    expect_type(tc, Ty::TyBool {}, ty, "not requires Bool operand");
                    Ty::TyBool {}
                }
            }
        },
        Expr::CallExpr { callee, args, span } => {
            check_call(tc, callee, args, span)
        },
        Expr::FieldExpr { base, name, span } => {
            check_field_access(tc, base, name, span)
        },
        Expr::PathExpr { path, span } => {
            if vec_len(path) >= 1 {
                let last: String = vec_get_str(path, vec_len(path) - 1);
                if tc_locals_has(tc, last) {
                    return tc_locals_get(tc, last);
                };
                let key: String = path_to_string(path);
                if env_has_fn(tc.env, key) {
                    tc_error(tc, "function used as value");
                    return Ty::TyUnit {};
                };
                if env_has_extern_fn(tc.env, key) {
                    tc_error(tc, "function used as value");
                    return Ty::TyUnit {};
                };
            };
            tc_error(tc, "unknown value");
            Ty::TyUnit {}
        },
        Expr::StructLitExpr { path, fields, span } => {
            check_struct_lit(tc, path, fields, expected, has_expected)
        },
        Expr::TupleExpr { items, span } => {
            check_tuple(tc, items, expected, has_expected)
        },
        Expr::LitExpr { lit, span } => {
            check_literal(tc, lit, expected, has_expected)
        },
        Expr::BlockExpr { block } => {
            check_block(tc, block, expected, has_expected)
        },
        Expr::BreakExpr { span } => {
            if tc.loop_depth == 0 {
                tc_error(tc, "break outside of loop");
            };
            Ty::TyUnit {}
        },
        Expr::ContinueExpr { span } => {
            if tc.loop_depth == 0 {
                tc_error(tc, "continue outside of loop");
            };
            Ty::TyUnit {}
        }
    }
}

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

fn check_numeric(tc: TypeChecker, ty: Ty, msg: String) -> I64 {
    if is_numeric_ty(ty) == false {
        tc_error(tc, msg);
    };
    0
}

fn check_call(tc: TypeChecker, callee: Expr, args: Vec, span: Span) -> Ty {
    match callee {
        Expr::PathExpr { path, span: cspan } => {
            let resolved: Vec = resolve_callable(tc, path);
            if vec_len(resolved) == 0 {
                tc_error(tc, string_concat("unknown function '", string_concat(path_to_string(path), "'")));
                return Ty::TyUnit {};
            };
            // resolved: [ret_ty, varargs_flag_as_ty, param0, param1, ...]
            let ret: Ty = vec_get_ty(resolved, 0);
            let varargs_marker: Ty = vec_get_ty(resolved, 1);
            let is_varargs: Bool = match varargs_marker { Ty::TyBool {} => { true }, _ => { false } };
            let params: Vec = vec_new();
            let mut pi: I64 = 2;
            while pi < vec_len(resolved) {
                let pt: Ty = vec_get_ty(resolved, pi);
                vec_push_ty(params, pt);
                pi = pi + 1;
            };
            check_call_args(tc, args, params, is_varargs, cspan);
            ret
        },
        _ => {
            tc_error(tc, "call target must be a path");
            Ty::TyUnit {}
        }
    }
}

fn resolve_callable(tc: TypeChecker, path: Vec) -> Vec {
    let key: String = path_to_string(path);
    if env_has_fn(tc.env, key) {
        let sig: FnMapEntry = env_get_fn(tc.env, key);
        return callable_found(sig.ret, sig.params, sig.varargs);
    };
    if env_has_extern_fn(tc.env, key) {
        let sig: FnMapEntry = env_get_extern_fn(tc.env, key);
        return callable_found(sig.ret, sig.params, sig.varargs);
    };
    // Check for enum tuple variant constructor
    if vec_len(path) >= 2 {
        let en: String = enum_path_str(path);
        let vn: String = variant_name_from_path(path);
        if env_has_enum(tc.env, en) {
            let info: EnumMapEntry = env_get_enum(tc.env, en);
            if variant_has(info.variants, vn) {
                let ventry: VariantDefEntry = variant_get(info.variants, vn);
                match ventry.def {
                    VariantDef::VTuple { types } => {
                        let ret: Ty = Ty::TyEnum { name: en, type_args: vec_new() };
                        return callable_found(ret, types, false);
                    },
                    _ => {}
                };
            };
        };
    };
    vec_new()
}

fn callable_found(ret: Ty, params: Vec, varargs: Bool) -> Vec {
    let result: Vec = vec_new();
    vec_push_ty(result, ret);
    if varargs { vec_push_ty(result, Ty::TyBool {}); }
    else { vec_push_ty(result, Ty::TyUnit {}); };
    let len: I64 = vec_len(params);
    let mut i: I64 = 0;
    while i < len {
        let p: Ty = vec_get_ty(params, i);
        vec_push_ty(result, p);
        i = i + 1;
    };
    result
}

fn check_call_args(tc: TypeChecker, args: Vec, params: Vec, varargs: Bool, span: Span) -> I64 {
    let num_args: I64 = vec_len(args);
    let num_params: I64 = vec_len(params);
    if varargs == false {
        if num_args != num_params {
            tc_error(tc, string_concat("argument count mismatch: expected ", string_concat(string_from_i64(num_params), string_concat(", got ", string_from_i64(num_args)))));
            return 0;
        };
    };
    let mut i: I64 = 0;
    while i < num_params {
        if i < num_args {
            let param_ty: Ty = vec_get_ty(params, i);
            let arg_ty: Ty = check_expr(tc, vec_get_expr(args, i), param_ty, true);
            expect_type(tc, param_ty, arg_ty, "argument type mismatch");
        };
        i = i + 1;
    };
    if varargs {
        let mut j: I64 = num_params;
        while j < num_args {
            check_expr(tc, vec_get_expr(args, j), Ty::TyUnit {}, false);
            j = j + 1;
        };
    };
    0
}

fn check_field_access(tc: TypeChecker, base: Expr, name: String, span: Span) -> Ty {
    let base_ty: Ty = check_expr(tc, base, Ty::TyUnit {}, false);
    match base_ty {
        Ty::TyStruct { name: sname, type_args } => {
            if env_has_struct(tc.env, sname) {
                let info: StructMapEntry = env_get_struct(tc.env, sname);
                let subst: Vec = build_subst_map(info.type_params, type_args);
                let num_fields: I64 = vec_len(info.fields);
                let mut i: I64 = 0;
                while i < num_fields {
                    let f: TypeField = vec_get_tfield(info.fields, i);
                    if string_eq(f.name, name) == 1 {
                        return substitute(f.ty, subst);
                    };
                    i = i + 1;
                };
                tc_error(tc, string_concat("unknown field '", string_concat(name, "'")));
                return Ty::TyUnit {};
            };
            tc_error(tc, "unknown struct");
            Ty::TyUnit {}
        },
        Ty::TyTuple { items } => {
            let idx: I64 = string_parse_i64(name);
            if idx >= 0 {
                if idx < vec_len(items) {
                    let t: Ty = vec_get_ty(items, idx);
                    return t;
                };
            };
            tc_error(tc, string_concat("unknown tuple field '", string_concat(name, "'")));
            Ty::TyUnit {}
        },
        _ => {
            tc_error(tc, "field access requires struct or tuple");
            Ty::TyUnit {}
        }
    }
}

fn check_struct_lit(tc: TypeChecker, path: Vec, fields: Vec, expected: Ty, has_expected: Bool) -> Ty {
    // Check if this is an enum variant struct literal
    if vec_len(path) >= 2 {
        let en: String = enum_path_str(path);
        let vn: String = variant_name_from_path(path);
        if env_has_enum(tc.env, en) {
            let info: EnumMapEntry = env_get_enum(tc.env, en);
            if variant_has(info.variants, vn) {
                let ventry: VariantDefEntry = variant_get(info.variants, vn);
                match ventry.def {
                    VariantDef::VStruct { fields: vfields } => {
                        let type_args: Vec = match expected {
                            Ty::TyEnum { name: ename, type_args: ea } => {
                                if string_eq(ename, en) == 1 { ea } else { vec_new() }
                            },
                            _ => { vec_new() }
                        };
                        let subst: Vec = build_subst_map(info.type_params, type_args);
                        check_struct_fields(tc, fields, vfields, subst);
                        return Ty::TyEnum { name: en, type_args: type_args };
                    },
                    _ => {}
                };
            };
        };
    };

    // Regular struct literal
    let sname: String = path_to_string(path);
    if env_has_struct(tc.env, sname) {
        let info: StructMapEntry = env_get_struct(tc.env, sname);
        let type_args: Vec = match expected {
            Ty::TyStruct { name: ename, type_args: ea } => {
                if string_eq(ename, sname) == 1 { ea } else { vec_new() }
            },
            _ => { vec_new() }
        };
        let subst: Vec = build_subst_map(info.type_params, type_args);
        check_struct_fields(tc, fields, info.fields, subst);
        return Ty::TyStruct { name: sname, type_args: type_args };
    };
    tc_error(tc, string_concat("unknown struct '", string_concat(sname, "'")));
    Ty::TyUnit {}
}

fn check_struct_fields(tc: TypeChecker, lit_fields: Vec, def_fields: Vec, subst: Vec) -> I64 {
    let num_def: I64 = vec_len(def_fields);
    let mut di: I64 = 0;
    while di < num_def {
        let df: TypeField = vec_get_tfield(def_fields, di);
        let concrete_ty: Ty = substitute(df.ty, subst);
        let mut found: Bool = false;
        let num_lit: I64 = vec_len(lit_fields);
        let mut li: I64 = 0;
        while li < num_lit {
            let lf: StructLitField = vec_get_slfield(lit_fields, li);
            if string_eq(lf.name, df.name) == 1 {
                let lit_ty: Ty = check_expr(tc, lf.value, concrete_ty, true);
                expect_type(tc, concrete_ty, lit_ty, string_concat("field '", string_concat(df.name, "' type mismatch")));
                found = true;
            };
            li = li + 1;
        };
        if found == false {
            tc_error(tc, string_concat("missing field '", string_concat(df.name, "'")));
        };
        di = di + 1;
    };
    0
}

fn check_tuple(tc: TypeChecker, items: Vec, expected: Ty, has_expected: Bool) -> Ty {
    let num_items: I64 = vec_len(items);
    let result: Vec = vec_new();
    let mut i: I64 = 0;
    while i < num_items {
        let exp_item: Ty = Ty::TyUnit {};
        let mut has_exp_item: Bool = false;
        if has_expected {
            match expected {
                Ty::TyTuple { items: exp_items } => {
                    if i < vec_len(exp_items) {
                        // Can't reassign exp_item, so inline
                        let ety: Ty = vec_get_ty(exp_items, i);
                        let ity: Ty = check_expr(tc, vec_get_expr(items, i), ety, true);
                        vec_push_ty(result, ity);
                        has_exp_item = true;
                    };
                },
                _ => {}
            };
        };
        if has_exp_item == false {
            let ity: Ty = check_expr(tc, vec_get_expr(items, i), Ty::TyUnit {}, false);
            vec_push_ty(result, ity);
        };
        i = i + 1;
    };
    Ty::TyTuple { items: result }
}

fn check_literal(tc: TypeChecker, lit: Literal, expected: Ty, has_expected: Bool) -> Ty {
    match lit {
        Literal::IntLiteral { text } => { number_literal(tc, expected, has_expected, true) },
        Literal::CharLiteral { value } => { number_literal(tc, expected, has_expected, true) },
        Literal::FloatLiteral { text } => { number_literal(tc, expected, has_expected, false) },
        Literal::StrLiteral { text } => {
            if has_expected {
                if ty_eq(expected, Ty::TyString {}) == false {
                    tc_error(tc, "string literal type mismatch");
                };
            };
            Ty::TyString {}
        },
        Literal::BoolLiteral { value } => { Ty::TyBool {} },
        Literal::UnitLiteral {} => { Ty::TyUnit {} }
    }
}

fn number_literal(tc: TypeChecker, expected: Ty, has_expected: Bool, is_integer: Bool) -> Ty {
    if has_expected {
        if is_integer {
            if is_int_ty(expected) { return expected; };
        } else {
            if is_float_ty(expected) { return expected; };
        };
        tc_error(tc, "numeric literal type mismatch");
        return expected;
    };
    if is_integer { Ty::TyI64 {} }
    else { Ty::TyF64 {} }
}

// ---------------------------------------------------------------------------
// Pattern binding
// ---------------------------------------------------------------------------

fn bind_pattern(tc: TypeChecker, pat: Pattern, scrutinee: Ty) -> I64 {
    match pat {
        Pattern::WildcardPat { span } => {},
        Pattern::PathPat { path, span } => {
            if vec_len(path) >= 2 {
                let en: String = enum_path_str(path);
                let vn: String = variant_name_from_path(path);
                match scrutinee {
                    Ty::TyEnum { name, type_args } => {
                        if string_eq(en, name) == 0 {
                            tc_error(tc, "pattern enum mismatch");
                        };
                    },
                    _ => {
                        tc_error(tc, "match pattern requires enum scrutinee");
                    }
                };
                if env_has_enum(tc.env, en) {
                    let info: EnumMapEntry = env_get_enum(tc.env, en);
                    if variant_has(info.variants, vn) == false {
                        tc_error(tc, "unknown enum variant");
                    };
                };
            };
        },
        Pattern::StructPat { path, fields, span } => {
            if vec_len(path) < 2 {
                tc_error(tc, "struct pattern requires enum variant");
                return 0;
            };
            let en: String = enum_path_str(path);
            let vn: String = variant_name_from_path(path);
            let scrutinee_type_args: Vec = match scrutinee {
                Ty::TyEnum { name, type_args } => {
                    if string_eq(en, name) == 0 {
                        tc_error(tc, "pattern enum mismatch");
                    };
                    type_args
                },
                _ => {
                    tc_error(tc, "match pattern requires enum scrutinee");
                    vec_new()
                }
            };
            if env_has_enum(tc.env, en) == false { return 0; };
            let info: EnumMapEntry = env_get_enum(tc.env, en);
            let subst: Vec = build_subst_map(info.type_params, scrutinee_type_args);
            if variant_has(info.variants, vn) == false {
                tc_error(tc, "unknown enum variant");
                return 0;
            };
            let ventry: VariantDefEntry = variant_get(info.variants, vn);
            match ventry.def {
                VariantDef::VStruct { fields: def_fields } => {
                    let num_pf: I64 = vec_len(fields);
                    let mut fi: I64 = 0;
                    while fi < num_pf {
                        let pf: PatternField = vec_get_pfield(fields, fi);
                        // Find this field in the variant definition
                        let num_df: I64 = vec_len(def_fields);
                        let mut found: Bool = false;
                        let mut di: I64 = 0;
                        while di < num_df {
                            let df: TypeField = vec_get_tfield(def_fields, di);
                            if string_eq(df.name, pf.name) == 1 {
                                let field_ty: Ty = substitute(df.ty, subst);
                                match pf.binding {
                                    Option::Some { value: binding } => {
                                        tc_locals_insert(tc, binding, field_ty);
                                    },
                                    Option::None {} => {}
                                };
                                found = true;
                            };
                            di = di + 1;
                        };
                        if found == false {
                            tc_error(tc, string_concat("unknown field '", string_concat(pf.name, "'")));
                        };
                        fi = fi + 1;
                    };
                },
                _ => {
                    tc_error(tc, "pattern requires struct variant");
                }
            };
        }
    };
    0
}

// ---------------------------------------------------------------------------
// Entry point
// ---------------------------------------------------------------------------

fn build_module_extern_fns(m: Module, env: TypeEnv) -> Vec {
    // Start from global extern fns so cross-module extern fn calls are resolvable
    let extern_fns: Vec = vec_new();
    let num_global: I64 = vec_len(env.extern_fns);
    let mut gi: I64 = 0;
    while gi < num_global {
        let ge: FnMapEntry = vec_get_fnentry(env.extern_fns, gi);
        vec_push_fnentry(extern_fns, ge);
        gi = gi + 1;
    };
    let mod_path: Vec = m.path;
    let num_items: I64 = vec_len(m.items);
    let mut ii: I64 = 0;
    while ii < num_items {
        let item: Item = vec_get_item(m.items, ii);
        match item {
            Item::ExternFnItem { decl } => {
                let empty_tp: Vec = vec_new();
                let params: Vec = vec_new();
                let num_params: I64 = vec_len(decl.params);
                let mut pi: I64 = 0;
                while pi < num_params {
                    let p: Param = vec_get_param(decl.params, pi);
                    vec_push_ty(params, lower_type(p.ty, env.struct_names, env.enum_names, empty_tp));
                    pi = pi + 1;
                };
                let ret: Ty = lower_type(decl.ret_type, env.struct_names, env.enum_names, empty_tp);
                let efname: String = full_item_name(mod_path, decl.name);
                vec_push_fnentry(extern_fns, FnMapEntry { name: efname, params: params, ret: ret, varargs: decl.varargs });
            },
            _ => {}
        };
        ii = ii + 1;
    };
    extern_fns
}

fn typecheck_modules(modules: Vec) -> I64 {
    let env: TypeEnv = build_env(modules);
    let errors: Vec = vec_new();

    let num_modules: I64 = vec_len(modules);
    let mut mi: I64 = 0;
    while mi < num_modules {
        let m: Module = vec_get_module(modules, mi);
        let mod_path: Vec = m.path;
        // Build per-module extern fn map so each module sees its own declarations
        let mod_extern_fns: Vec = build_module_extern_fns(m, env);
        let mod_env: TypeEnv = TypeEnv {
            structs: env.structs, enums: env.enums, fns: env.fns,
            extern_fns: mod_extern_fns,
            struct_names: env.struct_names, enum_names: env.enum_names
        };
        let num_items: I64 = vec_len(m.items);
        let mut ii: I64 = 0;
        while ii < num_items {
            let item: Item = vec_get_item(m.items, ii);
            match item {
                Item::FnItem { decl } => {
                    let fname: String = full_item_name(mod_path, decl.name);
                    if env_has_fn(mod_env, fname) {
                        let sig: FnMapEntry = env_get_fn(mod_env, fname);
                        let locals: Vec = vec_new();
                        vec_push(locals, vec_new());
                        let tc: TypeChecker = TypeChecker {
                            env: mod_env, locals: locals,
                            return_type: sig.ret, errors: errors,
                            loop_depth: 0
                        };
                        // Insert params
                        let num_params: I64 = vec_len(decl.params);
                        let mut pi: I64 = 0;
                        while pi < num_params {
                            let p: Param = vec_get_param(decl.params, pi);
                            let param_ty: Ty = vec_get_ty(sig.params, pi);
                            tc_locals_insert(tc, p.name, param_ty);
                            pi = pi + 1;
                        };
                        check_block(tc, decl.body, sig.ret, true);
                    };
                },
                _ => {}
            };
            ii = ii + 1;
        };
        mi = mi + 1;
    };

    let num_errors: I64 = vec_len(errors);
    if num_errors > 0 {
        let mut ei: I64 = 0;
        while ei < num_errors {
            print_str_stderr(string_concat("type error: ", vec_get_str(errors, ei)));
            ei = ei + 1;
        };
        exit_process(1);
    };
    0
}
