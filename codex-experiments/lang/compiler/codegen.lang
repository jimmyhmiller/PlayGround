// ---------------------------------------------------------------------------
// Codegen pass — emit LLVM IR and compile to object file
// ---------------------------------------------------------------------------

use ast::Option;
use ast::Span;
use ast::Module;
use ast::Item;
use ast::FnDecl;
use ast::ExternFnDecl;
use ast::StructDecl;
use ast::EnumDecl;
use ast::EnumVariant;
use ast::EnumVariantKind;
use ast::Field;
use ast::Param;
use ast::Block;
use ast::Stmt;
use ast::Expr;
use ast::Literal;
use ast::BinaryOp;
use ast::UnaryOp;
use ast::Type;
use ast::Pattern;
use ast::MatchArm;
use ast::PatternField;
use ast::StructLitField;
use ast::CgFieldLayout;
use ast::CgStructLayout;
use ast::CgVariantFieldLayout;
use ast::CgVariantLayout;
use ast::CgEnumLayout;
use ast::CgLocal;
use ast::CgFnEntry;
use ast::LoopEntry;

// -- vec ops ---------------------------------------------------------------
use vec::vec_new;
use vec::vec_len;
use vec::vec_push;
use vec::vec_get;
use vec::vec_set_len;
use vec::vec_data;
use vec::vec_push_str;
use vec::vec_get_str;
use vec::vec_push_vec;
use vec::vec_get_vec;
use vec::vec_get_module;
use vec::vec_get_item;
use vec::vec_get_field;
use vec::vec_get_param;
use vec::vec_get_variant;
use vec::vec_get_type;
use vec::vec_get_expr;
use vec::vec_get_arm;
use vec::vec_get_stmt;
use vec::vec_get_pfield;
use vec::vec_get_slfield;
use vec::ptr_is_null;
use vec::Vec;
use vec::vec_push_raw;

// codegen-specific vec aliases
fn vec_push_cgfn(v: Vec, item: CgFnEntry) -> I64 { vec_push(v, item) }
fn vec_get_cgfn(v: Vec, index: I64) -> CgFnEntry { vec_get(v, index) }
fn vec_push_cgsl(v: Vec, item: CgStructLayout) -> I64 { vec_push(v, item) }
fn vec_get_cgsl(v: Vec, index: I64) -> CgStructLayout { vec_get(v, index) }
fn vec_push_cgel(v: Vec, item: CgEnumLayout) -> I64 { vec_push(v, item) }
fn vec_get_cgel(v: Vec, index: I64) -> CgEnumLayout { vec_get(v, index) }
fn vec_push_cgfl(v: Vec, item: CgFieldLayout) -> I64 { vec_push(v, item) }
fn vec_get_cgfl(v: Vec, index: I64) -> CgFieldLayout { vec_get(v, index) }
fn vec_push_cgvfl(v: Vec, item: CgVariantFieldLayout) -> I64 { vec_push(v, item) }
fn vec_get_cgvfl(v: Vec, index: I64) -> CgVariantFieldLayout { vec_get(v, index) }
fn vec_push_cgvl(v: Vec, item: CgVariantLayout) -> I64 { vec_push(v, item) }
fn vec_get_cgvl(v: Vec, index: I64) -> CgVariantLayout { vec_get(v, index) }
fn vec_push_cgloc(v: Vec, item: CgLocal) -> I64 { vec_push(v, item) }
fn vec_get_cgloc(v: Vec, index: I64) -> CgLocal { vec_get(v, index) }
fn vec_push_loop(v: Vec, item: LoopEntry) -> I64 { vec_push(v, item) }
fn vec_get_loop(v: Vec, index: I64) -> LoopEntry { vec_get(v, index) }

// -- string + io ops (from stdlib) -----------------------------------------
use string::string_eq;
use string::string_concat;
use string::string_from_i64;
use string::string_parse_i64;
use string::string_len;
use string::string_byte_at;
use string::string_slice;
use io::print_str;
use io::print_str_stderr;
use io::exit_process;
use io::write_file;
use io::system_cmd;

// -- LLVM C API (direct calls — no shim needed) ----------------------------
extern fn LLVMContextCreate() -> RawPointer<I8>;
extern fn LLVMModuleCreateWithNameInContext(name: String, ctx: RawPointer<I8>) -> RawPointer<I8>;
extern fn LLVMCreateBuilderInContext(ctx: RawPointer<I8>) -> RawPointer<I8>;
extern fn LLVMInt1TypeInContext(ctx: RawPointer<I8>) -> RawPointer<I8>;
extern fn LLVMInt8TypeInContext(ctx: RawPointer<I8>) -> RawPointer<I8>;
extern fn LLVMInt16TypeInContext(ctx: RawPointer<I8>) -> RawPointer<I8>;
extern fn LLVMInt32TypeInContext(ctx: RawPointer<I8>) -> RawPointer<I8>;
extern fn LLVMInt64TypeInContext(ctx: RawPointer<I8>) -> RawPointer<I8>;
extern fn LLVMFloatTypeInContext(ctx: RawPointer<I8>) -> RawPointer<I8>;
extern fn LLVMDoubleTypeInContext(ctx: RawPointer<I8>) -> RawPointer<I8>;
extern fn LLVMVoidTypeInContext(ctx: RawPointer<I8>) -> RawPointer<I8>;
extern fn LLVMConstNull(ty: RawPointer<I8>) -> RawPointer<I8>;
extern fn LLVMAddFunction(m: RawPointer<I8>, name: String, fn_ty: RawPointer<I8>) -> RawPointer<I8>;
extern fn LLVMGetNamedFunction(m: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn LLVMAddGlobal(m: RawPointer<I8>, ty: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn LLVMTypeOf(val: RawPointer<I8>) -> RawPointer<I8>;
extern fn LLVMGlobalGetValueType(val: RawPointer<I8>) -> RawPointer<I8>;
extern fn LLVMGetElementType(ty: RawPointer<I8>) -> RawPointer<I8>;
extern fn LLVMAppendBasicBlockInContext(ctx: RawPointer<I8>, f: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn LLVMGetFirstBasicBlock(f: RawPointer<I8>) -> RawPointer<I8>;
extern fn LLVMGetBasicBlockTerminator(bb: RawPointer<I8>) -> RawPointer<I8>;
extern fn LLVMGetInsertBlock(builder: RawPointer<I8>) -> RawPointer<I8>;
extern fn LLVMGetFirstInstruction(bb: RawPointer<I8>) -> RawPointer<I8>;
extern fn LLVMBuildAlloca(builder: RawPointer<I8>, ty: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn LLVMBuildLoad2(builder: RawPointer<I8>, ty: RawPointer<I8>, ptr: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn LLVMBuildStore(builder: RawPointer<I8>, val: RawPointer<I8>, ptr: RawPointer<I8>) -> RawPointer<I8>;
extern fn LLVMBuildRet(builder: RawPointer<I8>, val: RawPointer<I8>) -> RawPointer<I8>;
extern fn LLVMBuildRetVoid(builder: RawPointer<I8>) -> RawPointer<I8>;
extern fn LLVMBuildBr(builder: RawPointer<I8>, dest: RawPointer<I8>) -> RawPointer<I8>;
extern fn LLVMBuildCondBr(builder: RawPointer<I8>, cond: RawPointer<I8>, then_bb: RawPointer<I8>, else_bb: RawPointer<I8>) -> RawPointer<I8>;
extern fn LLVMBuildPhi(builder: RawPointer<I8>, ty: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn LLVMBuildBitCast(builder: RawPointer<I8>, val: RawPointer<I8>, dest_ty: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn LLVMBuildGlobalStringPtr(builder: RawPointer<I8>, str: String, name: String) -> RawPointer<I8>;
extern fn LLVMBuildAdd(builder: RawPointer<I8>, l: RawPointer<I8>, r: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn LLVMBuildSub(builder: RawPointer<I8>, l: RawPointer<I8>, r: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn LLVMBuildMul(builder: RawPointer<I8>, l: RawPointer<I8>, r: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn LLVMBuildSDiv(builder: RawPointer<I8>, l: RawPointer<I8>, r: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn LLVMBuildSRem(builder: RawPointer<I8>, l: RawPointer<I8>, r: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn LLVMBuildAnd(builder: RawPointer<I8>, l: RawPointer<I8>, r: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn LLVMBuildOr(builder: RawPointer<I8>, l: RawPointer<I8>, r: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn LLVMBuildXor(builder: RawPointer<I8>, l: RawPointer<I8>, r: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn LLVMBuildZExt(builder: RawPointer<I8>, val: RawPointer<I8>, dest_ty: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn LLVMBuildTrunc(builder: RawPointer<I8>, val: RawPointer<I8>, dest_ty: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn LLVMBuildFAdd(builder: RawPointer<I8>, l: RawPointer<I8>, r: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn LLVMBuildFSub(builder: RawPointer<I8>, l: RawPointer<I8>, r: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn LLVMBuildFMul(builder: RawPointer<I8>, l: RawPointer<I8>, r: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn LLVMBuildFDiv(builder: RawPointer<I8>, l: RawPointer<I8>, r: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn LLVMBuildFRem(builder: RawPointer<I8>, l: RawPointer<I8>, r: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn LLVMBuildFNeg(builder: RawPointer<I8>, val: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn LLVMGetDefaultTargetTriple() -> String;
extern fn LLVMGetHostCPUName() -> String;
extern fn LLVMGetHostCPUFeatures() -> String;

// -- LLVM C API (shims in runtime/llvm_shims.c for type conversion) --------
extern fn lang_llvm_dispose_builder(b: RawPointer<I8>) -> I64;
extern fn lang_llvm_dispose_module(m: RawPointer<I8>) -> I64;
extern fn lang_llvm_context_dispose(ctx: RawPointer<I8>) -> I64;
extern fn lang_llvm_ptr_type(ctx: RawPointer<I8>) -> RawPointer<I8>;
extern fn lang_llvm_function_type(ret: RawPointer<I8>, params: RawPointer<I8>, param_count: I64, is_vararg: I64) -> RawPointer<I8>;
extern fn lang_llvm_struct_type(ctx: RawPointer<I8>, elements: RawPointer<I8>, count: I64, packed: I64) -> RawPointer<I8>;
extern fn lang_llvm_array_type(elem_ty: RawPointer<I8>, count: I64) -> RawPointer<I8>;
extern fn lang_llvm_const_int(ty: RawPointer<I8>, val: I64, sign_extend: I64) -> RawPointer<I8>;
extern fn lang_llvm_const_string(ctx: RawPointer<I8>, str: String, len: I64, null_terminate: I64) -> RawPointer<I8>;
extern fn lang_llvm_const_named_struct(struct_ty: RawPointer<I8>, vals: RawPointer<I8>, count: I64) -> RawPointer<I8>;
extern fn lang_llvm_const_array(elem_ty: RawPointer<I8>, vals: RawPointer<I8>, count: I64) -> RawPointer<I8>;
extern fn lang_llvm_const_gep2(ty: RawPointer<I8>, val: RawPointer<I8>, indices: RawPointer<I8>, count: I64) -> RawPointer<I8>;
extern fn lang_llvm_set_initializer(global: RawPointer<I8>, val: RawPointer<I8>) -> I64;
extern fn lang_llvm_get_type_kind(ty: RawPointer<I8>) -> I64;
extern fn lang_llvm_pointer_type(ty: RawPointer<I8>) -> RawPointer<I8>;
extern fn lang_llvm_get_param(f: RawPointer<I8>, index: I64) -> RawPointer<I8>;
extern fn lang_llvm_count_params(f: RawPointer<I8>) -> I64;
extern fn lang_llvm_position_at_end(builder: RawPointer<I8>, bb: RawPointer<I8>) -> I64;
extern fn lang_llvm_position_before(builder: RawPointer<I8>, instr: RawPointer<I8>) -> I64;
extern fn lang_llvm_build_call(builder: RawPointer<I8>, fn_ty: RawPointer<I8>, f: RawPointer<I8>, args: RawPointer<I8>, arg_count: I64, name: String) -> RawPointer<I8>;
extern fn lang_llvm_build_switch(builder: RawPointer<I8>, val: RawPointer<I8>, default_bb: RawPointer<I8>, num_cases: I64) -> RawPointer<I8>;
extern fn lang_llvm_build_gep2(builder: RawPointer<I8>, ty: RawPointer<I8>, ptr: RawPointer<I8>, indices: RawPointer<I8>, count: I64, name: String) -> RawPointer<I8>;
extern fn lang_llvm_build_inbounds_gep2(builder: RawPointer<I8>, ty: RawPointer<I8>, ptr: RawPointer<I8>, indices: RawPointer<I8>, count: I64, name: String) -> RawPointer<I8>;
extern fn lang_llvm_build_struct_gep2(builder: RawPointer<I8>, struct_ty: RawPointer<I8>, ptr: RawPointer<I8>, idx: I64, name: String) -> RawPointer<I8>;
extern fn lang_llvm_build_icmp(builder: RawPointer<I8>, predicate: I64, l: RawPointer<I8>, r: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn lang_llvm_build_fcmp(builder: RawPointer<I8>, predicate: I64, l: RawPointer<I8>, r: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn lang_llvm_build_memset(builder: RawPointer<I8>, ptr: RawPointer<I8>, val: RawPointer<I8>, len: RawPointer<I8>, align: I64) -> RawPointer<I8>;
extern fn lang_llvm_add_incoming(phi: RawPointer<I8>, vals: RawPointer<I8>, blocks: RawPointer<I8>, count: I64) -> I64;
extern fn lang_llvm_add_case(switch: RawPointer<I8>, val: RawPointer<I8>, dest: RawPointer<I8>) -> I64;
extern fn lang_llvm_set_volatile(instr: RawPointer<I8>, is_volatile: I64) -> I64;
extern fn lang_llvm_init_native_target() -> I64;
extern fn lang_llvm_init_native_asm_printer() -> I64;
extern fn lang_llvm_get_target_from_triple(triple: String) -> RawPointer<I8>;
extern fn lang_llvm_create_target_machine(target: RawPointer<I8>, triple: String, cpu: String, features: String) -> RawPointer<I8>;
extern fn lang_llvm_set_module_target(m: RawPointer<I8>, machine: RawPointer<I8>) -> I64;
extern fn lang_llvm_emit_to_file(machine: RawPointer<I8>, m: RawPointer<I8>, filename: String) -> I64;
extern fn lang_llvm_print_module_to_string(m: RawPointer<I8>) -> String;
extern fn lang_llvm_set_section(global: RawPointer<I8>, section: String) -> I64;
extern fn lang_llvm_set_linkage(global: RawPointer<I8>, linkage: I64) -> I64;
extern fn lang_llvm_set_unnamed_addr(global: RawPointer<I8>, unnamed: I64) -> I64;

// ---------------------------------------------------------------------------
// Constants
// ---------------------------------------------------------------------------

// Type tags for lang_ty_tag field
fn TAG_I64() -> I64 { 0 }
fn TAG_BOOL() -> I64 { 1 }
fn TAG_STRING() -> I64 { 2 }
fn TAG_RAWPTR() -> I64 { 3 }
fn TAG_GCREF() -> I64 { 4 }
fn TAG_F32() -> I64 { 5 }
fn TAG_F64() -> I64 { 6 }
fn TAG_I8() -> I64 { 7 }
fn TAG_I16() -> I64 { 8 }
fn TAG_I32() -> I64 { 9 }
fn TAG_U8() -> I64 { 10 }
fn TAG_U16() -> I64 { 11 }
fn TAG_U32() -> I64 { 12 }
fn TAG_U64() -> I64 { 13 }
fn TAG_UNIT() -> I64 { 14 }
fn TAG_TUPLE() -> I64 { 15 }

// LLVM ICmp predicates
fn ICMP_EQ() -> I64 { 32 }
fn ICMP_NE() -> I64 { 33 }
fn ICMP_SGT() -> I64 { 38 }
fn ICMP_SGE() -> I64 { 39 }
fn ICMP_SLT() -> I64 { 40 }
fn ICMP_SLE() -> I64 { 41 }

// LLVM FCmp predicates
fn FCMP_OEQ() -> I64 { 1 }
fn FCMP_OGT() -> I64 { 2 }
fn FCMP_OGE() -> I64 { 3 }
fn FCMP_OLT() -> I64 { 4 }
fn FCMP_OLE() -> I64 { 5 }
fn FCMP_ONE() -> I64 { 6 }

// LLVM type kinds
fn TK_FLOAT() -> I64 { 2 }
fn TK_DOUBLE() -> I64 { 3 }
fn TK_INTEGER() -> I64 { 8 }
fn TK_POINTER() -> I64 { 12 }

// ---------------------------------------------------------------------------
// Codegen state structs
// ---------------------------------------------------------------------------

struct Codegen {
    context: RawPointer<I8>,
    llmod: RawPointer<I8>,
    builder: RawPointer<I8>,
    thread_struct_ty: RawPointer<I8>,
    functions: Vec,
    externs: Vec,
    gc_pollcheck_fn: RawPointer<I8>,
    gc_pollcheck_ty: RawPointer<I8>,
    gc_alloc_fn: RawPointer<I8>,
    gc_alloc_ty: RawPointer<I8>,
    gc_write_barrier_fn: RawPointer<I8>,
    gc_write_barrier_ty: RawPointer<I8>,
    structs: Vec,
    enums: Vec,
    tuples: Vec,
    str_lit_id: I64,
    next_type_id: I64,
    compiler_used: Vec
}

struct FnCtx {
    function: RawPointer<I8>,
    locals: Vec,
    scopes: Vec,
    thread: RawPointer<I8>,
    frame_ptr: RawPointer<I8>,
    frame_origin: RawPointer<I8>,
    frame_ty: RawPointer<I8>,
    root_base: RawPointer<I8>,
    next_root: I64,
    loop_stack: Vec
}

// ---------------------------------------------------------------------------
// Utility functions
// ---------------------------------------------------------------------------

fn path_to_string(path: Vec) -> String {
    let len: I64 = vec_len(path);
    if len == 0 { return ""; };
    let mut result: String = vec_get_str(path, 0);
    let mut i: I64 = 1;
    while i < len {
        result = string_concat(result, string_concat("::", vec_get_str(path, i)));
        i = i + 1;
    };
    result
}

fn full_item_name(module_path: Vec, name: String) -> String {
    if vec_len(module_path) == 0 {
        return name;
    };
    string_concat(path_to_string(module_path), string_concat("::", name))
}

fn enum_path_and_variant(path: Vec) -> String {
    // Returns the enum path (everything except last segment) as a string
    let len: I64 = vec_len(path);
    if len < 2 {
        return path_to_string(path);
    };
    let enum_parts: Vec = vec_new();
    let mut i: I64 = 0;
    while i < len - 1 {
        vec_push_str(enum_parts, vec_get_str(path, i));
        i = i + 1;
    };
    path_to_string(enum_parts)
}

fn variant_name_from_path(path: Vec) -> String {
    let len: I64 = vec_len(path);
    if len == 0 {
        return "";
    };
    vec_get_str(path, len - 1)
}

fn mangle_name(name: String) -> String {
    // Replace :: with __
    let len: I64 = string_len(name);
    let mut result: String = "";
    let mut i: I64 = 0;
    while i < len {
        let ch: I64 = string_byte_at(name, i);
        if ch == 58 {
            // ':' = 58
            if i + 1 < len {
                let next: I64 = string_byte_at(name, i + 1);
                if next == 58 {
                    result = string_concat(result, "__");
                    i = i + 2;
                    continue;
                };
            };
            result = string_concat(result, string_slice(name, i, i + 1));
            i = i + 1;
        } else {
            result = string_concat(result, string_slice(name, i, i + 1));
            i = i + 1;
        };
    };
    result
}

fn last_segment(full: String) -> String {
    let len: I64 = string_len(full);
    let mut last_sep: I64 = 0 - 1;
    let mut i: I64 = 0;
    while i < len - 1 {
        let ch: I64 = string_byte_at(full, i);
        if ch == 58 {
            let next: I64 = string_byte_at(full, i + 1);
            if next == 58 {
                last_sep = i + 1;
                i = i + 2;
                continue;
            };
        };
        i = i + 1;
    };
    if last_sep < 0 {
        return full;
    };
    string_slice(full, last_sep + 1, len)
}

fn type_key(ty: Type) -> String {
    match ty {
        Type::PathType { path, type_args } => {
            mangle_name(path_to_string(path))
        },
        Type::RawPtrType { inner } => {
            string_concat("ptr_", type_key(inner))
        },
        Type::TupleType { types } => {
            let mut out: String = "tup";
            let mut i: I64 = 0;
            while i < vec_len(types) {
                let t: Type = vec_get_type(types, i);
                out = string_concat(out, string_concat("_", type_key(t)));
                i = i + 1;
            };
            out
        }
    }
}

fn tuple_key(items: Vec) -> String {
    let mut out: String = "__tuple__";
    let mut i: I64 = 0;
    while i < vec_len(items) {
        if i > 0 {
            out = string_concat(out, "_");
        };
        let t: Type = vec_get_type(items, i);
        out = string_concat(out, type_key(t));
        i = i + 1;
    };
    out
}

fn type_name_from_type(ty: Type) -> String {
    match ty {
        Type::PathType { path, type_args } => {
            path_to_string(path)
        },
        Type::RawPtrType { inner } => {
            "RawPointer"
        },
        Type::TupleType { types } => {
            tuple_key(types)
        }
    }
}

fn llvm_fn_name(name: String) -> String {
    if string_eq(name, "main") == 1 {
        return "__lang_main";
    };
    mangle_name(name)
}

// ---------------------------------------------------------------------------
// Type helpers
// ---------------------------------------------------------------------------

fn is_gc_ref_type(ty: Type) -> Bool {
    match ty {
        Type::RawPtrType { inner } => { false },
        Type::TupleType { types } => { true },
        Type::PathType { path, type_args } => {
            let name: String = vec_get_str(path, vec_len(path) - 1);
            if string_eq(name, "I8") == 1 { return false; };
            if string_eq(name, "I16") == 1 { return false; };
            if string_eq(name, "I32") == 1 { return false; };
            if string_eq(name, "I64") == 1 { return false; };
            if string_eq(name, "U8") == 1 { return false; };
            if string_eq(name, "U16") == 1 { return false; };
            if string_eq(name, "U32") == 1 { return false; };
            if string_eq(name, "U64") == 1 { return false; };
            if string_eq(name, "F32") == 1 { return false; };
            if string_eq(name, "F64") == 1 { return false; };
            if string_eq(name, "Bool") == 1 { return false; };
            if string_eq(name, "Unit") == 1 { return false; };
            if string_eq(name, "String") == 1 { return false; };
            true
        }
    }
}

fn is_bool_type(ty: Type) -> Bool {
    match ty {
        Type::PathType { path, type_args } => {
            let name: String = vec_get_str(path, vec_len(path) - 1);
            string_eq(name, "Bool") == 1
        },
        Type::RawPtrType { inner } => { false },
        Type::TupleType { types } => { false }
    }
}

fn tag_is_gc_ref(tag: I64) -> Bool {
    tag == TAG_GCREF() || tag == TAG_TUPLE()
}

fn tag_is_bool(tag: I64) -> Bool {
    tag == TAG_BOOL()
}

fn type_to_tag(ty: Type) -> I64 {
    match ty {
        Type::RawPtrType { inner } => { TAG_RAWPTR() },
        Type::TupleType { types } => { TAG_TUPLE() },
        Type::PathType { path, type_args } => {
            let name: String = vec_get_str(path, vec_len(path) - 1);
            if string_eq(name, "I64") == 1 { return TAG_I64(); };
            if string_eq(name, "Bool") == 1 { return TAG_BOOL(); };
            if string_eq(name, "String") == 1 { return TAG_STRING(); };
            if string_eq(name, "F32") == 1 { return TAG_F32(); };
            if string_eq(name, "F64") == 1 { return TAG_F64(); };
            if string_eq(name, "I8") == 1 { return TAG_I8(); };
            if string_eq(name, "I16") == 1 { return TAG_I16(); };
            if string_eq(name, "I32") == 1 { return TAG_I32(); };
            if string_eq(name, "U8") == 1 { return TAG_U8(); };
            if string_eq(name, "U16") == 1 { return TAG_U16(); };
            if string_eq(name, "U32") == 1 { return TAG_U32(); };
            if string_eq(name, "U64") == 1 { return TAG_U64(); };
            if string_eq(name, "Unit") == 1 { return TAG_UNIT(); };
            TAG_GCREF()
        }
    }
}

fn llvm_type_for_tag(cg: Codegen, tag: I64) -> RawPointer<I8> {
    let ctx: RawPointer<I8> = cg.context;
    if tag == TAG_I64() { return LLVMInt64TypeInContext(ctx); };
    if tag == TAG_BOOL() { return LLVMInt1TypeInContext(ctx); };
    if tag == TAG_STRING() { return lang_llvm_ptr_type(ctx); };
    if tag == TAG_RAWPTR() { return lang_llvm_ptr_type(ctx); };
    if tag == TAG_GCREF() { return lang_llvm_ptr_type(ctx); };
    if tag == TAG_F32() { return LLVMFloatTypeInContext(ctx); };
    if tag == TAG_F64() { return LLVMDoubleTypeInContext(ctx); };
    if tag == TAG_I8() { return LLVMInt8TypeInContext(ctx); };
    if tag == TAG_I16() { return LLVMInt16TypeInContext(ctx); };
    if tag == TAG_I32() { return LLVMInt32TypeInContext(ctx); };
    if tag == TAG_U8() { return LLVMInt8TypeInContext(ctx); };
    if tag == TAG_U16() { return LLVMInt16TypeInContext(ctx); };
    if tag == TAG_U32() { return LLVMInt32TypeInContext(ctx); };
    if tag == TAG_U64() { return LLVMInt64TypeInContext(ctx); };
    if tag == TAG_UNIT() { return LLVMInt64TypeInContext(ctx); };
    if tag == TAG_TUPLE() { return lang_llvm_ptr_type(ctx); };
    LLVMInt64TypeInContext(ctx)
}

fn llvm_type(cg: Codegen, ty: Type) -> RawPointer<I8> {
    let tag: I64 = type_to_tag(ty);
    llvm_type_for_tag(cg, tag)
}

fn field_llvm_type(cg: Codegen, ty: Type) -> RawPointer<I8> {
    // For field storage: Bool -> i8, everything else same
    match ty {
        Type::PathType { path, type_args } => {
            let name: String = vec_get_str(path, vec_len(path) - 1);
            if string_eq(name, "Bool") == 1 { return LLVMInt8TypeInContext(cg.context); };
            if string_eq(name, "I8") == 1 { return LLVMInt8TypeInContext(cg.context); };
            if string_eq(name, "U8") == 1 { return LLVMInt8TypeInContext(cg.context); };
            if string_eq(name, "I16") == 1 { return LLVMInt16TypeInContext(cg.context); };
            if string_eq(name, "U16") == 1 { return LLVMInt16TypeInContext(cg.context); };
            if string_eq(name, "I32") == 1 { return LLVMInt32TypeInContext(cg.context); };
            if string_eq(name, "U32") == 1 { return LLVMInt32TypeInContext(cg.context); };
            if string_eq(name, "I64") == 1 { return LLVMInt64TypeInContext(cg.context); };
            if string_eq(name, "U64") == 1 { return LLVMInt64TypeInContext(cg.context); };
            if string_eq(name, "F32") == 1 { return LLVMFloatTypeInContext(cg.context); };
            if string_eq(name, "F64") == 1 { return LLVMDoubleTypeInContext(cg.context); };
            if string_eq(name, "String") == 1 { return lang_llvm_ptr_type(cg.context); };
            if string_eq(name, "Unit") == 1 { return LLVMInt64TypeInContext(cg.context); };
            // gc ref type
            lang_llvm_ptr_type(cg.context)
        },
        Type::RawPtrType { inner } => { lang_llvm_ptr_type(cg.context) },
        Type::TupleType { types } => { lang_llvm_ptr_type(cg.context) }
    }
}

fn field_align(tag: I64) -> I64 {
    if tag == TAG_BOOL() { return 1; };
    if tag == TAG_I8() { return 1; };
    if tag == TAG_U8() { return 1; };
    if tag == TAG_I16() { return 2; };
    if tag == TAG_U16() { return 2; };
    if tag == TAG_I32() { return 4; };
    if tag == TAG_U32() { return 4; };
    8
}

fn field_size(tag: I64) -> I64 {
    if tag == TAG_BOOL() { return 1; };
    if tag == TAG_I8() { return 1; };
    if tag == TAG_U8() { return 1; };
    if tag == TAG_I16() { return 2; };
    if tag == TAG_U16() { return 2; };
    if tag == TAG_I32() { return 4; };
    if tag == TAG_U32() { return 4; };
    8
}

// ---------------------------------------------------------------------------
// Lookup helpers
// ---------------------------------------------------------------------------

fn cg_get_fn(cg: Codegen, name: String) -> CgFnEntry {
    let mut i: I64 = 0;
    let len: I64 = vec_len(cg.functions);
    while i < len {
        let entry: CgFnEntry = vec_get_cgfn(cg.functions, i);
        if string_eq(entry.name, name) == 1 {
            return entry;
        };
        i = i + 1;
    };
    print_str_stderr(string_concat("codegen error: unknown function: ", name));
    exit_process(1);
    // unreachable
    let dummy: CgFnEntry = vec_get_cgfn(cg.functions, 0);
    dummy
}

fn cg_get_extern(cg: Codegen, name: String) -> CgFnEntry {
    let mut i: I64 = 0;
    let len: I64 = vec_len(cg.externs);
    while i < len {
        let entry: CgFnEntry = vec_get_cgfn(cg.externs, i);
        if string_eq(entry.name, name) == 1 {
            return entry;
        };
        i = i + 1;
    };
    print_str_stderr(string_concat("codegen error: unknown extern: ", name));
    exit_process(1);
    let dummy: CgFnEntry = vec_get_cgfn(cg.externs, 0);
    dummy
}

fn cg_find_fn(cg: Codegen, name: String) -> I64 {
    // Returns 1 if found, 0 if not
    let mut i: I64 = 0;
    let len: I64 = vec_len(cg.functions);
    while i < len {
        let entry: CgFnEntry = vec_get_cgfn(cg.functions, i);
        if string_eq(entry.name, name) == 1 {
            return 1;
        };
        i = i + 1;
    };
    0
}

fn cg_find_extern(cg: Codegen, name: String) -> I64 {
    let mut i: I64 = 0;
    let len: I64 = vec_len(cg.externs);
    while i < len {
        let entry: CgFnEntry = vec_get_cgfn(cg.externs, i);
        if string_eq(entry.name, name) == 1 {
            return 1;
        };
        i = i + 1;
    };
    0
}

fn cg_get_struct(cg: Codegen, name: String) -> CgStructLayout {
    let mut i: I64 = 0;
    let len: I64 = vec_len(cg.structs);
    while i < len {
        let entry: CgStructLayout = vec_get_cgsl(cg.structs, i);
        if string_eq(entry.name, name) == 1 {
            return entry;
        };
        i = i + 1;
    };
    print_str_stderr(string_concat("codegen error: unknown struct: ", name));
    exit_process(1);
    let dummy: CgStructLayout = vec_get_cgsl(cg.structs, 0);
    dummy
}

fn cg_find_struct(cg: Codegen, name: String) -> I64 {
    let mut i: I64 = 0;
    let len: I64 = vec_len(cg.structs);
    while i < len {
        let entry: CgStructLayout = vec_get_cgsl(cg.structs, i);
        if string_eq(entry.name, name) == 1 {
            return 1;
        };
        i = i + 1;
    };
    0
}

fn cg_get_enum(cg: Codegen, name: String) -> CgEnumLayout {
    let mut i: I64 = 0;
    let len: I64 = vec_len(cg.enums);
    while i < len {
        let entry: CgEnumLayout = vec_get_cgel(cg.enums, i);
        if string_eq(entry.name, name) == 1 {
            return entry;
        };
        i = i + 1;
    };
    print_str_stderr(string_concat("codegen error: unknown enum: ", name));
    exit_process(1);
    let dummy: CgEnumLayout = vec_get_cgel(cg.enums, 0);
    dummy
}

fn cg_find_enum(cg: Codegen, name: String) -> I64 {
    let mut i: I64 = 0;
    let len: I64 = vec_len(cg.enums);
    while i < len {
        let entry: CgEnumLayout = vec_get_cgel(cg.enums, i);
        if string_eq(entry.name, name) == 1 {
            return 1;
        };
        i = i + 1;
    };
    0
}

fn cg_get_tuple(cg: Codegen, name: String) -> CgStructLayout {
    let mut i: I64 = 0;
    let len: I64 = vec_len(cg.tuples);
    while i < len {
        let entry: CgStructLayout = vec_get_cgsl(cg.tuples, i);
        if string_eq(entry.name, name) == 1 {
            return entry;
        };
        i = i + 1;
    };
    print_str_stderr(string_concat("codegen error: unknown tuple layout: ", name));
    exit_process(1);
    let dummy: CgStructLayout = vec_get_cgsl(cg.tuples, 0);
    dummy
}

fn cg_get_variant(layout: CgEnumLayout, vname: String) -> CgVariantLayout {
    let mut i: I64 = 0;
    let len: I64 = vec_len(layout.variants);
    while i < len {
        let v: CgVariantLayout = vec_get_cgvl(layout.variants, i);
        if string_eq(v.name, vname) == 1 {
            return v;
        };
        i = i + 1;
    };
    print_str_stderr(string_concat("codegen error: unknown variant: ", vname));
    exit_process(1);
    let dummy: CgVariantLayout = vec_get_cgvl(layout.variants, 0);
    dummy
}

fn cg_get_variant_field(vlayout: CgVariantLayout, fname: String) -> CgVariantFieldLayout {
    let mut i: I64 = 0;
    let len: I64 = vec_len(vlayout.fields);
    while i < len {
        let f: CgVariantFieldLayout = vec_get_cgvfl(vlayout.fields, i);
        if string_eq(f.name, fname) == 1 {
            return f;
        };
        i = i + 1;
    };
    print_str_stderr(string_concat("codegen error: unknown variant field: ", fname));
    exit_process(1);
    let dummy: CgVariantFieldLayout = vec_get_cgvfl(vlayout.fields, 0);
    dummy
}

// ---------------------------------------------------------------------------
// FnCtx helpers
// ---------------------------------------------------------------------------

fn ctx_push_scope(ctx: FnCtx) -> I64 {
    vec_push_vec(ctx.scopes, vec_new());
    0
}

fn ctx_pop_scope(ctx: FnCtx) -> I64 {
    let scope_count: I64 = vec_len(ctx.scopes);
    if scope_count == 0 { return 0; };
    let scope: Vec = vec_get_vec(ctx.scopes, scope_count - 1);
    let mut i: I64 = 0;
    let len: I64 = vec_len(scope);
    // Remove locals that were in this scope
    while i < len {
        let name: String = vec_get_str(scope, i);
        ctx_remove_local(ctx, name);
        i = i + 1;
    };
    vec_set_len(ctx.scopes, scope_count - 1);
    0
}

fn ctx_insert_local(ctx: FnCtx, name: String, local: CgLocal) -> I64 {
    vec_push_cgloc(ctx.locals, local);
    let scope_count: I64 = vec_len(ctx.scopes);
    if scope_count > 0 {
        let scope: Vec = vec_get_vec(ctx.scopes, scope_count - 1);
        vec_push_str(scope, name);
    };
    0
}

fn ctx_get_local(ctx: FnCtx, name: String) -> CgLocal {
    // Search backwards (most recent first)
    let len: I64 = vec_len(ctx.locals);
    let mut i: I64 = len - 1;
    while i >= 0 {
        let local: CgLocal = vec_get_cgloc(ctx.locals, i);
        if string_eq(local.name, name) == 1 {
            return local;
        };
        i = i - 1;
    };
    print_str_stderr(string_concat("codegen error: unknown local: ", name));
    exit_process(1);
    let dummy: CgLocal = vec_get_cgloc(ctx.locals, 0);
    dummy
}

fn ctx_remove_local(ctx: FnCtx, name: String) -> I64 {
    let len: I64 = vec_len(ctx.locals);
    let mut i: I64 = len - 1;
    while i >= 0 {
        let local: CgLocal = vec_get_cgloc(ctx.locals, i);
        if string_eq(local.name, name) == 1 {
            vec_set_len(ctx.locals, len - 1);
            return 0;
        };
        i = i - 1;
    };
    0
}

// ---------------------------------------------------------------------------
// Codegen initialization
// ---------------------------------------------------------------------------

fn new_codegen() -> Codegen {
    let ctx: RawPointer<I8> = LLVMContextCreate();
    let llmod: RawPointer<I8> = LLVMModuleCreateWithNameInContext("lang_module", ctx);
    let builder: RawPointer<I8> = LLVMCreateBuilderInContext(ctx);
    let ptr_ty: RawPointer<I8> = lang_llvm_ptr_type(ctx);
    let i32_ty: RawPointer<I8> = LLVMInt32TypeInContext(ctx);
    let i64_ty: RawPointer<I8> = LLVMInt64TypeInContext(ctx);
    let void_ty: RawPointer<I8> = LLVMVoidTypeInContext(ctx);

    // Thread struct: { ptr, i32, i32 }
    let thread_elems: Vec = vec_new();
    vec_push_raw(thread_elems, ptr_ty);
    vec_push_raw(thread_elems, i32_ty);
    vec_push_raw(thread_elems, i32_ty);
    let thread_struct_ty: RawPointer<I8> = lang_llvm_struct_type(ctx, vec_data(thread_elems), 3, 0);

    // gc_pollcheck_slow(ptr, ptr) -> void
    let poll_params: Vec = vec_new();
    vec_push_raw(poll_params, ptr_ty);
    vec_push_raw(poll_params, ptr_ty);
    let poll_ty: RawPointer<I8> = lang_llvm_function_type(void_ty, vec_data(poll_params), 2, 0);
    let poll_fn: RawPointer<I8> = LLVMAddFunction(llmod, "gc_pollcheck_slow", poll_ty);

    // gc_alloc(i64, i64, i64) -> ptr
    let alloc_params: Vec = vec_new();
    vec_push_raw(alloc_params, i64_ty);
    vec_push_raw(alloc_params, i64_ty);
    vec_push_raw(alloc_params, i64_ty);
    let alloc_ty: RawPointer<I8> = lang_llvm_function_type(ptr_ty, vec_data(alloc_params), 3, 0);
    let alloc_fn: RawPointer<I8> = LLVMAddFunction(llmod, "gc_alloc", alloc_ty);

    // gc_write_barrier(ptr, ptr, ptr) -> void
    let wb_params: Vec = vec_new();
    vec_push_raw(wb_params, ptr_ty);
    vec_push_raw(wb_params, ptr_ty);
    vec_push_raw(wb_params, ptr_ty);
    let wb_ty: RawPointer<I8> = lang_llvm_function_type(void_ty, vec_data(wb_params), 3, 0);
    let wb_fn: RawPointer<I8> = LLVMAddFunction(llmod, "gc_write_barrier", wb_ty);

    Codegen {
        context: ctx,
        llmod: llmod,
        builder: builder,
        thread_struct_ty: thread_struct_ty,
        functions: vec_new(),
        externs: vec_new(),
        gc_pollcheck_fn: poll_fn,
        gc_pollcheck_ty: poll_ty,
        gc_alloc_fn: alloc_fn,
        gc_alloc_ty: alloc_ty,
        gc_write_barrier_fn: wb_fn,
        gc_write_barrier_ty: wb_ty,
        structs: vec_new(),
        enums: vec_new(),
        tuples: vec_new(),
        str_lit_id: 0,
        next_type_id: 1,
        compiler_used: vec_new()
    }
}

// ---------------------------------------------------------------------------
// Layout computation
// ---------------------------------------------------------------------------

fn compute_struct_layout(cg: Codegen, full_name: String, fields: Vec) -> CgStructLayout {
    let ptr_fields: Vec = vec_new();
    let raw_fields: Vec = vec_new();

    let mut i: I64 = 0;
    while i < vec_len(fields) {
        let f: Field = vec_get_field(fields, i);
        let is_ptr: Bool = is_gc_ref_type(f.ty);
        let fty: RawPointer<I8> = field_llvm_type(cg, f.ty);
        let tag: I64 = type_to_tag(f.ty);
        let tname: String = type_name_from_type(f.ty);
        let fl: CgFieldLayout = CgFieldLayout {
            name: f.name, type_name: tname, index: 0, is_ptr: is_ptr, llvm_ty: fty, lang_ty_tag: tag
        };
        if is_ptr { vec_push_cgfl(ptr_fields, fl); }
        else { vec_push_cgfl(raw_fields, fl); };
        i = i + 1;
    };

    let result_fields: Vec = vec_new();
    let mut idx: I64 = 0;

    let mut j: I64 = 0;
    while j < vec_len(ptr_fields) {
        let pf: CgFieldLayout = vec_get_cgfl(ptr_fields, j);
        vec_push_cgfl(result_fields, CgFieldLayout {
            name: pf.name, type_name: pf.type_name, index: idx, is_ptr: pf.is_ptr, llvm_ty: pf.llvm_ty, lang_ty_tag: pf.lang_ty_tag
        });
        idx = idx + 1;
        j = j + 1;
    };

    let ptr_field_count: I64 = idx;

    let mut k: I64 = 0;
    while k < vec_len(raw_fields) {
        let rf: CgFieldLayout = vec_get_cgfl(raw_fields, k);
        vec_push_cgfl(result_fields, CgFieldLayout {
            name: rf.name, type_name: rf.type_name, index: idx, is_ptr: rf.is_ptr, llvm_ty: rf.llvm_ty, lang_ty_tag: rf.lang_ty_tag
        });
        idx = idx + 1;
        k = k + 1;
    };

    let field_count: I64 = idx;
    let type_id: I64 = cg.next_type_id;
    cg.next_type_id = cg.next_type_id + 1;

    CgStructLayout { name: full_name, field_count: field_count, ptr_field_count: ptr_field_count, type_id: type_id, fields: result_fields }
}

fn compute_enum_layout(cg: Codegen, full_name: String, variants: Vec) -> CgEnumLayout {
    let result_variants: Vec = vec_new();
    let mut max_ptrs: I64 = 0;
    let mut max_raw_fields: I64 = 0;

    // First pass: find max ptr count and max raw field count
    let mut vi: I64 = 0;
    while vi < vec_len(variants) {
        let v: EnumVariant = vec_get_variant(variants, vi);
        let mut ptr_count: I64 = 0;
        let mut raw_count: I64 = 0;

        match v.kind {
            EnumVariantKind::UnitKind {} => {},
            EnumVariantKind::TupleKind { types } => {
                let mut ti: I64 = 0;
                while ti < vec_len(types) {
                    let ty: Type = vec_get_type(types, ti);
                    if is_gc_ref_type(ty) { ptr_count = ptr_count + 1; }
                    else { raw_count = raw_count + 1; };
                    ti = ti + 1;
                };
            },
            EnumVariantKind::StructKind { fields } => {
                let mut fi: I64 = 0;
                while fi < vec_len(fields) {
                    let f: Field = vec_get_field(fields, fi);
                    if is_gc_ref_type(f.ty) { ptr_count = ptr_count + 1; }
                    else { raw_count = raw_count + 1; };
                    fi = fi + 1;
                };
            }
        };

        if ptr_count > max_ptrs { max_ptrs = ptr_count; };
        if raw_count > max_raw_fields { max_raw_fields = raw_count; };
        vi = vi + 1;
    };

    // Layout: [ptr fields 0..max_ptrs-1] [tag at max_ptrs] [raw fields max_ptrs+1..]
    let tag_index: I64 = max_ptrs;
    let field_count: I64 = max_ptrs + 1 + max_raw_fields;

    // Second pass: assign field indices per variant
    let mut vi2: I64 = 0;
    while vi2 < vec_len(variants) {
        let v: EnumVariant = vec_get_variant(variants, vi2);
        let mut ptr_idx: I64 = 0;
        let mut raw_idx: I64 = tag_index + 1;
        let vfields: Vec = vec_new();

        match v.kind {
            EnumVariantKind::UnitKind {} => {},
            EnumVariantKind::TupleKind { types } => {
                let mut ti: I64 = 0;
                while ti < vec_len(types) {
                    let ty: Type = vec_get_type(types, ti);
                    let is_ptr: Bool = is_gc_ref_type(ty);
                    let fty: RawPointer<I8> = field_llvm_type(cg, ty);
                    let ftag: I64 = type_to_tag(ty);
                    let tname: String = type_name_from_type(ty);
                    if is_ptr {
                        vec_push_cgvfl(vfields, CgVariantFieldLayout { name: "", type_name: tname, is_ptr: true, field_index: ptr_idx, llvm_ty: fty, lang_ty_tag: ftag });
                        ptr_idx = ptr_idx + 1;
                    } else {
                        vec_push_cgvfl(vfields, CgVariantFieldLayout { name: "", type_name: tname, is_ptr: false, field_index: raw_idx, llvm_ty: fty, lang_ty_tag: ftag });
                        raw_idx = raw_idx + 1;
                    };
                    ti = ti + 1;
                };
            },
            EnumVariantKind::StructKind { fields } => {
                let mut fi: I64 = 0;
                while fi < vec_len(fields) {
                    let f: Field = vec_get_field(fields, fi);
                    let is_ptr: Bool = is_gc_ref_type(f.ty);
                    let fty: RawPointer<I8> = field_llvm_type(cg, f.ty);
                    let ftag: I64 = type_to_tag(f.ty);
                    let tname: String = type_name_from_type(f.ty);
                    if is_ptr {
                        vec_push_cgvfl(vfields, CgVariantFieldLayout { name: f.name, type_name: tname, is_ptr: true, field_index: ptr_idx, llvm_ty: fty, lang_ty_tag: ftag });
                        ptr_idx = ptr_idx + 1;
                    } else {
                        vec_push_cgvfl(vfields, CgVariantFieldLayout { name: f.name, type_name: tname, is_ptr: false, field_index: raw_idx, llvm_ty: fty, lang_ty_tag: ftag });
                        raw_idx = raw_idx + 1;
                    };
                    fi = fi + 1;
                };
            }
        };

        vec_push_cgvl(result_variants, CgVariantLayout { name: v.name, tag: vi2, fields: vfields });
        vi2 = vi2 + 1;
    };

    let type_id: I64 = cg.next_type_id;
    cg.next_type_id = cg.next_type_id + 1;

    CgEnumLayout { name: full_name, field_count: field_count, ptr_field_count: max_ptrs, type_id: type_id, variants: result_variants }
}

// ---------------------------------------------------------------------------
// Declaration phase
// ---------------------------------------------------------------------------

fn declare_structs(cg: Codegen, modules: Vec) -> I64 {
    let mut mi: I64 = 0;
    while mi < vec_len(modules) {
        let m: Module = vec_get_module(modules, mi);
        let mut ii: I64 = 0;
        while ii < vec_len(m.items) {
            let item: Item = vec_get_item(m.items, ii);
            match item {
                Item::StructItem { decl } => {
                    let fname: String = full_item_name(m.path, decl.name);
                    let layout: CgStructLayout = compute_struct_layout(cg, fname, decl.fields);
                    vec_push_cgsl(cg.structs, layout);
                },
                Item::FnItem { decl } => {},
                Item::EnumItem { decl } => {},
                Item::ExternFnItem { decl } => {},
                Item::UseItem { decl } => {},
                Item::LinkItem { decl } => {}
            };
            ii = ii + 1;
        };
        mi = mi + 1;
    };
    0
}

fn declare_enums(cg: Codegen, modules: Vec) -> I64 {
    let mut mi: I64 = 0;
    while mi < vec_len(modules) {
        let m: Module = vec_get_module(modules, mi);
        let mut ii: I64 = 0;
        while ii < vec_len(m.items) {
            let item: Item = vec_get_item(m.items, ii);
            match item {
                Item::EnumItem { decl } => {
                    let fname: String = full_item_name(m.path, decl.name);
                    let layout: CgEnumLayout = compute_enum_layout(cg, fname, decl.variants);
                    vec_push_cgel(cg.enums, layout);
                },
                Item::FnItem { decl } => {},
                Item::StructItem { decl } => {},
                Item::ExternFnItem { decl } => {},
                Item::UseItem { decl } => {},
                Item::LinkItem { decl } => {}
            };
            ii = ii + 1;
        };
        mi = mi + 1;
    };
    0
}

fn declare_fn(cg: Codegen, full_name: String, params: Vec, ret_type: Type) -> CgFnEntry {
    let param_tys: Vec = vec_new();
    vec_push_raw(param_tys, lang_llvm_ptr_type(cg.context));
    let mut i: I64 = 0;
    while i < vec_len(params) {
        let p: Param = vec_get_param(params, i);
        vec_push_raw(param_tys, llvm_type(cg, p.ty));
        i = i + 1;
    };
    let ret: RawPointer<I8> = llvm_type(cg, ret_type);
    let fn_ty: RawPointer<I8> = lang_llvm_function_type(ret, vec_data(param_tys), vec_len(param_tys), 0);
    let llvm_name: String = llvm_fn_name(full_name);
    let fn_val: RawPointer<I8> = LLVMAddFunction(cg.llmod, llvm_name, fn_ty);
    CgFnEntry { name: full_name, fn_val: fn_val, fn_ty: fn_ty }
}

fn declare_extern_fn_entry(cg: Codegen, full_name: String, params: Vec, ret_type: Type, varargs: Bool) -> CgFnEntry {
    let symbol: String = last_segment(full_name);
    let existing: RawPointer<I8> = LLVMGetNamedFunction(cg.llmod, symbol);
    if ptr_is_null(existing) == 0 {
        let fn_ty: RawPointer<I8> = LLVMGlobalGetValueType(existing);
        return CgFnEntry { name: full_name, fn_val: existing, fn_ty: fn_ty };
    };
    let param_tys: Vec = vec_new();
    let mut i: I64 = 0;
    while i < vec_len(params) {
        let p: Param = vec_get_param(params, i);
        vec_push_raw(param_tys, llvm_type(cg, p.ty));
        i = i + 1;
    };
    let ret: RawPointer<I8> = llvm_type(cg, ret_type);
    let va: I64 = if varargs { 1 } else { 0 };
    let fn_ty: RawPointer<I8> = lang_llvm_function_type(ret, vec_data(param_tys), vec_len(param_tys), va);
    let fn_val: RawPointer<I8> = LLVMAddFunction(cg.llmod, symbol, fn_ty);
    CgFnEntry { name: full_name, fn_val: fn_val, fn_ty: fn_ty }
}

fn declare_functions(cg: Codegen, modules: Vec) -> I64 {
    let mut mi: I64 = 0;
    while mi < vec_len(modules) {
        let m: Module = vec_get_module(modules, mi);
        let mut ii: I64 = 0;
        while ii < vec_len(m.items) {
            let item: Item = vec_get_item(m.items, ii);
            match item {
                Item::FnItem { decl } => {
                    let fname: String = full_item_name(m.path, decl.name);
                    let entry: CgFnEntry = declare_fn(cg, fname, decl.params, decl.ret_type);
                    vec_push_cgfn(cg.functions, entry);
                },
                Item::ExternFnItem { decl } => {
                    let fname: String = full_item_name(m.path, decl.name);
                    let entry: CgFnEntry = declare_extern_fn_entry(cg, fname, decl.params, decl.ret_type, decl.varargs);
                    vec_push_cgfn(cg.externs, entry);
                },
                Item::StructItem { decl } => {},
                Item::EnumItem { decl } => {},
                Item::UseItem { decl } => {},
                Item::LinkItem { decl } => {}
            };
            ii = ii + 1;
        };
        mi = mi + 1;
    };
    0
}

// ---------------------------------------------------------------------------
// GC stack frames
// ---------------------------------------------------------------------------

fn make_frame_type(cg: Codegen, num_roots: I64) -> RawPointer<I8> {
    let ptr_ty: RawPointer<I8> = lang_llvm_ptr_type(cg.context);
    let roots_ty: RawPointer<I8> = lang_llvm_array_type(ptr_ty, num_roots);
    let elems: Vec = vec_new();
    vec_push_raw(elems, ptr_ty);
    vec_push_raw(elems, ptr_ty);
    vec_push_raw(elems, roots_ty);
    lang_llvm_struct_type(cg.context, vec_data(elems), 3, 0)
}

fn create_frame_origin(cg: Codegen, fn_name: String, num_roots: I64) -> RawPointer<I8> {
    let ctx: RawPointer<I8> = cg.context;
    let i32_ty: RawPointer<I8> = LLVMInt32TypeInContext(ctx);
    let ptr_ty: RawPointer<I8> = lang_llvm_ptr_type(ctx);

    let name_len: I64 = string_len(fn_name);
    let name_const: RawPointer<I8> = lang_llvm_const_string(ctx, fn_name, name_len, 1);
    let name_arr_ty: RawPointer<I8> = lang_llvm_array_type(LLVMInt8TypeInContext(ctx), name_len + 1);
    let sym: String = mangle_name(fn_name);
    let name_global: RawPointer<I8> = LLVMAddGlobal(cg.llmod, name_arr_ty, string_concat("__fn_name_", sym));
    lang_llvm_set_initializer(name_global, name_const);

    let zero32: RawPointer<I8> = lang_llvm_const_int(i32_ty, 0, 0);
    let gep_indices: Vec = vec_new();
    vec_push_raw(gep_indices, zero32);
    vec_push_raw(gep_indices, zero32);
    let name_ptr: RawPointer<I8> = lang_llvm_const_gep2(name_arr_ty, name_global, vec_data(gep_indices), 2);

    let origin_elems: Vec = vec_new();
    vec_push_raw(origin_elems, i32_ty);
    vec_push_raw(origin_elems, ptr_ty);
    let origin_ty: RawPointer<I8> = lang_llvm_struct_type(ctx, vec_data(origin_elems), 2, 0);
    let origin_global: RawPointer<I8> = LLVMAddGlobal(cg.llmod, origin_ty, string_concat("__frame_origin_", sym));

    let origin_vals: Vec = vec_new();
    vec_push_raw(origin_vals, lang_llvm_const_int(i32_ty, num_roots, 0));
    vec_push_raw(origin_vals, name_ptr);
    let init: RawPointer<I8> = lang_llvm_const_named_struct(origin_ty, vec_data(origin_vals), 2);
    lang_llvm_set_initializer(origin_global, init);

    vec_push_raw(cg.compiler_used, name_global);
    vec_push_raw(cg.compiler_used, origin_global);

    origin_global
}

fn thread_top_frame_ptr(cg: Codegen, thread: RawPointer<I8>) -> RawPointer<I8> {
    lang_llvm_build_struct_gep2(cg.builder, cg.thread_struct_ty, thread, 0, "thread.top")
}

fn thread_state_ptr(cg: Codegen, thread: RawPointer<I8>) -> RawPointer<I8> {
    lang_llvm_build_struct_gep2(cg.builder, cg.thread_struct_ty, thread, 1, "thread.state")
}

fn emit_prologue(cg: Codegen, function: RawPointer<I8>, thread: RawPointer<I8>, fn_name: String, num_roots: I64, ft: RawPointer<I8>) -> FnCtx {
    let ctx: RawPointer<I8> = cg.context;
    let ptr_ty: RawPointer<I8> = lang_llvm_ptr_type(ctx);

    let frame_origin: RawPointer<I8> = create_frame_origin(cg, fn_name, num_roots);
    let frame_ptr: RawPointer<I8> = LLVMBuildAlloca(cg.builder, ft, "frame");

    let parent_ptr: RawPointer<I8> = lang_llvm_build_struct_gep2(cg.builder, ft, frame_ptr, 0, "frame.parent");
    let origin_ptr: RawPointer<I8> = lang_llvm_build_struct_gep2(cg.builder, ft, frame_ptr, 1, "frame.origin");

    let top_frame_ptr: RawPointer<I8> = thread_top_frame_ptr(cg, thread);
    let parent: RawPointer<I8> = LLVMBuildLoad2(cg.builder, ptr_ty, top_frame_ptr, "parent");

    LLVMBuildStore(cg.builder, parent, parent_ptr);
    LLVMBuildStore(cg.builder, frame_origin, origin_ptr);

    let mut root_base: RawPointer<I8> = LLVMConstNull(ptr_ty);
    if num_roots > 0 {
        let roots_ptr: RawPointer<I8> = lang_llvm_build_struct_gep2(cg.builder, ft, frame_ptr, 2, "frame.roots");
        let roots_ty: RawPointer<I8> = lang_llvm_array_type(ptr_ty, num_roots);
        let zero: RawPointer<I8> = lang_llvm_const_int(LLVMInt32TypeInContext(ctx), 0, 0);
        let gep_idx: Vec = vec_new();
        vec_push_raw(gep_idx, zero);
        vec_push_raw(gep_idx, zero);
        root_base = lang_llvm_build_gep2(cg.builder, roots_ty, roots_ptr, vec_data(gep_idx), 2, "root0");

        let size_val: RawPointer<I8> = lang_llvm_const_int(LLVMInt64TypeInContext(ctx), 8 * num_roots, 0);
        let zero_val: RawPointer<I8> = lang_llvm_const_int(LLVMInt8TypeInContext(ctx), 0, 0);
        let cast: RawPointer<I8> = LLVMBuildBitCast(cg.builder, root_base, ptr_ty, "root0_cast");
        lang_llvm_build_memset(cg.builder, cast, zero_val, size_val, 8);
    };

    LLVMBuildStore(cg.builder, frame_ptr, top_frame_ptr);

    FnCtx {
        function: function,
        locals: vec_new(),
        scopes: vec_new(),
        thread: thread,
        frame_ptr: frame_ptr,
        frame_origin: frame_origin,
        frame_ty: ft,
        root_base: root_base,
        next_root: 0,
        loop_stack: vec_new()
    }
}

fn emit_epilogue(cg: Codegen, ctx: FnCtx) -> I64 {
    let ptr_ty: RawPointer<I8> = lang_llvm_ptr_type(cg.context);
    let parent_ptr: RawPointer<I8> = lang_llvm_build_struct_gep2(cg.builder, ctx.frame_ty, ctx.frame_ptr, 0, "frame.parent");
    let parent: RawPointer<I8> = LLVMBuildLoad2(cg.builder, ptr_ty, parent_ptr, "parent_load");
    let top_frame_ptr: RawPointer<I8> = thread_top_frame_ptr(cg, ctx.thread);
    LLVMBuildStore(cg.builder, parent, top_frame_ptr);
    0
}

fn emit_pollcheck(cg: Codegen, ctx: FnCtx) -> I64 {
    let i32_ty: RawPointer<I8> = LLVMInt32TypeInContext(cg.context);
    let state_ptr: RawPointer<I8> = thread_state_ptr(cg, ctx.thread);
    let state: RawPointer<I8> = LLVMBuildLoad2(cg.builder, i32_ty, state_ptr, "gc_state");
    let zero: RawPointer<I8> = lang_llvm_const_int(i32_ty, 0, 0);
    let needs: RawPointer<I8> = lang_llvm_build_icmp(cg.builder, ICMP_NE(), state, zero, "needs_gc");

    let slow_bb: RawPointer<I8> = LLVMAppendBasicBlockInContext(cg.context, ctx.function, "poll.slow");
    let cont_bb: RawPointer<I8> = LLVMAppendBasicBlockInContext(cg.context, ctx.function, "poll.cont");
    LLVMBuildCondBr(cg.builder, needs, slow_bb, cont_bb);

    lang_llvm_position_at_end(cg.builder, slow_bb);
    let args: Vec = vec_new();
    vec_push_raw(args, ctx.thread);
    vec_push_raw(args, ctx.frame_origin);
    lang_llvm_build_call(cg.builder, cg.gc_pollcheck_ty, cg.gc_pollcheck_fn, vec_data(args), 2, "poll");
    LLVMBuildBr(cg.builder, cont_bb);

    lang_llvm_position_at_end(cg.builder, cont_bb);
    0
}

// ---------------------------------------------------------------------------
// Local variable storage
// ---------------------------------------------------------------------------

fn create_entry_alloca(cg: Codegen, function: RawPointer<I8>, name: String, tag: I64) -> RawPointer<I8> {
    let entry_bb: RawPointer<I8> = LLVMGetFirstBasicBlock(function);
    let first_instr: RawPointer<I8> = LLVMGetFirstInstruction(entry_bb);
    let tmp_builder: RawPointer<I8> = LLVMCreateBuilderInContext(cg.context);
    if ptr_is_null(first_instr) == 1 {
        lang_llvm_position_at_end(tmp_builder, entry_bb);
    } else {
        lang_llvm_position_before(tmp_builder, first_instr);
    };
    let lty: RawPointer<I8> = llvm_type_for_tag(cg, tag);
    let ptr: RawPointer<I8> = LLVMBuildAlloca(tmp_builder, lty, name);
    lang_llvm_dispose_builder(tmp_builder);
    ptr
}

fn create_local_storage(cg: Codegen, ctx: FnCtx, name: String, ty: Type) -> CgLocal {
    let tag: I64 = type_to_tag(ty);
    let tname: String = type_name_from_type(ty);
    let is_ref: Bool = is_gc_ref_type(ty);
    if is_ref {
        let idx: RawPointer<I8> = lang_llvm_const_int(LLVMInt32TypeInContext(cg.context), ctx.next_root, 0);
        let ptr_ty: RawPointer<I8> = lang_llvm_ptr_type(cg.context);
        let indices: Vec = vec_new();
        vec_push_raw(indices, idx);
        let slot_ptr: RawPointer<I8> = lang_llvm_build_gep2(cg.builder, ptr_ty, ctx.root_base, vec_data(indices), 1, "root_slot");
        CgLocal { name: name, type_name: tname, ptr: slot_ptr, ty: ptr_ty, lang_ty_tag: tag, is_gc_ref: true }
    } else {
        let ptr: RawPointer<I8> = create_entry_alloca(cg, ctx.function, name, tag);
        let lty: RawPointer<I8> = llvm_type_for_tag(cg, tag);
        CgLocal { name: name, type_name: tname, ptr: ptr, ty: lty, lang_ty_tag: tag, is_gc_ref: false }
    }
}

fn load_local(cg: Codegen, local: CgLocal) -> RawPointer<I8> {
    let loaded: RawPointer<I8> = LLVMBuildLoad2(cg.builder, local.ty, local.ptr, local.name);
    if local.is_gc_ref { lang_llvm_set_volatile(loaded, 1); };
    loaded
}

fn store_local(cg: Codegen, local: CgLocal, value: RawPointer<I8>) -> I64 {
    let inst: RawPointer<I8> = LLVMBuildStore(cg.builder, value, local.ptr);
    if local.is_gc_ref { lang_llvm_set_volatile(inst, 1); };
    0
}

// ---------------------------------------------------------------------------
// Root counting (pre-scan to determine frame size)
// ---------------------------------------------------------------------------

fn count_param_roots(params: Vec) -> I64 {
    let mut count: I64 = 0;
    let mut i: I64 = 0;
    while i < vec_len(params) {
        let p: Param = vec_get_param(params, i);
        if is_gc_ref_type(p.ty) { count = count + 1; };
        i = i + 1;
    };
    count
}

fn count_roots_in_fn(cg: Codegen, params: Vec, body: Block) -> I64 {
    count_param_roots(params) + count_roots_in_block(cg, body)
}

fn count_roots_in_block(cg: Codegen, block: Block) -> I64 {
    let mut count: I64 = 0;
    let mut i: I64 = 0;
    while i < vec_len(block.stmts) {
        let stmt: Stmt = vec_get_stmt(block.stmts, i);
        match stmt {
            Stmt::ExprStmt { expr, span } => {
                count = count + count_roots_in_expr(cg, expr);
            },
            Stmt::ReturnStmt { value, span } => {
                match value {
                    Option::Some { value } => {
                        count = count + count_roots_in_expr(cg, value);
                    },
                    Option::None {} => {}
                };
            }
        };
        i = i + 1;
    };
    match block.tail {
        Option::Some { value } => { count = count + count_roots_in_expr(cg, value); },
        Option::None {} => {}
    };
    count
}

fn count_roots_in_expr(cg: Codegen, expr: Expr) -> I64 {
    match expr {
        Expr::LetExpr { name, mutable, ty, value, span } => {
            let mut count: I64 = 0;
            match ty {
                Option::Some { value: ty_val } => {
                    if is_gc_ref_type(ty_val) { count = count + 1; };
                },
                Option::None {} => {}
            };
            count + count_roots_in_expr(cg, value)
        },
        Expr::IfExpr { cond, then_branch, else_branch, span } => {
            let mut count: I64 = count_roots_in_expr(cg, cond);
            count = count + count_roots_in_block(cg, then_branch);
            match else_branch {
                Option::Some { value } => { count = count + count_roots_in_block(cg, value); },
                Option::None {} => {}
            };
            count
        },
        Expr::WhileExpr { cond, body, span } => {
            count_roots_in_expr(cg, cond) + count_roots_in_block(cg, body)
        },
        Expr::MatchExpr { scrutinee, arms, span } => {
            let mut count: I64 = count_roots_in_expr(cg, scrutinee);
            let mut i: I64 = 0;
            while i < vec_len(arms) {
                let arm: MatchArm = vec_get_arm(arms, i);
                count = count + count_roots_in_pattern(cg, arm.pattern);
                count = count + count_roots_in_expr(cg, arm.body);
                i = i + 1;
            };
            count
        },
        Expr::AssignExpr { target, value, span } => {
            count_roots_in_expr(cg, target) + count_roots_in_expr(cg, value)
        },
        Expr::BinaryExpr { op, left, right, span } => {
            count_roots_in_expr(cg, left) + count_roots_in_expr(cg, right)
        },
        Expr::UnaryExpr { op, operand, span } => {
            count_roots_in_expr(cg, operand)
        },
        Expr::CallExpr { callee, args, span } => {
            let mut count: I64 = count_roots_in_expr(cg, callee);
            let mut i: I64 = 0;
            while i < vec_len(args) {
                let arg: Expr = vec_get_expr(args, i);
                count = count + count_roots_in_expr(cg, arg);
                i = i + 1;
            };
            count
        },
        Expr::FieldExpr { base, name, span } => {
            count_roots_in_expr(cg, base)
        },
        Expr::StructLitExpr { path, fields, span } => {
            let mut count: I64 = 0;
            let mut i: I64 = 0;
            while i < vec_len(fields) {
                let f: StructLitField = vec_get_slfield(fields, i);
                count = count + count_roots_in_expr(cg, f.value);
                i = i + 1;
            };
            count
        },
        Expr::TupleExpr { items, span } => {
            let mut count: I64 = 0;
            let mut i: I64 = 0;
            while i < vec_len(items) {
                let it: Expr = vec_get_expr(items, i);
                count = count + count_roots_in_expr(cg, it);
                i = i + 1;
            };
            count
        },
        Expr::BlockExpr { block } => {
            count_roots_in_block(cg, block)
        },
        Expr::PathExpr { path, span } => { 0 },
        Expr::LitExpr { lit, span } => { 0 },
        Expr::BreakExpr { span } => { 0 },
        Expr::ContinueExpr { span } => { 0 }
    }
}

fn count_roots_in_pattern(cg: Codegen, pat: Pattern) -> I64 {
    match pat {
        Pattern::StructPat { path, fields, span } => {
            if vec_len(path) < 2 { return 0; };
            let enum_name: String = enum_path_and_variant(path);
            let vname: String = variant_name_from_path(path);
            if cg_find_enum(cg, enum_name) == 0 { return 0; };
            let layout: CgEnumLayout = cg_get_enum(cg, enum_name);
            let mut vi: I64 = 0;
            let mut vlayout_found: Bool = false;
            let mut vlayout: CgVariantLayout = CgVariantLayout { name: "", tag: 0, fields: vec_new() };
            while vi < vec_len(layout.variants) {
                let v: CgVariantLayout = vec_get_cgvl(layout.variants, vi);
                if string_eq(v.name, vname) == 1 {
                    vlayout = v;
                    vlayout_found = true;
                };
                vi = vi + 1;
            };
            if !vlayout_found { return 0; };
            let mut count: I64 = 0;
            let mut fi: I64 = 0;
            while fi < vec_len(fields) {
                let pf: PatternField = vec_get_pfield(fields, fi);
                match pf.binding {
                    Option::None {} => {},
                    Option::Some { value } => {
                        // Find this field in the variant
                        let mut ffi: I64 = 0;
                        while ffi < vec_len(vlayout.fields) {
                            let vfl: CgVariantFieldLayout = vec_get_cgvfl(vlayout.fields, ffi);
                            if string_eq(vfl.name, pf.name) == 1 {
                                if vfl.is_ptr { count = count + 1; };
                            };
                            ffi = ffi + 1;
                        };
                    }
                };
                fi = fi + 1;
            };
            count
        },
        Pattern::WildcardPat { span } => { 0 },
        Pattern::PathPat { path, span } => { 0 }
    }
}

// ---------------------------------------------------------------------------
// Memory access helpers
// ---------------------------------------------------------------------------

// Compute pointer to field at given index: obj + 8 + index * 8
fn gc_field_ptr(cg: Codegen, obj_ptr: RawPointer<I8>, field_index: I64) -> RawPointer<I8> {
    let i8_ty: RawPointer<I8> = LLVMInt8TypeInContext(cg.context);
    let byte_offset: I64 = 8 + field_index * 8;
    let offset: RawPointer<I8> = lang_llvm_const_int(LLVMInt64TypeInContext(cg.context), byte_offset, 0);
    let idx: Vec = vec_new();
    vec_push_raw(idx, offset);
    lang_llvm_build_gep2(cg.builder, i8_ty, obj_ptr, vec_data(idx), 1, "field_ptr")
}

fn field_ptr(cg: Codegen, obj_ptr: RawPointer<I8>, fl: CgFieldLayout) -> RawPointer<I8> {
    gc_field_ptr(cg, obj_ptr, fl.index)
}

fn enum_field_ptr(cg: Codegen, obj_ptr: RawPointer<I8>, field_index: I64) -> RawPointer<I8> {
    gc_field_ptr(cg, obj_ptr, field_index)
}

fn load_enum_tag(cg: Codegen, obj_ptr: RawPointer<I8>, layout: CgEnumLayout) -> RawPointer<I8> {
    let tag_index: I64 = layout.ptr_field_count;
    let tag_ptr: RawPointer<I8> = gc_field_ptr(cg, obj_ptr, tag_index);
    let i64_ty: RawPointer<I8> = LLVMInt64TypeInContext(cg.context);
    let tag_i64: RawPointer<I8> = LLVMBuildLoad2(cg.builder, i64_ty, tag_ptr, "tag_i64");
    LLVMBuildTrunc(cg.builder, tag_i64, LLVMInt32TypeInContext(cg.context), "tag")
}

// ---------------------------------------------------------------------------
// Struct field resolution
// ---------------------------------------------------------------------------

fn resolve_struct_base(cg: Codegen, base: Expr, ctx: FnCtx) -> RawPointer<I8> {
    // Returns the object pointer for a struct base expression
    match base {
        Expr::PathExpr { path, span } => {
            let var: String = vec_get_str(path, vec_len(path) - 1);
            let local: CgLocal = ctx_get_local(ctx, var);
            load_local(cg, local)
        },
        Expr::FieldExpr { base, name, span } => {
            let obj_ptr: RawPointer<I8> = resolve_struct_base(cg, base, ctx);
            let type_name: String = resolve_base_type_name(cg, base, ctx);
            let layout: CgStructLayout = cg_get_struct(cg, type_name);
            let fl: CgFieldLayout = find_field_layout(layout.fields, name);
            let fp: RawPointer<I8> = field_ptr(cg, obj_ptr, fl);
            LLVMBuildLoad2(cg.builder, fl.llvm_ty, fp, "field_obj")
        },
        _ => {
            print_str_stderr("codegen error: field base must be path or field");
            exit_process(1);
            LLVMConstNull(lang_llvm_ptr_type(cg.context))
        }
    }
}

fn resolve_base_type_name(cg: Codegen, base: Expr, ctx: FnCtx) -> String {
    match base {
        Expr::PathExpr { path, span } => {
            let var: String = vec_get_str(path, vec_len(path) - 1);
            let local: CgLocal = ctx_get_local(ctx, var);
            local.type_name
        },
        Expr::FieldExpr { base, name, span } => {
            let parent_type: String = resolve_base_type_name(cg, base, ctx);
            let layout: CgStructLayout = cg_get_struct(cg, parent_type);
            let fl: CgFieldLayout = find_field_layout(layout.fields, name);
            fl.type_name
        },
        _ => {
            print_str_stderr("codegen error: cannot resolve type name for base");
            exit_process(1);
            ""
        }
    }
}

fn find_field_layout(fields: Vec, name: String) -> CgFieldLayout {
    let mut i: I64 = 0;
    while i < vec_len(fields) {
        let fl: CgFieldLayout = vec_get_cgfl(fields, i);
        if string_eq(fl.name, name) == 1 { return fl; };
        i = i + 1;
    };
    print_str_stderr(string_concat("codegen error: unknown field: ", name));
    exit_process(1);
    let dummy: CgFieldLayout = vec_get_cgfl(fields, 0);
    dummy
}

// ---------------------------------------------------------------------------
// Binary operations
// ---------------------------------------------------------------------------

fn codegen_binary(cg: Codegen, op: BinaryOp, left: RawPointer<I8>, right: RawPointer<I8>) -> RawPointer<I8> {
    // Check if float by looking at LLVM type kind
    let left_ty: RawPointer<I8> = LLVMTypeOf(left);
    let kind: I64 = lang_llvm_get_type_kind(left_ty);
    if kind == TK_FLOAT() || kind == TK_DOUBLE() {
        return codegen_binary_float(cg, op, left, right);
    };
    codegen_binary_int(cg, op, left, right)
}

fn codegen_binary_int(cg: Codegen, op: BinaryOp, l: RawPointer<I8>, r: RawPointer<I8>) -> RawPointer<I8> {
    let b: RawPointer<I8> = cg.builder;
    match op {
        BinaryOp::Add {} => { LLVMBuildAdd(b, l, r, "add") },
        BinaryOp::Sub {} => { LLVMBuildSub(b, l, r, "sub") },
        BinaryOp::Mul {} => { LLVMBuildMul(b, l, r, "mul") },
        BinaryOp::Div {} => { LLVMBuildSDiv(b, l, r, "div") },
        BinaryOp::Rem {} => { LLVMBuildSRem(b, l, r, "rem") },
        BinaryOp::Eq {} => { lang_llvm_build_icmp(b, ICMP_EQ(), l, r, "eq") },
        BinaryOp::NotEq {} => { lang_llvm_build_icmp(b, ICMP_NE(), l, r, "ne") },
        BinaryOp::Lt {} => { lang_llvm_build_icmp(b, ICMP_SLT(), l, r, "lt") },
        BinaryOp::LtEq {} => { lang_llvm_build_icmp(b, ICMP_SLE(), l, r, "le") },
        BinaryOp::Gt {} => { lang_llvm_build_icmp(b, ICMP_SGT(), l, r, "gt") },
        BinaryOp::GtEq {} => { lang_llvm_build_icmp(b, ICMP_SGE(), l, r, "ge") },
        BinaryOp::AndAnd {} => { LLVMBuildAnd(b, l, r, "and") },
        BinaryOp::OrOr {} => { LLVMBuildOr(b, l, r, "or") }
    }
}

fn codegen_binary_float(cg: Codegen, op: BinaryOp, l: RawPointer<I8>, r: RawPointer<I8>) -> RawPointer<I8> {
    let b: RawPointer<I8> = cg.builder;
    match op {
        BinaryOp::Add {} => { LLVMBuildFAdd(b, l, r, "fadd") },
        BinaryOp::Sub {} => { LLVMBuildFSub(b, l, r, "fsub") },
        BinaryOp::Mul {} => { LLVMBuildFMul(b, l, r, "fmul") },
        BinaryOp::Div {} => { LLVMBuildFDiv(b, l, r, "fdiv") },
        BinaryOp::Rem {} => { LLVMBuildFRem(b, l, r, "frem") },
        BinaryOp::Eq {} => { lang_llvm_build_fcmp(b, FCMP_OEQ(), l, r, "feq") },
        BinaryOp::NotEq {} => { lang_llvm_build_fcmp(b, FCMP_ONE(), l, r, "fne") },
        BinaryOp::Lt {} => { lang_llvm_build_fcmp(b, FCMP_OLT(), l, r, "flt") },
        BinaryOp::LtEq {} => { lang_llvm_build_fcmp(b, FCMP_OLE(), l, r, "fle") },
        BinaryOp::Gt {} => { lang_llvm_build_fcmp(b, FCMP_OGT(), l, r, "fgt") },
        BinaryOp::GtEq {} => { lang_llvm_build_fcmp(b, FCMP_OGE(), l, r, "fge") },
        BinaryOp::AndAnd {} => {
            print_str_stderr("codegen error: invalid float logical op");
            exit_process(1);
            l
        },
        BinaryOp::OrOr {} => {
            print_str_stderr("codegen error: invalid float logical op");
            exit_process(1);
            l
        }
    }
}

// ---------------------------------------------------------------------------
// Block codegen
// ---------------------------------------------------------------------------

// codegen_block: emits stmts, returns 1 if terminated (return), 0 otherwise
fn codegen_block(cg: Codegen, block: Block, ctx: FnCtx) -> I64 {
    ctx_push_scope(ctx);
    let mut i: I64 = 0;
    while i < vec_len(block.stmts) {
        let stmt: Stmt = vec_get_stmt(block.stmts, i);
        match stmt {
            Stmt::ExprStmt { expr, span } => {
                codegen_expr(cg, expr, ctx);
            },
            Stmt::ReturnStmt { value, span } => {
                let ret_val: RawPointer<I8> = match value {
                    Option::Some { value } => { codegen_expr(cg, value, ctx) },
                    Option::None {} => { lang_llvm_const_int(LLVMInt64TypeInContext(cg.context), 0, 0) }
                };
                emit_epilogue(cg, ctx);
                LLVMBuildRet(cg.builder, ret_val);
                ctx_pop_scope(ctx);
                return 1;
            }
        };
        i = i + 1;
    };
    match block.tail {
        Option::Some { value } => { codegen_expr(cg, value, ctx); },
        Option::None {} => {}
    };
    ctx_pop_scope(ctx);
    0
}

// codegen_block_value: like codegen_block but returns last value
fn codegen_block_value(cg: Codegen, block: Block, ctx: FnCtx) -> RawPointer<I8> {
    ctx_push_scope(ctx);
    let null: RawPointer<I8> = LLVMConstNull(lang_llvm_ptr_type(cg.context));
    let mut last: RawPointer<I8> = null;
    let mut terminated: Bool = false;
    let mut i: I64 = 0;
    while i < vec_len(block.stmts) {
        let stmt: Stmt = vec_get_stmt(block.stmts, i);
        match stmt {
            Stmt::ExprStmt { expr, span } => {
                last = codegen_expr(cg, expr, ctx);
            },
            Stmt::ReturnStmt { value, span } => {
                let ret_val: RawPointer<I8> = match value {
                    Option::Some { value } => { codegen_expr(cg, value, ctx) },
                    Option::None {} => { lang_llvm_const_int(LLVMInt64TypeInContext(cg.context), 0, 0) }
                };
                emit_epilogue(cg, ctx);
                LLVMBuildRet(cg.builder, ret_val);
                terminated = true;
                i = vec_len(block.stmts); // break
            }
        };
        i = i + 1;
    };
    if !terminated {
        match block.tail {
            Option::Some { value } => { last = codegen_expr(cg, value, ctx); },
            Option::None {} => {}
        };
    };
    ctx_pop_scope(ctx);
    last
}

// ---------------------------------------------------------------------------
// Expression codegen — returns LLVM value (or null for void expressions)
// ---------------------------------------------------------------------------

fn codegen_expr(cg: Codegen, expr: Expr, ctx: FnCtx) -> RawPointer<I8> {
    let null: RawPointer<I8> = LLVMConstNull(lang_llvm_ptr_type(cg.context));
    match expr {
        Expr::LetExpr { name, mutable, ty, value, span } => {
            let val: RawPointer<I8> = codegen_expr(cg, value, ctx);
            let the_ty: Type = match ty {
                Option::Some { value } => { value },
                Option::None {} => {
                    print_str_stderr("codegen error: let requires type annotation");
                    exit_process(1);
                    // unreachable
                    Type::PathType { path: vec_new(), type_args: vec_new() }
                }
            };
            let local: CgLocal = create_local_storage(cg, ctx, name, the_ty);
            store_local(cg, local, val);
            ctx_insert_local(ctx, name, local);
            if is_gc_ref_type(the_ty) {
                ctx.next_root = ctx.next_root + 1;
            };
            null
        },
        Expr::AssignExpr { target, value, span } => {
            let v: RawPointer<I8> = codegen_expr(cg, value, ctx);
            codegen_assign(cg, target, v, ctx);
            null
        },
        Expr::LitExpr { lit, span } => {
            codegen_literal(cg, lit)
        },
        Expr::PathExpr { path, span } => {
            let name: String = vec_get_str(path, vec_len(path) - 1);
            let local: CgLocal = ctx_get_local(ctx, name);
            load_local(cg, local)
        },
        Expr::FieldExpr { base, name, span } => {
            let obj_ptr: RawPointer<I8> = resolve_struct_base(cg, base, ctx);
            let type_name: String = resolve_base_type_name(cg, base, ctx);
            let layout: CgStructLayout = cg_get_struct(cg, type_name);
            let fl: CgFieldLayout = find_field_layout(layout.fields, name);
            let fp: RawPointer<I8> = field_ptr(cg, obj_ptr, fl);
            let loaded: RawPointer<I8> = LLVMBuildLoad2(cg.builder, fl.llvm_ty, fp, "field");
            if tag_is_bool(fl.lang_ty_tag) {
                let zero: RawPointer<I8> = lang_llvm_const_int(LLVMInt8TypeInContext(cg.context), 0, 0);
                return lang_llvm_build_icmp(cg.builder, ICMP_NE(), loaded, zero, "bool");
            };
            loaded
        },
        Expr::BinaryExpr { op, left, right, span } => {
            let l: RawPointer<I8> = codegen_expr(cg, left, ctx);
            let r: RawPointer<I8> = codegen_expr(cg, right, ctx);
            codegen_binary(cg, op, l, r)
        },
        Expr::UnaryExpr { op, operand, span } => {
            let v: RawPointer<I8> = codegen_expr(cg, operand, ctx);
            codegen_unary(cg, op, v)
        },
        Expr::IfExpr { cond, then_branch, else_branch, span } => {
            codegen_if(cg, cond, then_branch, else_branch, ctx)
        },
        Expr::WhileExpr { cond, body, span } => {
            codegen_while(cg, cond, body, ctx);
            null
        },
        Expr::MatchExpr { scrutinee, arms, span } => {
            codegen_match(cg, scrutinee, arms, ctx)
        },
        Expr::CallExpr { callee, args, span } => {
            codegen_call(cg, callee, args, ctx)
        },
        Expr::StructLitExpr { path, fields, span } => {
            codegen_struct_lit(cg, path, fields, ctx)
        },
        Expr::TupleExpr { items, span } => {
            print_str_stderr("codegen error: tuple construction not supported in bootstrap");
            exit_process(1);
            null
        },
        Expr::BlockExpr { block } => {
            codegen_block_value(cg, block, ctx)
        },
        Expr::BreakExpr { span } => {
            let len: I64 = vec_len(ctx.loop_stack);
            let entry: LoopEntry = vec_get_loop(ctx.loop_stack, len - 1);
            LLVMBuildBr(cg.builder, entry.break_bb);
            null
        },
        Expr::ContinueExpr { span } => {
            let len: I64 = vec_len(ctx.loop_stack);
            let entry: LoopEntry = vec_get_loop(ctx.loop_stack, len - 1);
            emit_pollcheck(cg, ctx);
            LLVMBuildBr(cg.builder, entry.cond_bb);
            null
        }
    }
}

fn codegen_assign(cg: Codegen, target: Expr, v: RawPointer<I8>, ctx: FnCtx) -> I64 {
    match target {
        Expr::PathExpr { path, span } => {
            let name: String = vec_get_str(path, vec_len(path) - 1);
            let local: CgLocal = ctx_get_local(ctx, name);
            store_local(cg, local, v);
        },
        Expr::FieldExpr { base, name, span } => {
            let obj_ptr: RawPointer<I8> = resolve_struct_base(cg, base, ctx);
            let type_name: String = resolve_base_type_name(cg, base, ctx);
            let layout: CgStructLayout = cg_get_struct(cg, type_name);
            let fl: CgFieldLayout = find_field_layout(layout.fields, name);
            let fp: RawPointer<I8> = field_ptr(cg, obj_ptr, fl);
            let store_val: RawPointer<I8> = if tag_is_bool(fl.lang_ty_tag) {
                LLVMBuildZExt(cg.builder, v, LLVMInt8TypeInContext(cg.context), "boolz")
            } else { v };
            LLVMBuildStore(cg.builder, store_val, fp);
            if tag_is_gc_ref(fl.lang_ty_tag) {
                let wb_args: Vec = vec_new();
                vec_push_raw(wb_args, ctx.thread);
                vec_push_raw(wb_args, obj_ptr);
                vec_push_raw(wb_args, v);
                lang_llvm_build_call(cg.builder, cg.gc_write_barrier_ty, cg.gc_write_barrier_fn, vec_data(wb_args), 3, "wb");
            };
        },
        _ => {
            print_str_stderr("codegen error: unsupported assignment target");
            exit_process(1);
        }
    };
    0
}

fn codegen_literal(cg: Codegen, lit: Literal) -> RawPointer<I8> {
    match lit {
        Literal::IntLiteral { text } => {
            let val: I64 = string_parse_i64(text);
            lang_llvm_const_int(LLVMInt64TypeInContext(cg.context), val, 1)
        },
        Literal::BoolLiteral { value } => {
            let val: I64 = if value { 1 } else { 0 };
            lang_llvm_const_int(LLVMInt1TypeInContext(cg.context), val, 0)
        },
        Literal::StrLiteral { text } => {
            let str_len: I64 = string_len(text);
            let const_str: RawPointer<I8> = lang_llvm_const_string(cg.context, text, str_len, 1);
            let arr_ty: RawPointer<I8> = lang_llvm_array_type(LLVMInt8TypeInContext(cg.context), str_len + 1);
            let name: String = string_concat("__str_lit_", string_from_i64(cg.str_lit_id));
            cg.str_lit_id = cg.str_lit_id + 1;
            let global: RawPointer<I8> = LLVMAddGlobal(cg.llmod, arr_ty, name);
            lang_llvm_set_initializer(global, const_str);
            let zero32: RawPointer<I8> = lang_llvm_const_int(LLVMInt32TypeInContext(cg.context), 0, 0);
            let gep_idx: Vec = vec_new();
            vec_push_raw(gep_idx, zero32);
            vec_push_raw(gep_idx, zero32);
            lang_llvm_const_gep2(arr_ty, global, vec_data(gep_idx), 2)
        },
        Literal::CharLiteral { value } => {
            lang_llvm_const_int(LLVMInt64TypeInContext(cg.context), value, 0)
        },
        Literal::UnitLiteral {} => {
            lang_llvm_const_int(LLVMInt64TypeInContext(cg.context), 0, 0)
        },
        Literal::FloatLiteral { text } => {
            print_str_stderr("codegen error: float literals not supported in bootstrap");
            exit_process(1);
            lang_llvm_const_int(LLVMInt64TypeInContext(cg.context), 0, 0)
        }
    }
}

fn codegen_unary(cg: Codegen, op: UnaryOp, v: RawPointer<I8>) -> RawPointer<I8> {
    match op {
        UnaryOp::Neg {} => {
            let vty: RawPointer<I8> = LLVMTypeOf(v);
            let kind: I64 = lang_llvm_get_type_kind(vty);
            if kind == TK_FLOAT() || kind == TK_DOUBLE() {
                return LLVMBuildFNeg(cg.builder, v, "fneg");
            };
            let zero: RawPointer<I8> = lang_llvm_const_int(LLVMInt64TypeInContext(cg.context), 0, 0);
            LLVMBuildSub(cg.builder, zero, v, "neg")
        },
        UnaryOp::Not {} => {
            let one: RawPointer<I8> = lang_llvm_const_int(LLVMInt1TypeInContext(cg.context), 1, 0);
            LLVMBuildXor(cg.builder, v, one, "not")
        }
    }
}

fn codegen_if(cg: Codegen, cond: Expr, then_branch: Block, else_branch: Option<Block>, ctx: FnCtx) -> RawPointer<I8> {
    let cond_val: RawPointer<I8> = codegen_expr(cg, cond, ctx);
    let func: RawPointer<I8> = ctx.function;
    let then_bb: RawPointer<I8> = LLVMAppendBasicBlockInContext(cg.context, func, "then");
    let else_bb: RawPointer<I8> = LLVMAppendBasicBlockInContext(cg.context, func, "else");
    let cont_bb: RawPointer<I8> = LLVMAppendBasicBlockInContext(cg.context, func, "cont");
    LLVMBuildCondBr(cg.builder, cond_val, then_bb, else_bb);

    lang_llvm_position_at_end(cg.builder, then_bb);
    let then_val: RawPointer<I8> = codegen_block_value(cg, then_branch, ctx);
    let then_val_bb: RawPointer<I8> = LLVMGetInsertBlock(cg.builder);
    if ptr_is_null(LLVMGetBasicBlockTerminator(then_val_bb)) == 1 {
        LLVMBuildBr(cg.builder, cont_bb);
    };

    lang_llvm_position_at_end(cg.builder, else_bb);
    let else_val: RawPointer<I8> = match else_branch {
        Option::Some { value } => { codegen_block_value(cg, value, ctx) },
        Option::None {} => { LLVMConstNull(lang_llvm_ptr_type(cg.context)) }
    };
    let else_val_bb: RawPointer<I8> = LLVMGetInsertBlock(cg.builder);
    if ptr_is_null(LLVMGetBasicBlockTerminator(else_val_bb)) == 1 {
        LLVMBuildBr(cg.builder, cont_bb);
    };

    lang_llvm_position_at_end(cg.builder, cont_bb);
    let null: RawPointer<I8> = LLVMConstNull(lang_llvm_ptr_type(cg.context));
    // Build phi if both branches produced values
    if ptr_is_null(then_val) == 0 {
        if ptr_is_null(else_val) == 0 {
            let phi_ty: RawPointer<I8> = LLVMTypeOf(then_val);
            let phi: RawPointer<I8> = LLVMBuildPhi(cg.builder, phi_ty, "iftmp");
            let vals: Vec = vec_new();
            vec_push_raw(vals, then_val);
            vec_push_raw(vals, else_val);
            let bbs: Vec = vec_new();
            vec_push_raw(bbs, then_val_bb);
            vec_push_raw(bbs, else_val_bb);
            lang_llvm_add_incoming(phi, vec_data(vals), vec_data(bbs), 2);
            return phi;
        };
    };
    null
}

fn codegen_while(cg: Codegen, cond: Expr, body: Block, ctx: FnCtx) -> I64 {
    let func: RawPointer<I8> = ctx.function;
    let cond_bb: RawPointer<I8> = LLVMAppendBasicBlockInContext(cg.context, func, "while.cond");
    let body_bb: RawPointer<I8> = LLVMAppendBasicBlockInContext(cg.context, func, "while.body");
    let cont_bb: RawPointer<I8> = LLVMAppendBasicBlockInContext(cg.context, func, "while.cont");
    LLVMBuildBr(cg.builder, cond_bb);

    lang_llvm_position_at_end(cg.builder, cond_bb);
    let cond_val: RawPointer<I8> = codegen_expr(cg, cond, ctx);
    LLVMBuildCondBr(cg.builder, cond_val, body_bb, cont_bb);

    lang_llvm_position_at_end(cg.builder, body_bb);
    vec_push_loop(ctx.loop_stack, LoopEntry { cond_bb: cond_bb, break_bb: cont_bb });
    codegen_block(cg, body, ctx);
    vec_set_len(ctx.loop_stack, vec_len(ctx.loop_stack) - 1);
    let cur_bb: RawPointer<I8> = LLVMGetInsertBlock(cg.builder);
    if ptr_is_null(LLVMGetBasicBlockTerminator(cur_bb)) == 1 {
        emit_pollcheck(cg, ctx);
        LLVMBuildBr(cg.builder, cond_bb);
    };

    lang_llvm_position_at_end(cg.builder, cont_bb);
    0
}

fn codegen_match(cg: Codegen, scrutinee: Expr, arms: Vec, ctx: FnCtx) -> RawPointer<I8> {
    let null: RawPointer<I8> = LLVMConstNull(lang_llvm_ptr_type(cg.context));
    // Determine enum name from first non-wildcard arm
    let mut enum_name: String = "";
    let mut ai: I64 = 0;
    while ai < vec_len(arms) {
        let arm: MatchArm = vec_get_arm(arms, ai);
        match arm.pattern {
            Pattern::PathPat { path, span } => {
                if vec_len(path) >= 2 {
                    enum_name = enum_path_and_variant(path);
                    ai = vec_len(arms);
                };
            },
            Pattern::StructPat { path, fields, span } => {
                if vec_len(path) >= 2 {
                    enum_name = enum_path_and_variant(path);
                    ai = vec_len(arms);
                };
            },
            Pattern::WildcardPat { span } => {}
        };
        ai = ai + 1;
    };

    let layout: CgEnumLayout = cg_get_enum(cg, enum_name);
    let obj_val: RawPointer<I8> = codegen_expr(cg, scrutinee, ctx);
    let tag_val: RawPointer<I8> = load_enum_tag(cg, obj_val, layout);

    let func: RawPointer<I8> = ctx.function;
    let cont_bb: RawPointer<I8> = LLVMAppendBasicBlockInContext(cg.context, func, "match.cont");
    let mut default_bb: RawPointer<I8> = cont_bb;
    let mut has_wildcard: Bool = false;
    let switch_bb: RawPointer<I8> = LLVMGetInsertBlock(cg.builder);

    // Build switch
    let num_arms: I64 = vec_len(arms);
    let switch_inst: RawPointer<I8> = lang_llvm_build_switch(cg.builder, tag_val, cont_bb, num_arms);

    // Track phi incoming values
    let phi_vals: Vec = vec_new();
    let phi_bbs: Vec = vec_new();

    let mut i: I64 = 0;
    while i < num_arms {
        let arm: MatchArm = vec_get_arm(arms, i);
        let arm_bb: RawPointer<I8> = LLVMAppendBasicBlockInContext(cg.context, func, "match.arm");

        match arm.pattern {
            Pattern::WildcardPat { span } => {
                default_bb = arm_bb;
                has_wildcard = true;
            },
            Pattern::PathPat { path, span } => {
                let vname: String = variant_name_from_path(path);
                let vlayout: CgVariantLayout = cg_get_variant(layout, vname);
                let tag_const: RawPointer<I8> = lang_llvm_const_int(LLVMInt32TypeInContext(cg.context), vlayout.tag, 0);
                lang_llvm_add_case(switch_inst, tag_const, arm_bb);
            },
            Pattern::StructPat { path, fields, span } => {
                let vname: String = variant_name_from_path(path);
                let vlayout: CgVariantLayout = cg_get_variant(layout, vname);
                let tag_const: RawPointer<I8> = lang_llvm_const_int(LLVMInt32TypeInContext(cg.context), vlayout.tag, 0);
                lang_llvm_add_case(switch_inst, tag_const, arm_bb);
            }
        };

        // Emit arm body
        lang_llvm_position_at_end(cg.builder, arm_bb);
        ctx_push_scope(ctx);

        // Bind pattern fields
        match arm.pattern {
            Pattern::StructPat { path, fields, span } => {
                let vname: String = variant_name_from_path(path);
                let vlayout: CgVariantLayout = cg_get_variant(layout, vname);
                let mut fi: I64 = 0;
                while fi < vec_len(fields) {
                    let pf: PatternField = vec_get_pfield(fields, fi);
                    let binding: String = match pf.binding {
                        Option::Some { value } => { value },
                        Option::None {} => { fi = fi + 1; continue; "" }
                    };
                    let vfl: CgVariantFieldLayout = cg_get_variant_field(vlayout, pf.name);
                    let fld_ptr: RawPointer<I8> = enum_field_ptr(cg, obj_val, vfl.field_index);
                    let loaded: RawPointer<I8> = if vfl.is_ptr {
                        let ptr_ty: RawPointer<I8> = lang_llvm_ptr_type(cg.context);
                        LLVMBuildLoad2(cg.builder, ptr_ty, fld_ptr, "enum_field")
                    } else {
                        let raw: RawPointer<I8> = LLVMBuildLoad2(cg.builder, vfl.llvm_ty, fld_ptr, "enum_field");
                        if tag_is_bool(vfl.lang_ty_tag) {
                            let zero: RawPointer<I8> = lang_llvm_const_int(LLVMInt8TypeInContext(cg.context), 0, 0);
                            lang_llvm_build_icmp(cg.builder, ICMP_NE(), raw, zero, "bool")
                        } else {
                            raw
                        }
                    };
                    // Create local for binding — build a Type from the variant field info
                    let local: CgLocal = CgLocal {
                        name: binding,
                        type_name: vfl.type_name,
                        ptr: LLVMConstNull(lang_llvm_ptr_type(cg.context)),
                        ty: vfl.llvm_ty,
                        lang_ty_tag: vfl.lang_ty_tag,
                        is_gc_ref: vfl.is_ptr
                    };
                    // For gc refs, use root slot; for raw, use entry alloca
                    let real_local: CgLocal = if vfl.is_ptr {
                        let idx: RawPointer<I8> = lang_llvm_const_int(LLVMInt32TypeInContext(cg.context), ctx.next_root, 0);
                        let ptr_ty: RawPointer<I8> = lang_llvm_ptr_type(cg.context);
                        let indices: Vec = vec_new();
                        vec_push_raw(indices, idx);
                        let slot_ptr: RawPointer<I8> = lang_llvm_build_gep2(cg.builder, ptr_ty, ctx.root_base, vec_data(indices), 1, "root_slot");
                        CgLocal { name: binding, type_name: vfl.type_name, ptr: slot_ptr, ty: ptr_ty, lang_ty_tag: vfl.lang_ty_tag, is_gc_ref: true }
                    } else {
                        let ptr: RawPointer<I8> = create_entry_alloca(cg, ctx.function, binding, vfl.lang_ty_tag);
                        let lty: RawPointer<I8> = llvm_type_for_tag(cg, vfl.lang_ty_tag);
                        CgLocal { name: binding, type_name: vfl.type_name, ptr: ptr, ty: lty, lang_ty_tag: vfl.lang_ty_tag, is_gc_ref: false }
                    };
                    store_local(cg, real_local, loaded);
                    ctx_insert_local(ctx, binding, real_local);
                    if vfl.is_ptr {
                        ctx.next_root = ctx.next_root + 1;
                    };
                    fi = fi + 1;
                };
            },
            Pattern::PathPat { path, span } => {},
            Pattern::WildcardPat { span } => {}
        };

        let value: RawPointer<I8> = codegen_expr(cg, arm.body, ctx);
        let value_bb: RawPointer<I8> = LLVMGetInsertBlock(cg.builder);
        if ptr_is_null(LLVMGetBasicBlockTerminator(value_bb)) == 1 {
            LLVMBuildBr(cg.builder, cont_bb);
        };
        if ptr_is_null(value) == 0 {
            vec_push_raw(phi_vals, value);
            vec_push_raw(phi_bbs, value_bb);
        };
        ctx_pop_scope(ctx);
        i = i + 1;
    };

    // Update switch default
    // We can't easily change default after creation, but we built with cont_bb as default.
    // If there's a wildcard, we need to redirect. Rebuild won't work, so just handle
    // the wildcard arm — the arm_bb IS connected via the default.
    // Actually the switch was built with cont_bb as default. If wildcard was found,
    // we need to patch it. Since we can't in .lang, let's re-emit from switch_bb.
    // Simpler approach: always build switch after knowing default.
    // For now, this basic approach works if wildcard arm is matched through default_bb.

    lang_llvm_position_at_end(cg.builder, cont_bb);
    if vec_len(phi_vals) > 0 {
        // Add a zero value from switch_bb for default path if needed
        if !has_wildcard {
            if vec_len(phi_vals) > 0 {
                let first_val: RawPointer<I8> = vec_get(phi_vals, 0);
                let zero_ty: RawPointer<I8> = LLVMTypeOf(first_val);
                let zero_val: RawPointer<I8> = lang_llvm_const_int(zero_ty, 0, 0);
                vec_push_raw(phi_vals, zero_val);
                vec_push_raw(phi_bbs, switch_bb);
            };
        };
        let phi_ty: RawPointer<I8> = LLVMTypeOf(vec_get(phi_vals, 0));
        let phi: RawPointer<I8> = LLVMBuildPhi(cg.builder, phi_ty, "matchtmp");
        lang_llvm_add_incoming(phi, vec_data(phi_vals), vec_data(phi_bbs), vec_len(phi_vals));
        return phi;
    };
    null
}

fn codegen_call(cg: Codegen, callee: Expr, args: Vec, ctx: FnCtx) -> RawPointer<I8> {
    // Check if this is an enum variant constructor
    match callee {
        Expr::PathExpr { path, span } => {
            if vec_len(path) >= 2 {
                let en: String = enum_path_and_variant(path);
                if cg_find_enum(cg, en) == 1 {
                    return codegen_enum_tuple_construct(cg, en, variant_name_from_path(path), args, ctx);
                };
            };
            // Regular function call
            let key: String = path_to_string(path);
            let mut fn_val: RawPointer<I8> = LLVMConstNull(lang_llvm_ptr_type(cg.context));
            let mut fn_ty: RawPointer<I8> = LLVMConstNull(lang_llvm_ptr_type(cg.context));
            let mut pass_thread: Bool = false;
            if cg_find_fn(cg, key) == 1 {
                let entry: CgFnEntry = cg_get_fn(cg, key);
                fn_val = entry.fn_val;
                fn_ty = entry.fn_ty;
                pass_thread = true;
            } else {
                if cg_find_extern(cg, key) == 1 {
                    let entry: CgFnEntry = cg_get_extern(cg, key);
                    fn_val = entry.fn_val;
                    fn_ty = entry.fn_ty;
                } else {
                    print_str_stderr(string_concat("codegen error: unknown function: ", key));
                    exit_process(1);
                };
            };
            let arg_vals: Vec = vec_new();
            if pass_thread { vec_push_raw(arg_vals, ctx.thread); };
            let mut i: I64 = 0;
            while i < vec_len(args) {
                let arg: Expr = vec_get_expr(args, i);
                let val: RawPointer<I8> = codegen_expr(cg, arg, ctx);
                vec_push_raw(arg_vals, val);
                i = i + 1;
            };
            let call: RawPointer<I8> = lang_llvm_build_call(cg.builder, fn_ty, fn_val, vec_data(arg_vals), vec_len(arg_vals), "call");
            emit_pollcheck(cg, ctx);
            call
        },
        _ => {
            print_str_stderr("codegen error: callee must be path");
            exit_process(1);
            LLVMConstNull(lang_llvm_ptr_type(cg.context))
        }
    }
}

fn codegen_enum_tuple_construct(cg: Codegen, enum_name: String, vname: String, args: Vec, ctx: FnCtx) -> RawPointer<I8> {
    let layout: CgEnumLayout = cg_get_enum(cg, enum_name);
    let vlayout: CgVariantLayout = cg_get_variant(layout, vname);

    let i64_ty: RawPointer<I8> = LLVMInt64TypeInContext(cg.context);
    let alloc_args: Vec = vec_new();
    vec_push_raw(alloc_args, lang_llvm_const_int(i64_ty, layout.field_count, 0));
    vec_push_raw(alloc_args, lang_llvm_const_int(i64_ty, layout.ptr_field_count, 0));
    vec_push_raw(alloc_args, lang_llvm_const_int(i64_ty, layout.type_id, 0));
    let obj_ptr: RawPointer<I8> = lang_llvm_build_call(cg.builder, cg.gc_alloc_ty, cg.gc_alloc_fn, vec_data(alloc_args), 3, "alloc_enum");

    // Write tag as i64 at tag field index (ptr_field_count)
    let tag_ptr: RawPointer<I8> = gc_field_ptr(cg, obj_ptr, layout.ptr_field_count);
    let tag_val: RawPointer<I8> = lang_llvm_const_int(i64_ty, vlayout.tag, 0);
    LLVMBuildStore(cg.builder, tag_val, tag_ptr);

    let mut i: I64 = 0;
    while i < vec_len(args) {
        let arg: Expr = vec_get_expr(args, i);
        let arg_val: RawPointer<I8> = codegen_expr(cg, arg, ctx);
        let vfl: CgVariantFieldLayout = vec_get_cgvfl(vlayout.fields, i);
        let fp: RawPointer<I8> = enum_field_ptr(cg, obj_ptr, vfl.field_index);
        let sv: RawPointer<I8> = if tag_is_bool(vfl.lang_ty_tag) {
            LLVMBuildZExt(cg.builder, arg_val, LLVMInt8TypeInContext(cg.context), "boolz")
        } else { arg_val };
        LLVMBuildStore(cg.builder, sv, fp);
        i = i + 1;
    };
    emit_pollcheck(cg, ctx);
    obj_ptr
}

fn codegen_struct_lit(cg: Codegen, path: Vec, fields: Vec, ctx: FnCtx) -> RawPointer<I8> {
    // Check if it's an enum variant struct literal
    if vec_len(path) >= 2 {
        let en: String = enum_path_and_variant(path);
        if cg_find_enum(cg, en) == 1 {
            return codegen_enum_struct_construct(cg, en, variant_name_from_path(path), fields, ctx);
        };
    };

    // Regular struct literal
    let name: String = path_to_string(path);
    let layout: CgStructLayout = cg_get_struct(cg, name);
    let i64_ty: RawPointer<I8> = LLVMInt64TypeInContext(cg.context);
    let alloc_args: Vec = vec_new();
    vec_push_raw(alloc_args, lang_llvm_const_int(i64_ty, layout.field_count, 0));
    vec_push_raw(alloc_args, lang_llvm_const_int(i64_ty, layout.ptr_field_count, 0));
    vec_push_raw(alloc_args, lang_llvm_const_int(i64_ty, layout.type_id, 0));
    let obj_ptr: RawPointer<I8> = lang_llvm_build_call(cg.builder, cg.gc_alloc_ty, cg.gc_alloc_fn, vec_data(alloc_args), 3, "alloc");

    let mut i: I64 = 0;
    while i < vec_len(fields) {
        let sf: StructLitField = vec_get_slfield(fields, i);
        let fl: CgFieldLayout = find_field_layout(layout.fields, sf.name);
        let value: RawPointer<I8> = codegen_expr(cg, sf.value, ctx);
        let fp: RawPointer<I8> = field_ptr(cg, obj_ptr, fl);
        let sv: RawPointer<I8> = if tag_is_bool(fl.lang_ty_tag) {
            LLVMBuildZExt(cg.builder, value, LLVMInt8TypeInContext(cg.context), "boolz")
        } else { value };
        LLVMBuildStore(cg.builder, sv, fp);
        i = i + 1;
    };
    emit_pollcheck(cg, ctx);
    obj_ptr
}

fn codegen_enum_struct_construct(cg: Codegen, enum_name: String, vname: String, fields: Vec, ctx: FnCtx) -> RawPointer<I8> {
    let layout: CgEnumLayout = cg_get_enum(cg, enum_name);
    let vlayout: CgVariantLayout = cg_get_variant(layout, vname);

    let i64_ty: RawPointer<I8> = LLVMInt64TypeInContext(cg.context);
    let alloc_args: Vec = vec_new();
    vec_push_raw(alloc_args, lang_llvm_const_int(i64_ty, layout.field_count, 0));
    vec_push_raw(alloc_args, lang_llvm_const_int(i64_ty, layout.ptr_field_count, 0));
    vec_push_raw(alloc_args, lang_llvm_const_int(i64_ty, layout.type_id, 0));
    let obj_ptr: RawPointer<I8> = lang_llvm_build_call(cg.builder, cg.gc_alloc_ty, cg.gc_alloc_fn, vec_data(alloc_args), 3, "alloc_enum");

    // Write tag as i64 at tag field index (ptr_field_count)
    let tag_ptr: RawPointer<I8> = gc_field_ptr(cg, obj_ptr, layout.ptr_field_count);
    let tag_val: RawPointer<I8> = lang_llvm_const_int(i64_ty, vlayout.tag, 0);
    LLVMBuildStore(cg.builder, tag_val, tag_ptr);

    let mut i: I64 = 0;
    while i < vec_len(fields) {
        let sf: StructLitField = vec_get_slfield(fields, i);
        let vfl: CgVariantFieldLayout = cg_get_variant_field(vlayout, sf.name);
        let value: RawPointer<I8> = codegen_expr(cg, sf.value, ctx);
        let fp: RawPointer<I8> = enum_field_ptr(cg, obj_ptr, vfl.field_index);
        let sv: RawPointer<I8> = if tag_is_bool(vfl.lang_ty_tag) {
            LLVMBuildZExt(cg.builder, value, LLVMInt8TypeInContext(cg.context), "boolz")
        } else { value };
        LLVMBuildStore(cg.builder, sv, fp);
        i = i + 1;
    };
    emit_pollcheck(cg, ctx);
    obj_ptr
}

// ---------------------------------------------------------------------------
// Function definition
// ---------------------------------------------------------------------------

fn define_functions(cg: Codegen, modules: Vec) -> I64 {
    let mut mi: I64 = 0;
    while mi < vec_len(modules) {
        let m: Module = vec_get_module(modules, mi);
        let mut ii: I64 = 0;
        while ii < vec_len(m.items) {
            let item: Item = vec_get_item(m.items, ii);
            match item {
                Item::FnItem { decl } => {
                    let fname: String = full_item_name(m.path, decl.name);
                    define_fn(cg, fname, decl);
                },
                Item::StructItem { decl } => {},
                Item::EnumItem { decl } => {},
                Item::ExternFnItem { decl } => {},
                Item::UseItem { decl } => {},
                Item::LinkItem { decl } => {}
            };
            ii = ii + 1;
        };
        mi = mi + 1;
    };
    0
}

fn define_fn(cg: Codegen, full_name: String, f: FnDecl) -> I64 {
    let entry_obj: CgFnEntry = cg_get_fn(cg, full_name);
    let function: RawPointer<I8> = entry_obj.fn_val;
    let entry_bb: RawPointer<I8> = LLVMAppendBasicBlockInContext(cg.context, function, "entry");
    lang_llvm_position_at_end(cg.builder, entry_bb);

    let thread: RawPointer<I8> = lang_llvm_get_param(function, 0);
    let num_roots: I64 = count_roots_in_fn(cg, f.params, f.body);
    let ft: RawPointer<I8> = make_frame_type(cg, num_roots);
    let mut ctx: FnCtx = emit_prologue(cg, function, thread, full_name, num_roots, ft);
    ctx.function = function;

    // Store params
    let mut param_root_index: I64 = 0;
    let mut i: I64 = 0;
    while i < vec_len(f.params) {
        let p: Param = vec_get_param(f.params, i);
        let local: CgLocal = create_local_storage(cg, ctx, p.name, p.ty);
        let arg: RawPointer<I8> = lang_llvm_get_param(function, i + 1);
        store_local(cg, local, arg);
        ctx_insert_local(ctx, p.name, local);
        if is_gc_ref_type(p.ty) {
            ctx.next_root = ctx.next_root + 1;
        };
        i = i + 1;
    };

    let value: RawPointer<I8> = codegen_block_value(cg, f.body, ctx);
    let cur_bb: RawPointer<I8> = LLVMGetInsertBlock(cg.builder);
    if ptr_is_null(LLVMGetBasicBlockTerminator(cur_bb)) == 1 {
        let ret_val: RawPointer<I8> = if ptr_is_null(value) == 1 {
            lang_llvm_const_int(LLVMInt64TypeInContext(cg.context), 0, 0)
        } else { value };
        emit_epilogue(cg, ctx);
        LLVMBuildRet(cg.builder, ret_val);
    };
    0
}

// ---------------------------------------------------------------------------
// AOT wrapper main
// ---------------------------------------------------------------------------

fn emit_aot_wrapper_main(cg: Codegen) -> I64 {
    let lang_main_entry: CgFnEntry = cg_get_fn(cg, "main");
    let lang_main: RawPointer<I8> = lang_main_entry.fn_val;
    let lang_main_ty: RawPointer<I8> = lang_main_entry.fn_ty;

    let ctx: RawPointer<I8> = cg.context;
    let i32_ty: RawPointer<I8> = LLVMInt32TypeInContext(ctx);
    let ptr_ty: RawPointer<I8> = lang_llvm_ptr_type(ctx);

    let wrapper_params: Vec = vec_new();
    vec_push_raw(wrapper_params, i32_ty);
    vec_push_raw(wrapper_params, ptr_ty);
    let wrapper_ty: RawPointer<I8> = lang_llvm_function_type(i32_ty, vec_data(wrapper_params), 2, 0);
    let wrapper: RawPointer<I8> = LLVMAddFunction(cg.llmod, "main", wrapper_ty);

    let entry_bb: RawPointer<I8> = LLVMAppendBasicBlockInContext(ctx, wrapper, "entry");
    lang_llvm_position_at_end(cg.builder, entry_bb);

    let argc: RawPointer<I8> = lang_llvm_get_param(wrapper, 0);
    let argv: RawPointer<I8> = lang_llvm_get_param(wrapper, 1);

    // Call rt_init_args(argc, argv)
    let void_ty: RawPointer<I8> = LLVMVoidTypeInContext(ctx);
    let init_params: Vec = vec_new();
    vec_push_raw(init_params, i32_ty);
    vec_push_raw(init_params, ptr_ty);
    let init_ty: RawPointer<I8> = lang_llvm_function_type(void_ty, vec_data(init_params), 2, 0);
    let init_fn: RawPointer<I8> = LLVMGetNamedFunction(cg.llmod, "rt_init_args");
    let actual_init: RawPointer<I8> = if ptr_is_null(init_fn) == 1 {
        LLVMAddFunction(cg.llmod, "rt_init_args", init_ty)
    } else { init_fn };
    let init_args: Vec = vec_new();
    vec_push_raw(init_args, argc);
    vec_push_raw(init_args, argv);
    lang_llvm_build_call(cg.builder, init_ty, actual_init, vec_data(init_args), 2, "init_args");

    // Call gc_init()
    let gc_init_params: Vec = vec_new();
    let gc_init_ty: RawPointer<I8> = lang_llvm_function_type(void_ty, vec_data(gc_init_params), 0, 0);
    let gc_init_fn: RawPointer<I8> = if ptr_is_null(LLVMGetNamedFunction(cg.llmod, "gc_init")) == 1 {
        LLVMAddFunction(cg.llmod, "gc_init", gc_init_ty)
    } else { LLVMGetNamedFunction(cg.llmod, "gc_init") };
    let gc_init_args: Vec = vec_new();
    lang_llvm_build_call(cg.builder, gc_init_ty, gc_init_fn, vec_data(gc_init_args), 0, "gc_init");

    // Alloca thread struct
    let thread_alloca: RawPointer<I8> = LLVMBuildAlloca(cg.builder, cg.thread_struct_ty, "thread");
    let top_ptr: RawPointer<I8> = lang_llvm_build_struct_gep2(cg.builder, cg.thread_struct_ty, thread_alloca, 0, "thread.top");
    let state_ptr: RawPointer<I8> = lang_llvm_build_struct_gep2(cg.builder, cg.thread_struct_ty, thread_alloca, 1, "thread.state");
    let pad_ptr: RawPointer<I8> = lang_llvm_build_struct_gep2(cg.builder, cg.thread_struct_ty, thread_alloca, 2, "thread.pad");
    LLVMBuildStore(cg.builder, LLVMConstNull(ptr_ty), top_ptr);
    LLVMBuildStore(cg.builder, lang_llvm_const_int(i32_ty, 0, 0), state_ptr);
    LLVMBuildStore(cg.builder, lang_llvm_const_int(i32_ty, 0, 0), pad_ptr);

    let thread_ptr: RawPointer<I8> = LLVMBuildBitCast(cg.builder, thread_alloca, ptr_ty, "thread_ptr");

    // Call gc_set_thread(thread_ptr)
    let set_thread_params: Vec = vec_new();
    vec_push_raw(set_thread_params, ptr_ty);
    let set_thread_ty: RawPointer<I8> = lang_llvm_function_type(void_ty, vec_data(set_thread_params), 1, 0);
    let set_thread_fn: RawPointer<I8> = if ptr_is_null(LLVMGetNamedFunction(cg.llmod, "gc_set_thread")) == 1 {
        LLVMAddFunction(cg.llmod, "gc_set_thread", set_thread_ty)
    } else { LLVMGetNamedFunction(cg.llmod, "gc_set_thread") };
    let set_thread_args: Vec = vec_new();
    vec_push_raw(set_thread_args, thread_ptr);
    lang_llvm_build_call(cg.builder, set_thread_ty, set_thread_fn, vec_data(set_thread_args), 1, "set_thread");

    let call_args: Vec = vec_new();
    vec_push_raw(call_args, thread_ptr);
    let call: RawPointer<I8> = lang_llvm_build_call(cg.builder, lang_main_ty, lang_main, vec_data(call_args), 1, "lang_main");
    let ret_i32: RawPointer<I8> = LLVMBuildTrunc(cg.builder, call, i32_ty, "ret");
    LLVMBuildRet(cg.builder, ret_i32);
    0
}

// ---------------------------------------------------------------------------
// llvm.compiler.used — protect GC metadata globals from optimization
// ---------------------------------------------------------------------------

fn LINKAGE_APPENDING() -> I64 { 7 }

fn emit_compiler_used(cg: Codegen) -> I64 {
    let count: I64 = vec_len(cg.compiler_used);
    if count == 0 { return 0; };

    let ptr_ty: RawPointer<I8> = lang_llvm_ptr_type(cg.context);
    let arr_ty: RawPointer<I8> = lang_llvm_array_type(ptr_ty, count);
    let arr_val: RawPointer<I8> = lang_llvm_const_array(ptr_ty, vec_data(cg.compiler_used), count);
    let global: RawPointer<I8> = LLVMAddGlobal(cg.llmod, arr_ty, "llvm.compiler.used");
    lang_llvm_set_initializer(global, arr_val);
    lang_llvm_set_linkage(global, LINKAGE_APPENDING());
    lang_llvm_set_section(global, "llvm.metadata");
    0
}

// ---------------------------------------------------------------------------
// Compile to object file
// ---------------------------------------------------------------------------

fn compile_to_object(cg: Codegen, output_path: String) -> I64 {
    lang_llvm_init_native_target();
    lang_llvm_init_native_asm_printer();

    let triple: String = LLVMGetDefaultTargetTriple();
    let target: RawPointer<I8> = lang_llvm_get_target_from_triple(triple);
    let cpu: String = LLVMGetHostCPUName();
    let features: String = LLVMGetHostCPUFeatures();
    let machine: RawPointer<I8> = lang_llvm_create_target_machine(target, triple, cpu, features);
    lang_llvm_set_module_target(cg.llmod, machine);

    let result: I64 = lang_llvm_emit_to_file(machine, cg.llmod, output_path);
    if result != 0 {
        print_str_stderr("codegen error: failed to emit object file");
        exit_process(1);
    };
    0
}

// ---------------------------------------------------------------------------
// Entry point: codegen_modules
// ---------------------------------------------------------------------------

fn codegen_modules(modules: Vec, output_path: String) -> I64 {
    let cg: Codegen = new_codegen();
    declare_structs(cg, modules);
    declare_enums(cg, modules);
    declare_functions(cg, modules);
    define_functions(cg, modules);
    emit_aot_wrapper_main(cg);
    emit_compiler_used(cg);
    compile_to_object(cg, output_path);
    0
}
