// ---------------------------------------------------------------------------
// Codegen pass â€” emit LLVM IR and compile to object file
// ---------------------------------------------------------------------------

use ast::Option;
use ast::Span;
use ast::Module;
use ast::Item;
use ast::FnDecl;
use ast::ExternFnDecl;
use ast::StructDecl;
use ast::EnumDecl;
use ast::EnumVariant;
use ast::EnumVariantKind;
use ast::Field;
use ast::Param;
use ast::Block;
use ast::Stmt;
use ast::Expr;
use ast::Literal;
use ast::BinaryOp;
use ast::UnaryOp;
use ast::Type;
use ast::Pattern;
use ast::MatchArm;
use ast::PatternField;
use ast::StructLitField;
use ast::CgFieldLayout;
use ast::CgStructLayout;
use ast::CgVariantFieldLayout;
use ast::CgVariantLayout;
use ast::CgEnumLayout;
use ast::CgLocal;
use ast::CgFnEntry;
use ast::LoopEntry;

// -- vec ops ---------------------------------------------------------------
extern fn vec_new() -> RawPointer<I8>;
extern fn vec_len(v: RawPointer<I8>) -> I64;
extern fn vec_push(v: RawPointer<I8>, item: RawPointer<I8>) -> I64;
extern fn vec_get(v: RawPointer<I8>, index: I64) -> RawPointer<I8>;
extern fn vec_set_len(v: RawPointer<I8>, new_len: I64) -> I64;
extern fn vec_data(v: RawPointer<I8>) -> RawPointer<I8>;

extern fn vec_push_str(v: RawPointer<I8>, item: String) -> I64;
extern fn vec_get_str(v: RawPointer<I8>, index: I64) -> String;
extern fn vec_push_vec(v: RawPointer<I8>, item: RawPointer<I8>) -> I64;
extern fn vec_get_vec(v: RawPointer<I8>, index: I64) -> RawPointer<I8>;
extern fn vec_get_module(v: RawPointer<I8>, index: I64) -> Module;
extern fn vec_get_item(v: RawPointer<I8>, index: I64) -> Item;
extern fn vec_get_field(v: RawPointer<I8>, index: I64) -> Field;
extern fn vec_get_param(v: RawPointer<I8>, index: I64) -> Param;
extern fn vec_get_variant(v: RawPointer<I8>, index: I64) -> EnumVariant;
extern fn vec_get_type(v: RawPointer<I8>, index: I64) -> Type;
extern fn vec_get_expr(v: RawPointer<I8>, index: I64) -> Expr;
extern fn vec_get_arm(v: RawPointer<I8>, index: I64) -> MatchArm;
extern fn vec_get_stmt(v: RawPointer<I8>, index: I64) -> Stmt;
extern fn vec_get_pfield(v: RawPointer<I8>, index: I64) -> PatternField;
extern fn vec_get_slfield(v: RawPointer<I8>, index: I64) -> StructLitField;

// codegen-specific vec aliases
extern fn vec_push_cgfn(v: RawPointer<I8>, item: CgFnEntry) -> I64;
extern fn vec_get_cgfn(v: RawPointer<I8>, index: I64) -> CgFnEntry;
extern fn vec_push_cgsl(v: RawPointer<I8>, item: CgStructLayout) -> I64;
extern fn vec_get_cgsl(v: RawPointer<I8>, index: I64) -> CgStructLayout;
extern fn vec_push_cgel(v: RawPointer<I8>, item: CgEnumLayout) -> I64;
extern fn vec_get_cgel(v: RawPointer<I8>, index: I64) -> CgEnumLayout;
extern fn vec_push_cgfl(v: RawPointer<I8>, item: CgFieldLayout) -> I64;
extern fn vec_get_cgfl(v: RawPointer<I8>, index: I64) -> CgFieldLayout;
extern fn vec_push_cgvfl(v: RawPointer<I8>, item: CgVariantFieldLayout) -> I64;
extern fn vec_get_cgvfl(v: RawPointer<I8>, index: I64) -> CgVariantFieldLayout;
extern fn vec_push_cgvl(v: RawPointer<I8>, item: CgVariantLayout) -> I64;
extern fn vec_get_cgvl(v: RawPointer<I8>, index: I64) -> CgVariantLayout;
extern fn vec_push_cgloc(v: RawPointer<I8>, item: CgLocal) -> I64;
extern fn vec_get_cgloc(v: RawPointer<I8>, index: I64) -> CgLocal;
extern fn vec_push_loop(v: RawPointer<I8>, item: LoopEntry) -> I64;
extern fn vec_get_loop(v: RawPointer<I8>, index: I64) -> LoopEntry;

// -- string ops ------------------------------------------------------------
extern fn string_eq(a: String, b: String) -> I64;
extern fn string_concat(a: String, b: String) -> String;
extern fn string_from_i64(v: I64) -> String;
extern fn string_parse_i64(s: String) -> I64;
extern fn string_len(s: String) -> I64;
extern fn print_str(s: String) -> I64;
extern fn print_str_stderr(s: String) -> I64;
extern fn exit_process(code: I64) -> I64;
extern fn write_file(path: String, data: String, len: I64) -> I64;
extern fn system_cmd(cmd: String) -> I64;

// -- LLVM wrappers ---------------------------------------------------------
extern fn llvm_context_create() -> RawPointer<I8>;
extern fn llvm_module_create(name: String, ctx: RawPointer<I8>) -> RawPointer<I8>;
extern fn llvm_create_builder(ctx: RawPointer<I8>) -> RawPointer<I8>;
extern fn llvm_dispose_builder(b: RawPointer<I8>) -> I64;
extern fn llvm_dispose_module(m: RawPointer<I8>) -> I64;
extern fn llvm_context_dispose(ctx: RawPointer<I8>) -> I64;

extern fn llvm_int1_type(ctx: RawPointer<I8>) -> RawPointer<I8>;
extern fn llvm_int8_type(ctx: RawPointer<I8>) -> RawPointer<I8>;
extern fn llvm_int16_type(ctx: RawPointer<I8>) -> RawPointer<I8>;
extern fn llvm_int32_type(ctx: RawPointer<I8>) -> RawPointer<I8>;
extern fn llvm_int64_type(ctx: RawPointer<I8>) -> RawPointer<I8>;
extern fn llvm_float_type(ctx: RawPointer<I8>) -> RawPointer<I8>;
extern fn llvm_double_type(ctx: RawPointer<I8>) -> RawPointer<I8>;
extern fn llvm_ptr_type(ctx: RawPointer<I8>) -> RawPointer<I8>;
extern fn llvm_void_type(ctx: RawPointer<I8>) -> RawPointer<I8>;
extern fn llvm_function_type(ret: RawPointer<I8>, params: RawPointer<I8>, param_count: I64, is_vararg: I64) -> RawPointer<I8>;
extern fn llvm_struct_type(ctx: RawPointer<I8>, elements: RawPointer<I8>, count: I64, packed: I64) -> RawPointer<I8>;
extern fn llvm_array_type(elem_ty: RawPointer<I8>, count: I64) -> RawPointer<I8>;

extern fn llvm_const_int(ty: RawPointer<I8>, val: I64, sign_extend: I64) -> RawPointer<I8>;
extern fn llvm_const_null(ty: RawPointer<I8>) -> RawPointer<I8>;
extern fn llvm_const_string(ctx: RawPointer<I8>, str: String, len: I64, null_terminate: I64) -> RawPointer<I8>;
extern fn llvm_const_named_struct(struct_ty: RawPointer<I8>, vals: RawPointer<I8>, count: I64) -> RawPointer<I8>;
extern fn llvm_const_array(elem_ty: RawPointer<I8>, vals: RawPointer<I8>, count: I64) -> RawPointer<I8>;
extern fn llvm_const_gep2(ty: RawPointer<I8>, val: RawPointer<I8>, indices: RawPointer<I8>, count: I64) -> RawPointer<I8>;

extern fn llvm_add_function(m: RawPointer<I8>, name: String, fn_ty: RawPointer<I8>) -> RawPointer<I8>;
extern fn llvm_get_named_function(m: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn llvm_add_global(m: RawPointer<I8>, ty: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn llvm_set_initializer(global: RawPointer<I8>, val: RawPointer<I8>) -> I64;
extern fn llvm_get_value_type(val: RawPointer<I8>) -> RawPointer<I8>;
extern fn llvm_get_global_value_type(val: RawPointer<I8>) -> RawPointer<I8>;
extern fn llvm_get_element_type(ty: RawPointer<I8>) -> RawPointer<I8>;
extern fn llvm_get_type_kind(ty: RawPointer<I8>) -> I64;
extern fn llvm_pointer_type(ty: RawPointer<I8>) -> RawPointer<I8>;

extern fn llvm_get_param(f: RawPointer<I8>, index: I64) -> RawPointer<I8>;
extern fn llvm_count_params(f: RawPointer<I8>) -> I64;
extern fn llvm_append_basic_block(ctx: RawPointer<I8>, f: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn llvm_get_first_basic_block(f: RawPointer<I8>) -> RawPointer<I8>;
extern fn llvm_get_bb_terminator(bb: RawPointer<I8>) -> RawPointer<I8>;
extern fn llvm_get_insert_block(builder: RawPointer<I8>) -> RawPointer<I8>;
extern fn llvm_get_first_instruction(bb: RawPointer<I8>) -> RawPointer<I8>;
extern fn llvm_is_null(val: RawPointer<I8>) -> I64;

extern fn llvm_position_at_end(builder: RawPointer<I8>, bb: RawPointer<I8>) -> I64;
extern fn llvm_position_before(builder: RawPointer<I8>, instr: RawPointer<I8>) -> I64;

extern fn llvm_build_alloca(builder: RawPointer<I8>, ty: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn llvm_build_load(builder: RawPointer<I8>, ty: RawPointer<I8>, ptr: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn llvm_build_store(builder: RawPointer<I8>, val: RawPointer<I8>, ptr: RawPointer<I8>) -> RawPointer<I8>;
extern fn llvm_build_call(builder: RawPointer<I8>, fn_ty: RawPointer<I8>, f: RawPointer<I8>, args: RawPointer<I8>, arg_count: I64, name: String) -> RawPointer<I8>;
extern fn llvm_build_ret(builder: RawPointer<I8>, val: RawPointer<I8>) -> RawPointer<I8>;
extern fn llvm_build_ret_void(builder: RawPointer<I8>) -> RawPointer<I8>;
extern fn llvm_build_br(builder: RawPointer<I8>, dest: RawPointer<I8>) -> RawPointer<I8>;
extern fn llvm_build_cond_br(builder: RawPointer<I8>, cond: RawPointer<I8>, then_bb: RawPointer<I8>, else_bb: RawPointer<I8>) -> RawPointer<I8>;
extern fn llvm_build_switch(builder: RawPointer<I8>, val: RawPointer<I8>, default_bb: RawPointer<I8>, num_cases: I64) -> RawPointer<I8>;
extern fn llvm_build_phi(builder: RawPointer<I8>, ty: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn llvm_build_gep2(builder: RawPointer<I8>, ty: RawPointer<I8>, ptr: RawPointer<I8>, indices: RawPointer<I8>, count: I64, name: String) -> RawPointer<I8>;
extern fn llvm_build_inbounds_gep2(builder: RawPointer<I8>, ty: RawPointer<I8>, ptr: RawPointer<I8>, indices: RawPointer<I8>, count: I64, name: String) -> RawPointer<I8>;
extern fn llvm_build_bitcast(builder: RawPointer<I8>, val: RawPointer<I8>, dest_ty: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn llvm_build_struct_gep2(builder: RawPointer<I8>, struct_ty: RawPointer<I8>, ptr: RawPointer<I8>, idx: I64, name: String) -> RawPointer<I8>;
extern fn llvm_build_memset(builder: RawPointer<I8>, ptr: RawPointer<I8>, val: RawPointer<I8>, len: RawPointer<I8>, align: I64) -> RawPointer<I8>;
extern fn llvm_build_global_string_ptr(builder: RawPointer<I8>, str: String, name: String) -> RawPointer<I8>;

extern fn llvm_build_add(builder: RawPointer<I8>, l: RawPointer<I8>, r: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn llvm_build_sub(builder: RawPointer<I8>, l: RawPointer<I8>, r: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn llvm_build_mul(builder: RawPointer<I8>, l: RawPointer<I8>, r: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn llvm_build_sdiv(builder: RawPointer<I8>, l: RawPointer<I8>, r: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn llvm_build_srem(builder: RawPointer<I8>, l: RawPointer<I8>, r: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn llvm_build_icmp(builder: RawPointer<I8>, predicate: I64, l: RawPointer<I8>, r: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn llvm_build_and(builder: RawPointer<I8>, l: RawPointer<I8>, r: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn llvm_build_or(builder: RawPointer<I8>, l: RawPointer<I8>, r: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn llvm_build_xor(builder: RawPointer<I8>, l: RawPointer<I8>, r: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn llvm_build_zext(builder: RawPointer<I8>, val: RawPointer<I8>, dest_ty: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn llvm_build_trunc(builder: RawPointer<I8>, val: RawPointer<I8>, dest_ty: RawPointer<I8>, name: String) -> RawPointer<I8>;

extern fn llvm_build_fadd(builder: RawPointer<I8>, l: RawPointer<I8>, r: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn llvm_build_fsub(builder: RawPointer<I8>, l: RawPointer<I8>, r: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn llvm_build_fmul(builder: RawPointer<I8>, l: RawPointer<I8>, r: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn llvm_build_fdiv(builder: RawPointer<I8>, l: RawPointer<I8>, r: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn llvm_build_frem(builder: RawPointer<I8>, l: RawPointer<I8>, r: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn llvm_build_fcmp(builder: RawPointer<I8>, predicate: I64, l: RawPointer<I8>, r: RawPointer<I8>, name: String) -> RawPointer<I8>;
extern fn llvm_build_fneg(builder: RawPointer<I8>, val: RawPointer<I8>, name: String) -> RawPointer<I8>;

extern fn llvm_add_incoming(phi: RawPointer<I8>, vals: RawPointer<I8>, blocks: RawPointer<I8>, count: I64) -> I64;
extern fn llvm_add_case(switch: RawPointer<I8>, val: RawPointer<I8>, dest: RawPointer<I8>) -> I64;
extern fn llvm_set_volatile(instr: RawPointer<I8>, is_volatile: I64) -> I64;

extern fn llvm_init_native_target() -> I64;
extern fn llvm_init_native_asm_printer() -> I64;
extern fn llvm_get_default_triple() -> String;
extern fn llvm_get_target_from_triple(triple: String) -> RawPointer<I8>;
extern fn llvm_get_host_cpu_name() -> String;
extern fn llvm_get_host_cpu_features() -> String;
extern fn llvm_create_target_machine(target: RawPointer<I8>, triple: String, cpu: String, features: String) -> RawPointer<I8>;
extern fn llvm_set_module_target(m: RawPointer<I8>, machine: RawPointer<I8>) -> I64;
extern fn llvm_emit_to_file(machine: RawPointer<I8>, m: RawPointer<I8>, filename: String) -> I64;
extern fn llvm_print_module_to_string(m: RawPointer<I8>) -> String;

// ---------------------------------------------------------------------------
// Constants
// ---------------------------------------------------------------------------

// Type tags for lang_ty_tag field
fn TAG_I64() -> I64 { 0 }
fn TAG_BOOL() -> I64 { 1 }
fn TAG_STRING() -> I64 { 2 }
fn TAG_RAWPTR() -> I64 { 3 }
fn TAG_GCREF() -> I64 { 4 }
fn TAG_F32() -> I64 { 5 }
fn TAG_F64() -> I64 { 6 }
fn TAG_I8() -> I64 { 7 }
fn TAG_I16() -> I64 { 8 }
fn TAG_I32() -> I64 { 9 }
fn TAG_U8() -> I64 { 10 }
fn TAG_U16() -> I64 { 11 }
fn TAG_U32() -> I64 { 12 }
fn TAG_U64() -> I64 { 13 }
fn TAG_UNIT() -> I64 { 14 }
fn TAG_TUPLE() -> I64 { 15 }

// LLVM ICmp predicates
fn ICMP_EQ() -> I64 { 32 }
fn ICMP_NE() -> I64 { 33 }
fn ICMP_SGT() -> I64 { 38 }
fn ICMP_SGE() -> I64 { 39 }
fn ICMP_SLT() -> I64 { 40 }
fn ICMP_SLE() -> I64 { 41 }

// LLVM FCmp predicates
fn FCMP_OEQ() -> I64 { 1 }
fn FCMP_OGT() -> I64 { 2 }
fn FCMP_OGE() -> I64 { 3 }
fn FCMP_OLT() -> I64 { 4 }
fn FCMP_OLE() -> I64 { 5 }
fn FCMP_ONE() -> I64 { 6 }

// LLVM type kinds
fn TK_FLOAT() -> I64 { 2 }
fn TK_DOUBLE() -> I64 { 3 }
fn TK_INTEGER() -> I64 { 8 }
fn TK_POINTER() -> I64 { 12 }

// ---------------------------------------------------------------------------
// Codegen state structs
// ---------------------------------------------------------------------------

struct Codegen {
    context: RawPointer<I8>,
    llmod: RawPointer<I8>,
    builder: RawPointer<I8>,
    thread_struct_ty: RawPointer<I8>,
    functions: RawPointer<I8>,
    externs: RawPointer<I8>,
    gc_pollcheck_fn: RawPointer<I8>,
    gc_pollcheck_ty: RawPointer<I8>,
    gc_allocate_fn: RawPointer<I8>,
    gc_allocate_ty: RawPointer<I8>,
    gc_allocate_array_fn: RawPointer<I8>,
    gc_allocate_array_ty: RawPointer<I8>,
    gc_write_barrier_fn: RawPointer<I8>,
    gc_write_barrier_ty: RawPointer<I8>,
    object_header_ty: RawPointer<I8>,
    structs: RawPointer<I8>,
    enums: RawPointer<I8>,
    tuples: RawPointer<I8>,
    str_lit_id: I64
}

struct FnCtx {
    function: RawPointer<I8>,
    locals: RawPointer<I8>,
    scopes: RawPointer<I8>,
    thread: RawPointer<I8>,
    frame_ptr: RawPointer<I8>,
    frame_origin: RawPointer<I8>,
    frame_ty: RawPointer<I8>,
    root_base: RawPointer<I8>,
    next_root: I64,
    loop_stack: RawPointer<I8>
}

// ---------------------------------------------------------------------------
// Utility functions
// ---------------------------------------------------------------------------

fn path_to_string(path: RawPointer<I8>) -> String {
    let len: I64 = vec_len(path);
    if len == 0 { return ""; };
    let mut result: String = vec_get_str(path, 0);
    let mut i: I64 = 1;
    while i < len {
        result = string_concat(result, string_concat("::", vec_get_str(path, i)));
        i = i + 1;
    };
    result
}

fn full_item_name(module_path: RawPointer<I8>, name: String) -> String {
    if vec_len(module_path) == 0 {
        return name;
    };
    string_concat(path_to_string(module_path), string_concat("::", name))
}

fn enum_path_and_variant(path: RawPointer<I8>) -> String {
    // Returns the enum path (everything except last segment) as a string
    let len: I64 = vec_len(path);
    if len < 2 {
        return path_to_string(path);
    };
    let enum_parts: RawPointer<I8> = vec_new();
    let mut i: I64 = 0;
    while i < len - 1 {
        vec_push_str(enum_parts, vec_get_str(path, i));
        i = i + 1;
    };
    path_to_string(enum_parts)
}

fn variant_name_from_path(path: RawPointer<I8>) -> String {
    let len: I64 = vec_len(path);
    if len == 0 {
        return "";
    };
    vec_get_str(path, len - 1)
}

fn mangle_name(name: String) -> String {
    // Replace :: with __
    let len: I64 = string_len(name);
    let mut result: String = "";
    let mut i: I64 = 0;
    while i < len {
        let ch: I64 = string_byte_at(name, i);
        if ch == 58 {
            // ':' = 58
            if i + 1 < len {
                let next: I64 = string_byte_at(name, i + 1);
                if next == 58 {
                    result = string_concat(result, "__");
                    i = i + 2;
                    continue;
                };
            };
            result = string_concat(result, string_slice(name, i, i + 1));
            i = i + 1;
        } else {
            result = string_concat(result, string_slice(name, i, i + 1));
            i = i + 1;
        };
    };
    result
}

extern fn string_byte_at(s: String, index: I64) -> I64;
extern fn string_slice(s: String, start: I64, end: I64) -> String;

fn last_segment(full: String) -> String {
    let len: I64 = string_len(full);
    let mut last_sep: I64 = 0 - 1;
    let mut i: I64 = 0;
    while i < len - 1 {
        let ch: I64 = string_byte_at(full, i);
        if ch == 58 {
            let next: I64 = string_byte_at(full, i + 1);
            if next == 58 {
                last_sep = i + 1;
                i = i + 2;
                continue;
            };
        };
        i = i + 1;
    };
    if last_sep < 0 {
        return full;
    };
    string_slice(full, last_sep + 1, len)
}

fn type_key(ty: Type) -> String {
    match ty {
        Type::PathType { path, type_args } => {
            mangle_name(path_to_string(path))
        },
        Type::RawPtrType { inner } => {
            string_concat("ptr_", type_key(inner))
        },
        Type::TupleType { types } => {
            let mut out: String = "tup";
            let mut i: I64 = 0;
            while i < vec_len(types) {
                let t: Type = vec_get_type(types, i);
                out = string_concat(out, string_concat("_", type_key(t)));
                i = i + 1;
            };
            out
        }
    }
}

fn tuple_key(items: RawPointer<I8>) -> String {
    let mut out: String = "__tuple__";
    let mut i: I64 = 0;
    while i < vec_len(items) {
        if i > 0 {
            out = string_concat(out, "_");
        };
        let t: Type = vec_get_type(items, i);
        out = string_concat(out, type_key(t));
        i = i + 1;
    };
    out
}

fn type_name_from_type(ty: Type) -> String {
    match ty {
        Type::PathType { path, type_args } => {
            path_to_string(path)
        },
        Type::RawPtrType { inner } => {
            "RawPointer"
        },
        Type::TupleType { types } => {
            tuple_key(types)
        }
    }
}

fn llvm_fn_name(name: String) -> String {
    if string_eq(name, "main") == 1 {
        return "__lang_main";
    };
    mangle_name(name)
}

// ---------------------------------------------------------------------------
// Type helpers
// ---------------------------------------------------------------------------

fn is_gc_ref_type(ty: Type) -> Bool {
    match ty {
        Type::RawPtrType { inner } => { false },
        Type::TupleType { types } => { true },
        Type::PathType { path, type_args } => {
            let name: String = vec_get_str(path, vec_len(path) - 1);
            if string_eq(name, "I8") == 1 { return false; };
            if string_eq(name, "I16") == 1 { return false; };
            if string_eq(name, "I32") == 1 { return false; };
            if string_eq(name, "I64") == 1 { return false; };
            if string_eq(name, "U8") == 1 { return false; };
            if string_eq(name, "U16") == 1 { return false; };
            if string_eq(name, "U32") == 1 { return false; };
            if string_eq(name, "U64") == 1 { return false; };
            if string_eq(name, "F32") == 1 { return false; };
            if string_eq(name, "F64") == 1 { return false; };
            if string_eq(name, "Bool") == 1 { return false; };
            if string_eq(name, "Unit") == 1 { return false; };
            if string_eq(name, "String") == 1 { return false; };
            true
        }
    }
}

fn is_bool_type(ty: Type) -> Bool {
    match ty {
        Type::PathType { path, type_args } => {
            let name: String = vec_get_str(path, vec_len(path) - 1);
            string_eq(name, "Bool") == 1
        },
        Type::RawPtrType { inner } => { false },
        Type::TupleType { types } => { false }
    }
}

fn tag_is_gc_ref(tag: I64) -> Bool {
    tag == TAG_GCREF() || tag == TAG_TUPLE()
}

fn tag_is_bool(tag: I64) -> Bool {
    tag == TAG_BOOL()
}

fn type_to_tag(ty: Type) -> I64 {
    match ty {
        Type::RawPtrType { inner } => { TAG_RAWPTR() },
        Type::TupleType { types } => { TAG_TUPLE() },
        Type::PathType { path, type_args } => {
            let name: String = vec_get_str(path, vec_len(path) - 1);
            if string_eq(name, "I64") == 1 { return TAG_I64(); };
            if string_eq(name, "Bool") == 1 { return TAG_BOOL(); };
            if string_eq(name, "String") == 1 { return TAG_STRING(); };
            if string_eq(name, "F32") == 1 { return TAG_F32(); };
            if string_eq(name, "F64") == 1 { return TAG_F64(); };
            if string_eq(name, "I8") == 1 { return TAG_I8(); };
            if string_eq(name, "I16") == 1 { return TAG_I16(); };
            if string_eq(name, "I32") == 1 { return TAG_I32(); };
            if string_eq(name, "U8") == 1 { return TAG_U8(); };
            if string_eq(name, "U16") == 1 { return TAG_U16(); };
            if string_eq(name, "U32") == 1 { return TAG_U32(); };
            if string_eq(name, "U64") == 1 { return TAG_U64(); };
            if string_eq(name, "Unit") == 1 { return TAG_UNIT(); };
            TAG_GCREF()
        }
    }
}

fn llvm_type_for_tag(cg: Codegen, tag: I64) -> RawPointer<I8> {
    let ctx: RawPointer<I8> = cg.context;
    if tag == TAG_I64() { return llvm_int64_type(ctx); };
    if tag == TAG_BOOL() { return llvm_int1_type(ctx); };
    if tag == TAG_STRING() { return llvm_ptr_type(ctx); };
    if tag == TAG_RAWPTR() { return llvm_ptr_type(ctx); };
    if tag == TAG_GCREF() { return llvm_ptr_type(ctx); };
    if tag == TAG_F32() { return llvm_float_type(ctx); };
    if tag == TAG_F64() { return llvm_double_type(ctx); };
    if tag == TAG_I8() { return llvm_int8_type(ctx); };
    if tag == TAG_I16() { return llvm_int16_type(ctx); };
    if tag == TAG_I32() { return llvm_int32_type(ctx); };
    if tag == TAG_U8() { return llvm_int8_type(ctx); };
    if tag == TAG_U16() { return llvm_int16_type(ctx); };
    if tag == TAG_U32() { return llvm_int32_type(ctx); };
    if tag == TAG_U64() { return llvm_int64_type(ctx); };
    if tag == TAG_UNIT() { return llvm_int64_type(ctx); };
    if tag == TAG_TUPLE() { return llvm_ptr_type(ctx); };
    llvm_int64_type(ctx)
}

fn llvm_type(cg: Codegen, ty: Type) -> RawPointer<I8> {
    let tag: I64 = type_to_tag(ty);
    llvm_type_for_tag(cg, tag)
}

fn field_llvm_type(cg: Codegen, ty: Type) -> RawPointer<I8> {
    // For field storage: Bool -> i8, everything else same
    match ty {
        Type::PathType { path, type_args } => {
            let name: String = vec_get_str(path, vec_len(path) - 1);
            if string_eq(name, "Bool") == 1 { return llvm_int8_type(cg.context); };
            if string_eq(name, "I8") == 1 { return llvm_int8_type(cg.context); };
            if string_eq(name, "U8") == 1 { return llvm_int8_type(cg.context); };
            if string_eq(name, "I16") == 1 { return llvm_int16_type(cg.context); };
            if string_eq(name, "U16") == 1 { return llvm_int16_type(cg.context); };
            if string_eq(name, "I32") == 1 { return llvm_int32_type(cg.context); };
            if string_eq(name, "U32") == 1 { return llvm_int32_type(cg.context); };
            if string_eq(name, "I64") == 1 { return llvm_int64_type(cg.context); };
            if string_eq(name, "U64") == 1 { return llvm_int64_type(cg.context); };
            if string_eq(name, "F32") == 1 { return llvm_float_type(cg.context); };
            if string_eq(name, "F64") == 1 { return llvm_double_type(cg.context); };
            if string_eq(name, "String") == 1 { return llvm_ptr_type(cg.context); };
            if string_eq(name, "Unit") == 1 { return llvm_int64_type(cg.context); };
            // gc ref type
            llvm_ptr_type(cg.context)
        },
        Type::RawPtrType { inner } => { llvm_ptr_type(cg.context) },
        Type::TupleType { types } => { llvm_ptr_type(cg.context) }
    }
}

fn field_align(tag: I64) -> I64 {
    if tag == TAG_BOOL() { return 1; };
    if tag == TAG_I8() { return 1; };
    if tag == TAG_U8() { return 1; };
    if tag == TAG_I16() { return 2; };
    if tag == TAG_U16() { return 2; };
    if tag == TAG_I32() { return 4; };
    if tag == TAG_U32() { return 4; };
    8
}

fn field_size(tag: I64) -> I64 {
    if tag == TAG_BOOL() { return 1; };
    if tag == TAG_I8() { return 1; };
    if tag == TAG_U8() { return 1; };
    if tag == TAG_I16() { return 2; };
    if tag == TAG_U16() { return 2; };
    if tag == TAG_I32() { return 4; };
    if tag == TAG_U32() { return 4; };
    8
}

// ---------------------------------------------------------------------------
// Lookup helpers
// ---------------------------------------------------------------------------

fn cg_get_fn(cg: Codegen, name: String) -> CgFnEntry {
    let mut i: I64 = 0;
    let len: I64 = vec_len(cg.functions);
    while i < len {
        let entry: CgFnEntry = vec_get_cgfn(cg.functions, i);
        if string_eq(entry.name, name) == 1 {
            return entry;
        };
        i = i + 1;
    };
    print_str_stderr(string_concat("codegen error: unknown function: ", name));
    exit_process(1);
    // unreachable
    let dummy: CgFnEntry = vec_get_cgfn(cg.functions, 0);
    dummy
}

fn cg_get_extern(cg: Codegen, name: String) -> CgFnEntry {
    let mut i: I64 = 0;
    let len: I64 = vec_len(cg.externs);
    while i < len {
        let entry: CgFnEntry = vec_get_cgfn(cg.externs, i);
        if string_eq(entry.name, name) == 1 {
            return entry;
        };
        i = i + 1;
    };
    print_str_stderr(string_concat("codegen error: unknown extern: ", name));
    exit_process(1);
    let dummy: CgFnEntry = vec_get_cgfn(cg.externs, 0);
    dummy
}

fn cg_find_fn(cg: Codegen, name: String) -> I64 {
    // Returns 1 if found, 0 if not
    let mut i: I64 = 0;
    let len: I64 = vec_len(cg.functions);
    while i < len {
        let entry: CgFnEntry = vec_get_cgfn(cg.functions, i);
        if string_eq(entry.name, name) == 1 {
            return 1;
        };
        i = i + 1;
    };
    0
}

fn cg_find_extern(cg: Codegen, name: String) -> I64 {
    let mut i: I64 = 0;
    let len: I64 = vec_len(cg.externs);
    while i < len {
        let entry: CgFnEntry = vec_get_cgfn(cg.externs, i);
        if string_eq(entry.name, name) == 1 {
            return 1;
        };
        i = i + 1;
    };
    0
}

fn cg_get_struct(cg: Codegen, name: String) -> CgStructLayout {
    let mut i: I64 = 0;
    let len: I64 = vec_len(cg.structs);
    while i < len {
        let entry: CgStructLayout = vec_get_cgsl(cg.structs, i);
        if string_eq(entry.name, name) == 1 {
            return entry;
        };
        i = i + 1;
    };
    print_str_stderr(string_concat("codegen error: unknown struct: ", name));
    exit_process(1);
    let dummy: CgStructLayout = vec_get_cgsl(cg.structs, 0);
    dummy
}

fn cg_find_struct(cg: Codegen, name: String) -> I64 {
    let mut i: I64 = 0;
    let len: I64 = vec_len(cg.structs);
    while i < len {
        let entry: CgStructLayout = vec_get_cgsl(cg.structs, i);
        if string_eq(entry.name, name) == 1 {
            return 1;
        };
        i = i + 1;
    };
    0
}

fn cg_get_enum(cg: Codegen, name: String) -> CgEnumLayout {
    let mut i: I64 = 0;
    let len: I64 = vec_len(cg.enums);
    while i < len {
        let entry: CgEnumLayout = vec_get_cgel(cg.enums, i);
        if string_eq(entry.name, name) == 1 {
            return entry;
        };
        i = i + 1;
    };
    print_str_stderr(string_concat("codegen error: unknown enum: ", name));
    exit_process(1);
    let dummy: CgEnumLayout = vec_get_cgel(cg.enums, 0);
    dummy
}

fn cg_find_enum(cg: Codegen, name: String) -> I64 {
    let mut i: I64 = 0;
    let len: I64 = vec_len(cg.enums);
    while i < len {
        let entry: CgEnumLayout = vec_get_cgel(cg.enums, i);
        if string_eq(entry.name, name) == 1 {
            return 1;
        };
        i = i + 1;
    };
    0
}

fn cg_get_tuple(cg: Codegen, name: String) -> CgStructLayout {
    let mut i: I64 = 0;
    let len: I64 = vec_len(cg.tuples);
    while i < len {
        let entry: CgStructLayout = vec_get_cgsl(cg.tuples, i);
        if string_eq(entry.name, name) == 1 {
            return entry;
        };
        i = i + 1;
    };
    print_str_stderr(string_concat("codegen error: unknown tuple layout: ", name));
    exit_process(1);
    let dummy: CgStructLayout = vec_get_cgsl(cg.tuples, 0);
    dummy
}

fn cg_get_variant(layout: CgEnumLayout, vname: String) -> CgVariantLayout {
    let mut i: I64 = 0;
    let len: I64 = vec_len(layout.variants);
    while i < len {
        let v: CgVariantLayout = vec_get_cgvl(layout.variants, i);
        if string_eq(v.name, vname) == 1 {
            return v;
        };
        i = i + 1;
    };
    print_str_stderr(string_concat("codegen error: unknown variant: ", vname));
    exit_process(1);
    let dummy: CgVariantLayout = vec_get_cgvl(layout.variants, 0);
    dummy
}

fn cg_get_variant_field(vlayout: CgVariantLayout, fname: String) -> CgVariantFieldLayout {
    let mut i: I64 = 0;
    let len: I64 = vec_len(vlayout.fields);
    while i < len {
        let f: CgVariantFieldLayout = vec_get_cgvfl(vlayout.fields, i);
        if string_eq(f.name, fname) == 1 {
            return f;
        };
        i = i + 1;
    };
    print_str_stderr(string_concat("codegen error: unknown variant field: ", fname));
    exit_process(1);
    let dummy: CgVariantFieldLayout = vec_get_cgvfl(vlayout.fields, 0);
    dummy
}

// ---------------------------------------------------------------------------
// FnCtx helpers
// ---------------------------------------------------------------------------

fn ctx_push_scope(ctx: FnCtx) -> I64 {
    vec_push_vec(ctx.scopes, vec_new());
    0
}

fn ctx_pop_scope(ctx: FnCtx) -> I64 {
    let scope_count: I64 = vec_len(ctx.scopes);
    if scope_count == 0 { return 0; };
    let scope: RawPointer<I8> = vec_get_vec(ctx.scopes, scope_count - 1);
    let mut i: I64 = 0;
    let len: I64 = vec_len(scope);
    // Remove locals that were in this scope
    while i < len {
        let name: String = vec_get_str(scope, i);
        ctx_remove_local(ctx, name);
        i = i + 1;
    };
    vec_set_len(ctx.scopes, scope_count - 1);
    0
}

fn ctx_insert_local(ctx: FnCtx, name: String, local: CgLocal) -> I64 {
    vec_push_cgloc(ctx.locals, local);
    let scope_count: I64 = vec_len(ctx.scopes);
    if scope_count > 0 {
        let scope: RawPointer<I8> = vec_get_vec(ctx.scopes, scope_count - 1);
        vec_push_str(scope, name);
    };
    0
}

fn ctx_get_local(ctx: FnCtx, name: String) -> CgLocal {
    // Search backwards (most recent first)
    let len: I64 = vec_len(ctx.locals);
    let mut i: I64 = len - 1;
    while i >= 0 {
        let local: CgLocal = vec_get_cgloc(ctx.locals, i);
        if string_eq(local.name, name) == 1 {
            return local;
        };
        i = i - 1;
    };
    print_str_stderr(string_concat("codegen error: unknown local: ", name));
    exit_process(1);
    let dummy: CgLocal = vec_get_cgloc(ctx.locals, 0);
    dummy
}

fn ctx_remove_local(ctx: FnCtx, name: String) -> I64 {
    let len: I64 = vec_len(ctx.locals);
    let mut i: I64 = len - 1;
    while i >= 0 {
        let local: CgLocal = vec_get_cgloc(ctx.locals, i);
        if string_eq(local.name, name) == 1 {
            vec_set_len(ctx.locals, len - 1);
            return 0;
        };
        i = i - 1;
    };
    0
}

// ---------------------------------------------------------------------------
// Codegen initialization
// ---------------------------------------------------------------------------

fn new_codegen() -> Codegen {
    let ctx: RawPointer<I8> = llvm_context_create();
    let llmod: RawPointer<I8> = llvm_module_create("lang_module", ctx);
    let builder: RawPointer<I8> = llvm_create_builder(ctx);

    let ptr_ty: RawPointer<I8> = llvm_ptr_type(ctx);
    let i32_ty: RawPointer<I8> = llvm_int32_type(ctx);
    let i64_ty: RawPointer<I8> = llvm_int64_type(ctx);
    let void_ty: RawPointer<I8> = llvm_void_type(ctx);

    // Thread struct: { ptr, i32, i32 }
    let thread_elems: RawPointer<I8> = vec_new();
    vec_push(thread_elems, ptr_ty);
    vec_push(thread_elems, i32_ty);
    vec_push(thread_elems, i32_ty);
    let thread_struct_ty: RawPointer<I8> = llvm_struct_type(ctx, vec_data(thread_elems), 3, 0);

    // Object header: { ptr, i32, i32 }
    let header_elems: RawPointer<I8> = vec_new();
    vec_push(header_elems, ptr_ty);
    vec_push(header_elems, i32_ty);
    vec_push(header_elems, i32_ty);
    let object_header_ty: RawPointer<I8> = llvm_struct_type(ctx, vec_data(header_elems), 3, 0);

    // gc_pollcheck_slow(ptr, ptr) -> void
    let poll_params: RawPointer<I8> = vec_new();
    vec_push(poll_params, ptr_ty);
    vec_push(poll_params, ptr_ty);
    let poll_ty: RawPointer<I8> = llvm_function_type(void_ty, vec_data(poll_params), 2, 0);
    let poll_fn: RawPointer<I8> = llvm_add_function(llmod, "gc_pollcheck_slow", poll_ty);

    // gc_allocate(ptr, ptr, i64) -> ptr
    let alloc_params: RawPointer<I8> = vec_new();
    vec_push(alloc_params, ptr_ty);
    vec_push(alloc_params, ptr_ty);
    vec_push(alloc_params, i64_ty);
    let alloc_ty: RawPointer<I8> = llvm_function_type(ptr_ty, vec_data(alloc_params), 3, 0);
    let alloc_fn: RawPointer<I8> = llvm_add_function(llmod, "gc_allocate", alloc_ty);

    // gc_allocate_array(ptr, ptr, i64) -> ptr
    let alloc_array_fn: RawPointer<I8> = llvm_add_function(llmod, "gc_allocate_array", alloc_ty);

    // gc_write_barrier(ptr, ptr, ptr) -> void
    let wb_params: RawPointer<I8> = vec_new();
    vec_push(wb_params, ptr_ty);
    vec_push(wb_params, ptr_ty);
    vec_push(wb_params, ptr_ty);
    let wb_ty: RawPointer<I8> = llvm_function_type(void_ty, vec_data(wb_params), 3, 0);
    let wb_fn: RawPointer<I8> = llvm_add_function(llmod, "gc_write_barrier", wb_ty);

    Codegen {
        context: ctx,
        llmod: llmod,
        builder: builder,
        thread_struct_ty: thread_struct_ty,
        functions: vec_new(),
        externs: vec_new(),
        gc_pollcheck_fn: poll_fn,
        gc_pollcheck_ty: poll_ty,
        gc_allocate_fn: alloc_fn,
        gc_allocate_ty: alloc_ty,
        gc_allocate_array_fn: alloc_array_fn,
        gc_allocate_array_ty: alloc_ty,
        gc_write_barrier_fn: wb_fn,
        gc_write_barrier_ty: wb_ty,
        object_header_ty: object_header_ty,
        structs: vec_new(),
        enums: vec_new(),
        tuples: vec_new(),
        str_lit_id: 0
    }
}

// ---------------------------------------------------------------------------
// Type info (GC metadata) creation
// ---------------------------------------------------------------------------

fn create_type_info(cg: Codegen, name: String, kind: I64, size: I64, ptr_offsets: RawPointer<I8>) -> RawPointer<I8> {
    let ctx: RawPointer<I8> = cg.context;
    let i32_ty: RawPointer<I8> = llvm_int32_type(ctx);
    let i64_ty: RawPointer<I8> = llvm_int64_type(ctx);
    let ptr_ty: RawPointer<I8> = llvm_ptr_type(ctx);
    let num_ptrs: I64 = vec_len(ptr_offsets);

    // Build array of i64 offset values
    let offset_vals: RawPointer<I8> = vec_new();
    let mut i: I64 = 0;
    while i < num_ptrs {
        let off: I64 = string_parse_i64(vec_get_str(ptr_offsets, i));
        vec_push(offset_vals, llvm_const_int(i64_ty, off, 0));
        i = i + 1;
    };

    let offsets_arr_ty: RawPointer<I8> = llvm_array_type(i64_ty, num_ptrs);
    let offsets_const: RawPointer<I8> = llvm_const_array(i64_ty, vec_data(offset_vals), num_ptrs);
    let sym: String = mangle_name(name);
    let offsets_global: RawPointer<I8> = llvm_add_global(cg.llmod, offsets_arr_ty, string_concat("__ptr_offsets_", sym));
    llvm_set_initializer(offsets_global, offsets_const);

    let zero32: RawPointer<I8> = llvm_const_int(i32_ty, 0, 0);
    let gep_indices: RawPointer<I8> = vec_new();
    vec_push(gep_indices, zero32);
    vec_push(gep_indices, zero32);
    let offsets_ptr: RawPointer<I8> = llvm_const_gep2(offsets_arr_ty, offsets_global, vec_data(gep_indices), 2);

    let name_len: I64 = string_len(name);
    let name_const: RawPointer<I8> = llvm_const_string(ctx, name, name_len, 1);
    let name_arr_ty: RawPointer<I8> = llvm_array_type(llvm_int8_type(ctx), name_len + 1);
    let name_global: RawPointer<I8> = llvm_add_global(cg.llmod, name_arr_ty, string_concat("__type_name_", sym));
    llvm_set_initializer(name_global, name_const);
    let name_ptr: RawPointer<I8> = llvm_const_gep2(name_arr_ty, name_global, vec_data(gep_indices), 2);

    // TypeInfo struct: { i32, i32, i64, i32, i32, ptr, ptr }
    let ti_elems: RawPointer<I8> = vec_new();
    vec_push(ti_elems, i32_ty);
    vec_push(ti_elems, i32_ty);
    vec_push(ti_elems, i64_ty);
    vec_push(ti_elems, i32_ty);
    vec_push(ti_elems, i32_ty);
    vec_push(ti_elems, ptr_ty);
    vec_push(ti_elems, ptr_ty);
    let typeinfo_ty: RawPointer<I8> = llvm_struct_type(ctx, vec_data(ti_elems), 7, 0);

    let ti_vals: RawPointer<I8> = vec_new();
    vec_push(ti_vals, llvm_const_int(i32_ty, kind, 0));
    vec_push(ti_vals, llvm_const_int(i32_ty, 0, 0));
    vec_push(ti_vals, llvm_const_int(i64_ty, size, 0));
    vec_push(ti_vals, llvm_const_int(i32_ty, num_ptrs, 0));
    vec_push(ti_vals, llvm_const_int(i32_ty, 0, 0));
    vec_push(ti_vals, name_ptr);
    vec_push(ti_vals, offsets_ptr);
    let init: RawPointer<I8> = llvm_const_named_struct(typeinfo_ty, vec_data(ti_vals), 7);

    let global: RawPointer<I8> = llvm_add_global(cg.llmod, typeinfo_ty, string_concat("__typeinfo_", sym));
    llvm_set_initializer(global, init);
    global
}

// ---------------------------------------------------------------------------
// Layout computation
// ---------------------------------------------------------------------------

fn compute_struct_layout(cg: Codegen, full_name: String, fields: RawPointer<I8>) -> CgStructLayout {
    let ptr_size: I64 = 8;
    let header_size: I64 = 16;
    let ptr_fields: RawPointer<I8> = vec_new();
    let raw_fields: RawPointer<I8> = vec_new();

    let mut i: I64 = 0;
    while i < vec_len(fields) {
        let f: Field = vec_get_field(fields, i);
        let is_ptr: Bool = is_gc_ref_type(f.ty);
        let fty: RawPointer<I8> = field_llvm_type(cg, f.ty);
        let tag: I64 = type_to_tag(f.ty);
        let tname: String = type_name_from_type(f.ty);
        let fl: CgFieldLayout = CgFieldLayout {
            name: f.name, type_name: tname, offset: 0, is_ptr: is_ptr, llvm_ty: fty, lang_ty_tag: tag
        };
        if is_ptr { vec_push_cgfl(ptr_fields, fl); }
        else { vec_push_cgfl(raw_fields, fl); };
        i = i + 1;
    };

    let result_fields: RawPointer<I8> = vec_new();
    let mut offset: I64 = 0;

    let mut j: I64 = 0;
    while j < vec_len(ptr_fields) {
        let pf: CgFieldLayout = vec_get_cgfl(ptr_fields, j);
        vec_push_cgfl(result_fields, CgFieldLayout {
            name: pf.name, type_name: pf.type_name, offset: offset, is_ptr: pf.is_ptr, llvm_ty: pf.llvm_ty, lang_ty_tag: pf.lang_ty_tag
        });
        offset = offset + ptr_size;
        j = j + 1;
    };

    let mut k: I64 = 0;
    while k < vec_len(raw_fields) {
        let rf: CgFieldLayout = vec_get_cgfl(raw_fields, k);
        let align: I64 = field_align(rf.lang_ty_tag);
        let rem: I64 = offset - (offset / align) * align;
        if rem != 0 { offset = offset + align - rem; };
        vec_push_cgfl(result_fields, CgFieldLayout {
            name: rf.name, type_name: rf.type_name, offset: offset, is_ptr: rf.is_ptr, llvm_ty: rf.llvm_ty, lang_ty_tag: rf.lang_ty_tag
        });
        let sz: I64 = field_size(rf.lang_ty_tag);
        if sz < 1 { offset = offset + 1; } else { offset = offset + sz; };
        k = k + 1;
    };

    let total_size: I64 = header_size + offset;
    let ptr_offsets: RawPointer<I8> = vec_new();
    let mut m: I64 = 0;
    while m < vec_len(result_fields) {
        let fl2: CgFieldLayout = vec_get_cgfl(result_fields, m);
        if fl2.is_ptr { vec_push_str(ptr_offsets, string_from_i64(header_size + fl2.offset)); };
        m = m + 1;
    };

    let meta: RawPointer<I8> = create_type_info(cg, full_name, 0, total_size, ptr_offsets);
    CgStructLayout { name: full_name, size: total_size, fields: result_fields, meta: meta }
}

fn compute_enum_layout(cg: Codegen, full_name: String, variants: RawPointer<I8>) -> CgEnumLayout {
    let ptr_size: I64 = 8;
    let header_size: I64 = 16;
    let result_variants: RawPointer<I8> = vec_new();
    let mut max_ptrs: I64 = 0;
    let mut max_raw: I64 = 0;

    let mut vi: I64 = 0;
    while vi < vec_len(variants) {
        let v: EnumVariant = vec_get_variant(variants, vi);
        let mut ptr_index: I64 = 0;
        let mut raw_offset: I64 = 4;
        let vfields: RawPointer<I8> = vec_new();

        match v.kind {
            EnumVariantKind::UnitKind {} => {},
            EnumVariantKind::TupleKind { types } => {
                let mut ti: I64 = 0;
                while ti < vec_len(types) {
                    let ty: Type = vec_get_type(types, ti);
                    let is_ptr: Bool = is_gc_ref_type(ty);
                    let fty: RawPointer<I8> = field_llvm_type(cg, ty);
                    let ftag: I64 = type_to_tag(ty);
                    let tname: String = type_name_from_type(ty);
                    if is_ptr {
                        vec_push_cgvfl(vfields, CgVariantFieldLayout { name: "", type_name: tname, is_ptr: true, ptr_index: ptr_index, raw_offset: 0, llvm_ty: fty, lang_ty_tag: ftag });
                        ptr_index = ptr_index + 1;
                    } else {
                        let align: I64 = field_align(ftag);
                        let rem: I64 = raw_offset - (raw_offset / align) * align;
                        if rem != 0 { raw_offset = raw_offset + align - rem; };
                        vec_push_cgvfl(vfields, CgVariantFieldLayout { name: "", type_name: tname, is_ptr: false, ptr_index: 0, raw_offset: raw_offset, llvm_ty: fty, lang_ty_tag: ftag });
                        let sz: I64 = field_size(ftag);
                        if sz < 1 { raw_offset = raw_offset + 1; } else { raw_offset = raw_offset + sz; };
                    };
                    ti = ti + 1;
                };
            },
            EnumVariantKind::StructKind { fields } => {
                let mut fi: I64 = 0;
                while fi < vec_len(fields) {
                    let f: Field = vec_get_field(fields, fi);
                    let is_ptr: Bool = is_gc_ref_type(f.ty);
                    let fty: RawPointer<I8> = field_llvm_type(cg, f.ty);
                    let ftag: I64 = type_to_tag(f.ty);
                    let tname: String = type_name_from_type(f.ty);
                    if is_ptr {
                        vec_push_cgvfl(vfields, CgVariantFieldLayout { name: f.name, type_name: tname, is_ptr: true, ptr_index: ptr_index, raw_offset: 0, llvm_ty: fty, lang_ty_tag: ftag });
                        ptr_index = ptr_index + 1;
                    } else {
                        let align: I64 = field_align(ftag);
                        let rem: I64 = raw_offset - (raw_offset / align) * align;
                        if rem != 0 { raw_offset = raw_offset + align - rem; };
                        vec_push_cgvfl(vfields, CgVariantFieldLayout { name: f.name, type_name: tname, is_ptr: false, ptr_index: 0, raw_offset: raw_offset, llvm_ty: fty, lang_ty_tag: ftag });
                        let sz: I64 = field_size(ftag);
                        if sz < 1 { raw_offset = raw_offset + 1; } else { raw_offset = raw_offset + sz; };
                    };
                    fi = fi + 1;
                };
            }
        };

        if ptr_index > max_ptrs { max_ptrs = ptr_index; };
        if raw_offset > max_raw { max_raw = raw_offset; };
        vec_push_cgvl(result_variants, CgVariantLayout { name: v.name, tag: vi, fields: vfields });
        vi = vi + 1;
    };

    let raw_size: I64 = if max_raw == 0 { 4 } else { max_raw };
    let raw_base: I64 = header_size + max_ptrs * ptr_size;
    let total_size: I64 = raw_base + raw_size;

    let ptr_offsets: RawPointer<I8> = vec_new();
    let mut pi: I64 = 0;
    while pi < max_ptrs {
        vec_push_str(ptr_offsets, string_from_i64(header_size + pi * ptr_size));
        pi = pi + 1;
    };

    let meta: RawPointer<I8> = create_type_info(cg, full_name, 1, total_size, ptr_offsets);
    CgEnumLayout { name: full_name, size: total_size, ptr_count: max_ptrs, raw_size: raw_size, raw_base: raw_base, meta: meta, variants: result_variants }
}

// ---------------------------------------------------------------------------
// Declaration phase
// ---------------------------------------------------------------------------

fn declare_structs(cg: Codegen, modules: RawPointer<I8>) -> I64 {
    let mut mi: I64 = 0;
    while mi < vec_len(modules) {
        let m: Module = vec_get_module(modules, mi);
        let mut ii: I64 = 0;
        while ii < vec_len(m.items) {
            let item: Item = vec_get_item(m.items, ii);
            match item {
                Item::StructItem { decl } => {
                    let fname: String = full_item_name(m.path, decl.name);
                    let layout: CgStructLayout = compute_struct_layout(cg, fname, decl.fields);
                    vec_push_cgsl(cg.structs, layout);
                },
                Item::FnItem { decl } => {},
                Item::EnumItem { decl } => {},
                Item::ExternFnItem { decl } => {},
                Item::UseItem { decl } => {}
            };
            ii = ii + 1;
        };
        mi = mi + 1;
    };
    0
}

fn declare_enums(cg: Codegen, modules: RawPointer<I8>) -> I64 {
    let mut mi: I64 = 0;
    while mi < vec_len(modules) {
        let m: Module = vec_get_module(modules, mi);
        let mut ii: I64 = 0;
        while ii < vec_len(m.items) {
            let item: Item = vec_get_item(m.items, ii);
            match item {
                Item::EnumItem { decl } => {
                    let fname: String = full_item_name(m.path, decl.name);
                    let layout: CgEnumLayout = compute_enum_layout(cg, fname, decl.variants);
                    vec_push_cgel(cg.enums, layout);
                },
                Item::FnItem { decl } => {},
                Item::StructItem { decl } => {},
                Item::ExternFnItem { decl } => {},
                Item::UseItem { decl } => {}
            };
            ii = ii + 1;
        };
        mi = mi + 1;
    };
    0
}

fn declare_fn(cg: Codegen, full_name: String, params: RawPointer<I8>, ret_type: Type) -> CgFnEntry {
    let param_tys: RawPointer<I8> = vec_new();
    vec_push(param_tys, llvm_ptr_type(cg.context));
    let mut i: I64 = 0;
    while i < vec_len(params) {
        let p: Param = vec_get_param(params, i);
        vec_push(param_tys, llvm_type(cg, p.ty));
        i = i + 1;
    };
    let ret: RawPointer<I8> = llvm_type(cg, ret_type);
    let fn_ty: RawPointer<I8> = llvm_function_type(ret, vec_data(param_tys), vec_len(param_tys), 0);
    let llvm_name: String = llvm_fn_name(full_name);
    let fn_val: RawPointer<I8> = llvm_add_function(cg.llmod, llvm_name, fn_ty);
    CgFnEntry { name: full_name, fn_val: fn_val, fn_ty: fn_ty }
}

fn declare_extern_fn_entry(cg: Codegen, full_name: String, params: RawPointer<I8>, ret_type: Type, varargs: Bool) -> CgFnEntry {
    let symbol: String = last_segment(full_name);
    let existing: RawPointer<I8> = llvm_get_named_function(cg.llmod, symbol);
    if llvm_is_null(existing) == 0 {
        let fn_ty: RawPointer<I8> = llvm_get_global_value_type(existing);
        return CgFnEntry { name: full_name, fn_val: existing, fn_ty: fn_ty };
    };
    let param_tys: RawPointer<I8> = vec_new();
    let mut i: I64 = 0;
    while i < vec_len(params) {
        let p: Param = vec_get_param(params, i);
        vec_push(param_tys, llvm_type(cg, p.ty));
        i = i + 1;
    };
    let ret: RawPointer<I8> = llvm_type(cg, ret_type);
    let va: I64 = if varargs { 1 } else { 0 };
    let fn_ty: RawPointer<I8> = llvm_function_type(ret, vec_data(param_tys), vec_len(param_tys), va);
    let fn_val: RawPointer<I8> = llvm_add_function(cg.llmod, symbol, fn_ty);
    CgFnEntry { name: full_name, fn_val: fn_val, fn_ty: fn_ty }
}

fn declare_functions(cg: Codegen, modules: RawPointer<I8>) -> I64 {
    let mut mi: I64 = 0;
    while mi < vec_len(modules) {
        let m: Module = vec_get_module(modules, mi);
        let mut ii: I64 = 0;
        while ii < vec_len(m.items) {
            let item: Item = vec_get_item(m.items, ii);
            match item {
                Item::FnItem { decl } => {
                    let fname: String = full_item_name(m.path, decl.name);
                    let entry: CgFnEntry = declare_fn(cg, fname, decl.params, decl.ret_type);
                    vec_push_cgfn(cg.functions, entry);
                },
                Item::ExternFnItem { decl } => {
                    let fname: String = full_item_name(m.path, decl.name);
                    let entry: CgFnEntry = declare_extern_fn_entry(cg, fname, decl.params, decl.ret_type, decl.varargs);
                    vec_push_cgfn(cg.externs, entry);
                },
                Item::StructItem { decl } => {},
                Item::EnumItem { decl } => {},
                Item::UseItem { decl } => {}
            };
            ii = ii + 1;
        };
        mi = mi + 1;
    };
    0
}

// ---------------------------------------------------------------------------
// GC stack frames
// ---------------------------------------------------------------------------

fn make_frame_type(cg: Codegen, num_roots: I64) -> RawPointer<I8> {
    let ptr_ty: RawPointer<I8> = llvm_ptr_type(cg.context);
    let roots_ty: RawPointer<I8> = llvm_array_type(ptr_ty, num_roots);
    let elems: RawPointer<I8> = vec_new();
    vec_push(elems, ptr_ty);
    vec_push(elems, ptr_ty);
    vec_push(elems, roots_ty);
    llvm_struct_type(cg.context, vec_data(elems), 3, 0)
}

fn create_frame_origin(cg: Codegen, fn_name: String, num_roots: I64) -> RawPointer<I8> {
    let ctx: RawPointer<I8> = cg.context;
    let i32_ty: RawPointer<I8> = llvm_int32_type(ctx);
    let ptr_ty: RawPointer<I8> = llvm_ptr_type(ctx);

    let name_len: I64 = string_len(fn_name);
    let name_const: RawPointer<I8> = llvm_const_string(ctx, fn_name, name_len, 1);
    let name_arr_ty: RawPointer<I8> = llvm_array_type(llvm_int8_type(ctx), name_len + 1);
    let sym: String = mangle_name(fn_name);
    let name_global: RawPointer<I8> = llvm_add_global(cg.llmod, name_arr_ty, string_concat("__fn_name_", sym));
    llvm_set_initializer(name_global, name_const);

    let zero32: RawPointer<I8> = llvm_const_int(i32_ty, 0, 0);
    let gep_indices: RawPointer<I8> = vec_new();
    vec_push(gep_indices, zero32);
    vec_push(gep_indices, zero32);
    let name_ptr: RawPointer<I8> = llvm_const_gep2(name_arr_ty, name_global, vec_data(gep_indices), 2);

    let origin_elems: RawPointer<I8> = vec_new();
    vec_push(origin_elems, i32_ty);
    vec_push(origin_elems, ptr_ty);
    let origin_ty: RawPointer<I8> = llvm_struct_type(ctx, vec_data(origin_elems), 2, 0);
    let origin_global: RawPointer<I8> = llvm_add_global(cg.llmod, origin_ty, string_concat("__frame_origin_", sym));

    let origin_vals: RawPointer<I8> = vec_new();
    vec_push(origin_vals, llvm_const_int(i32_ty, num_roots, 0));
    vec_push(origin_vals, name_ptr);
    let init: RawPointer<I8> = llvm_const_named_struct(origin_ty, vec_data(origin_vals), 2);
    llvm_set_initializer(origin_global, init);
    origin_global
}

fn thread_top_frame_ptr(cg: Codegen, thread: RawPointer<I8>) -> RawPointer<I8> {
    llvm_build_struct_gep2(cg.builder, cg.thread_struct_ty, thread, 0, "thread.top")
}

fn thread_state_ptr(cg: Codegen, thread: RawPointer<I8>) -> RawPointer<I8> {
    llvm_build_struct_gep2(cg.builder, cg.thread_struct_ty, thread, 1, "thread.state")
}

fn emit_prologue(cg: Codegen, function: RawPointer<I8>, thread: RawPointer<I8>, fn_name: String, num_roots: I64, ft: RawPointer<I8>) -> FnCtx {
    let ctx: RawPointer<I8> = cg.context;
    let ptr_ty: RawPointer<I8> = llvm_ptr_type(ctx);

    let frame_origin: RawPointer<I8> = create_frame_origin(cg, fn_name, num_roots);
    let frame_ptr: RawPointer<I8> = llvm_build_alloca(cg.builder, ft, "frame");

    let parent_ptr: RawPointer<I8> = llvm_build_struct_gep2(cg.builder, ft, frame_ptr, 0, "frame.parent");
    let origin_ptr: RawPointer<I8> = llvm_build_struct_gep2(cg.builder, ft, frame_ptr, 1, "frame.origin");

    let top_frame_ptr: RawPointer<I8> = thread_top_frame_ptr(cg, thread);
    let parent: RawPointer<I8> = llvm_build_load(cg.builder, ptr_ty, top_frame_ptr, "parent");

    llvm_build_store(cg.builder, parent, parent_ptr);
    llvm_build_store(cg.builder, frame_origin, origin_ptr);

    let mut root_base: RawPointer<I8> = llvm_const_null(ptr_ty);
    if num_roots > 0 {
        let roots_ptr: RawPointer<I8> = llvm_build_struct_gep2(cg.builder, ft, frame_ptr, 2, "frame.roots");
        let roots_ty: RawPointer<I8> = llvm_array_type(ptr_ty, num_roots);
        let zero: RawPointer<I8> = llvm_const_int(llvm_int32_type(ctx), 0, 0);
        let gep_idx: RawPointer<I8> = vec_new();
        vec_push(gep_idx, zero);
        vec_push(gep_idx, zero);
        root_base = llvm_build_gep2(cg.builder, roots_ty, roots_ptr, vec_data(gep_idx), 2, "root0");

        let size_val: RawPointer<I8> = llvm_const_int(llvm_int64_type(ctx), 8 * num_roots, 0);
        let zero_val: RawPointer<I8> = llvm_const_int(llvm_int8_type(ctx), 0, 0);
        let cast: RawPointer<I8> = llvm_build_bitcast(cg.builder, root_base, ptr_ty, "root0_cast");
        llvm_build_memset(cg.builder, cast, zero_val, size_val, 8);
    };

    llvm_build_store(cg.builder, frame_ptr, top_frame_ptr);

    FnCtx {
        function: function,
        locals: vec_new(),
        scopes: vec_new(),
        thread: thread,
        frame_ptr: frame_ptr,
        frame_origin: frame_origin,
        frame_ty: ft,
        root_base: root_base,
        next_root: 0,
        loop_stack: vec_new()
    }
}

fn emit_epilogue(cg: Codegen, ctx: FnCtx) -> I64 {
    let ptr_ty: RawPointer<I8> = llvm_ptr_type(cg.context);
    let parent_ptr: RawPointer<I8> = llvm_build_struct_gep2(cg.builder, ctx.frame_ty, ctx.frame_ptr, 0, "frame.parent");
    let parent: RawPointer<I8> = llvm_build_load(cg.builder, ptr_ty, parent_ptr, "parent_load");
    let top_frame_ptr: RawPointer<I8> = thread_top_frame_ptr(cg, ctx.thread);
    llvm_build_store(cg.builder, parent, top_frame_ptr);
    0
}

fn emit_pollcheck(cg: Codegen, ctx: FnCtx) -> I64 {
    let i32_ty: RawPointer<I8> = llvm_int32_type(cg.context);
    let state_ptr: RawPointer<I8> = thread_state_ptr(cg, ctx.thread);
    let state: RawPointer<I8> = llvm_build_load(cg.builder, i32_ty, state_ptr, "gc_state");
    let zero: RawPointer<I8> = llvm_const_int(i32_ty, 0, 0);
    let needs: RawPointer<I8> = llvm_build_icmp(cg.builder, ICMP_NE(), state, zero, "needs_gc");

    let slow_bb: RawPointer<I8> = llvm_append_basic_block(cg.context, ctx.function, "poll.slow");
    let cont_bb: RawPointer<I8> = llvm_append_basic_block(cg.context, ctx.function, "poll.cont");
    llvm_build_cond_br(cg.builder, needs, slow_bb, cont_bb);

    llvm_position_at_end(cg.builder, slow_bb);
    let args: RawPointer<I8> = vec_new();
    vec_push(args, ctx.thread);
    vec_push(args, ctx.frame_origin);
    llvm_build_call(cg.builder, cg.gc_pollcheck_ty, cg.gc_pollcheck_fn, vec_data(args), 2, "poll");
    llvm_build_br(cg.builder, cont_bb);

    llvm_position_at_end(cg.builder, cont_bb);
    0
}

// ---------------------------------------------------------------------------
// Local variable storage
// ---------------------------------------------------------------------------

fn create_entry_alloca(cg: Codegen, function: RawPointer<I8>, name: String, tag: I64) -> RawPointer<I8> {
    let entry_bb: RawPointer<I8> = llvm_get_first_basic_block(function);
    let first_instr: RawPointer<I8> = llvm_get_first_instruction(entry_bb);
    let tmp_builder: RawPointer<I8> = llvm_create_builder(cg.context);
    if llvm_is_null(first_instr) == 1 {
        llvm_position_at_end(tmp_builder, entry_bb);
    } else {
        llvm_position_before(tmp_builder, first_instr);
    };
    let lty: RawPointer<I8> = llvm_type_for_tag(cg, tag);
    let ptr: RawPointer<I8> = llvm_build_alloca(tmp_builder, lty, name);
    llvm_dispose_builder(tmp_builder);
    ptr
}

fn create_local_storage(cg: Codegen, ctx: FnCtx, name: String, ty: Type) -> CgLocal {
    let tag: I64 = type_to_tag(ty);
    let tname: String = type_name_from_type(ty);
    let is_ref: Bool = is_gc_ref_type(ty);
    if is_ref {
        let idx: RawPointer<I8> = llvm_const_int(llvm_int32_type(cg.context), ctx.next_root, 0);
        let ptr_ty: RawPointer<I8> = llvm_ptr_type(cg.context);
        let indices: RawPointer<I8> = vec_new();
        vec_push(indices, idx);
        let slot_ptr: RawPointer<I8> = llvm_build_gep2(cg.builder, ptr_ty, ctx.root_base, vec_data(indices), 1, "root_slot");
        CgLocal { name: name, type_name: tname, ptr: slot_ptr, ty: ptr_ty, lang_ty_tag: tag, is_gc_ref: true }
    } else {
        let ptr: RawPointer<I8> = create_entry_alloca(cg, ctx.function, name, tag);
        let lty: RawPointer<I8> = llvm_type_for_tag(cg, tag);
        CgLocal { name: name, type_name: tname, ptr: ptr, ty: lty, lang_ty_tag: tag, is_gc_ref: false }
    }
}

fn load_local(cg: Codegen, local: CgLocal) -> RawPointer<I8> {
    let loaded: RawPointer<I8> = llvm_build_load(cg.builder, local.ty, local.ptr, local.name);
    if local.is_gc_ref { llvm_set_volatile(loaded, 1); };
    loaded
}

fn store_local(cg: Codegen, local: CgLocal, value: RawPointer<I8>) -> I64 {
    let inst: RawPointer<I8> = llvm_build_store(cg.builder, value, local.ptr);
    if local.is_gc_ref { llvm_set_volatile(inst, 1); };
    0
}

// ---------------------------------------------------------------------------
// Root counting (pre-scan to determine frame size)
// ---------------------------------------------------------------------------

fn count_param_roots(params: RawPointer<I8>) -> I64 {
    let mut count: I64 = 0;
    let mut i: I64 = 0;
    while i < vec_len(params) {
        let p: Param = vec_get_param(params, i);
        if is_gc_ref_type(p.ty) { count = count + 1; };
        i = i + 1;
    };
    count
}

fn count_roots_in_fn(cg: Codegen, params: RawPointer<I8>, body: Block) -> I64 {
    count_param_roots(params) + count_roots_in_block(cg, body)
}

fn count_roots_in_block(cg: Codegen, block: Block) -> I64 {
    let mut count: I64 = 0;
    let mut i: I64 = 0;
    while i < vec_len(block.stmts) {
        let stmt: Stmt = vec_get_stmt(block.stmts, i);
        match stmt {
            Stmt::ExprStmt { expr, span } => {
                count = count + count_roots_in_expr(cg, expr);
            },
            Stmt::ReturnStmt { value, span } => {
                match value {
                    Option::Some { value } => {
                        count = count + count_roots_in_expr(cg, value);
                    },
                    Option::None {} => {}
                };
            }
        };
        i = i + 1;
    };
    match block.tail {
        Option::Some { value } => { count = count + count_roots_in_expr(cg, value); },
        Option::None {} => {}
    };
    count
}

fn count_roots_in_expr(cg: Codegen, expr: Expr) -> I64 {
    match expr {
        Expr::LetExpr { name, mutable, ty, value, span } => {
            let mut count: I64 = 0;
            match ty {
                Option::Some { value: ty_val } => {
                    if is_gc_ref_type(ty_val) { count = count + 1; };
                },
                Option::None {} => {}
            };
            count + count_roots_in_expr(cg, value)
        },
        Expr::IfExpr { cond, then_branch, else_branch, span } => {
            let mut count: I64 = count_roots_in_expr(cg, cond);
            count = count + count_roots_in_block(cg, then_branch);
            match else_branch {
                Option::Some { value } => { count = count + count_roots_in_block(cg, value); },
                Option::None {} => {}
            };
            count
        },
        Expr::WhileExpr { cond, body, span } => {
            count_roots_in_expr(cg, cond) + count_roots_in_block(cg, body)
        },
        Expr::MatchExpr { scrutinee, arms, span } => {
            let mut count: I64 = count_roots_in_expr(cg, scrutinee);
            let mut i: I64 = 0;
            while i < vec_len(arms) {
                let arm: MatchArm = vec_get_arm(arms, i);
                count = count + count_roots_in_pattern(cg, arm.pattern);
                count = count + count_roots_in_expr(cg, arm.body);
                i = i + 1;
            };
            count
        },
        Expr::AssignExpr { target, value, span } => {
            count_roots_in_expr(cg, target) + count_roots_in_expr(cg, value)
        },
        Expr::BinaryExpr { op, left, right, span } => {
            count_roots_in_expr(cg, left) + count_roots_in_expr(cg, right)
        },
        Expr::UnaryExpr { op, operand, span } => {
            count_roots_in_expr(cg, operand)
        },
        Expr::CallExpr { callee, args, span } => {
            let mut count: I64 = count_roots_in_expr(cg, callee);
            let mut i: I64 = 0;
            while i < vec_len(args) {
                let arg: Expr = vec_get_expr(args, i);
                count = count + count_roots_in_expr(cg, arg);
                i = i + 1;
            };
            count
        },
        Expr::FieldExpr { base, name, span } => {
            count_roots_in_expr(cg, base)
        },
        Expr::StructLitExpr { path, fields, span } => {
            let mut count: I64 = 0;
            let mut i: I64 = 0;
            while i < vec_len(fields) {
                let f: StructLitField = vec_get_slfield(fields, i);
                count = count + count_roots_in_expr(cg, f.value);
                i = i + 1;
            };
            count
        },
        Expr::TupleExpr { items, span } => {
            let mut count: I64 = 0;
            let mut i: I64 = 0;
            while i < vec_len(items) {
                let it: Expr = vec_get_expr(items, i);
                count = count + count_roots_in_expr(cg, it);
                i = i + 1;
            };
            count
        },
        Expr::BlockExpr { block } => {
            count_roots_in_block(cg, block)
        },
        Expr::PathExpr { path, span } => { 0 },
        Expr::LitExpr { lit, span } => { 0 },
        Expr::BreakExpr { span } => { 0 },
        Expr::ContinueExpr { span } => { 0 }
    }
}

fn count_roots_in_pattern(cg: Codegen, pat: Pattern) -> I64 {
    match pat {
        Pattern::StructPat { path, fields, span } => {
            if vec_len(path) < 2 { return 0; };
            let enum_name: String = enum_path_and_variant(path);
            let vname: String = variant_name_from_path(path);
            if cg_find_enum(cg, enum_name) == 0 { return 0; };
            let layout: CgEnumLayout = cg_get_enum(cg, enum_name);
            let mut vi: I64 = 0;
            let mut vlayout_found: Bool = false;
            let mut vlayout: CgVariantLayout = CgVariantLayout { name: "", tag: 0, fields: vec_new() };
            while vi < vec_len(layout.variants) {
                let v: CgVariantLayout = vec_get_cgvl(layout.variants, vi);
                if string_eq(v.name, vname) == 1 {
                    vlayout = v;
                    vlayout_found = true;
                };
                vi = vi + 1;
            };
            if !vlayout_found { return 0; };
            let mut count: I64 = 0;
            let mut fi: I64 = 0;
            while fi < vec_len(fields) {
                let pf: PatternField = vec_get_pfield(fields, fi);
                match pf.binding {
                    Option::None {} => {},
                    Option::Some { value } => {
                        // Find this field in the variant
                        let mut ffi: I64 = 0;
                        while ffi < vec_len(vlayout.fields) {
                            let vfl: CgVariantFieldLayout = vec_get_cgvfl(vlayout.fields, ffi);
                            if string_eq(vfl.name, pf.name) == 1 {
                                if vfl.is_ptr { count = count + 1; };
                            };
                            ffi = ffi + 1;
                        };
                    }
                };
                fi = fi + 1;
            };
            count
        },
        Pattern::WildcardPat { span } => { 0 },
        Pattern::PathPat { path, span } => { 0 }
    }
}

// ---------------------------------------------------------------------------
// Memory access helpers
// ---------------------------------------------------------------------------

fn field_ptr(cg: Codegen, obj_ptr: RawPointer<I8>, fl: CgFieldLayout) -> RawPointer<I8> {
    let i8_ty: RawPointer<I8> = llvm_int8_type(cg.context);
    let header_off: RawPointer<I8> = llvm_const_int(llvm_int64_type(cg.context), 16, 0);
    let idx1: RawPointer<I8> = vec_new();
    vec_push(idx1, header_off);
    let payload_ptr: RawPointer<I8> = llvm_build_gep2(cg.builder, i8_ty, obj_ptr, vec_data(idx1), 1, "payload");
    let offset: RawPointer<I8> = llvm_const_int(llvm_int64_type(cg.context), fl.offset, 0);
    let idx2: RawPointer<I8> = vec_new();
    vec_push(idx2, offset);
    let field_i8: RawPointer<I8> = llvm_build_gep2(cg.builder, i8_ty, payload_ptr, vec_data(idx2), 1, "field_i8");
    field_i8
}

fn enum_raw_base_ptr(cg: Codegen, obj_ptr: RawPointer<I8>, raw_base: I64) -> RawPointer<I8> {
    let i8_ty: RawPointer<I8> = llvm_int8_type(cg.context);
    let offset: RawPointer<I8> = llvm_const_int(llvm_int64_type(cg.context), raw_base, 0);
    let idx: RawPointer<I8> = vec_new();
    vec_push(idx, offset);
    llvm_build_gep2(cg.builder, i8_ty, obj_ptr, vec_data(idx), 1, "enum_raw")
}

fn enum_ptr_slot(cg: Codegen, obj_ptr: RawPointer<I8>, index: I64) -> RawPointer<I8> {
    let i8_ty: RawPointer<I8> = llvm_int8_type(cg.context);
    let ptr_ty: RawPointer<I8> = llvm_ptr_type(cg.context);
    let header: RawPointer<I8> = llvm_const_int(llvm_int64_type(cg.context), 16, 0);
    let idx1: RawPointer<I8> = vec_new();
    vec_push(idx1, header);
    let ptr_base: RawPointer<I8> = llvm_build_gep2(cg.builder, i8_ty, obj_ptr, vec_data(idx1), 1, "enum_ptrs");
    let idx_val: RawPointer<I8> = llvm_const_int(llvm_int64_type(cg.context), index, 0);
    let idx2: RawPointer<I8> = vec_new();
    vec_push(idx2, idx_val);
    llvm_build_gep2(cg.builder, ptr_ty, ptr_base, vec_data(idx2), 1, "enum_slot")
}

fn enum_raw_field_ptr(cg: Codegen, raw_base_ptr: RawPointer<I8>, offset: I64) -> RawPointer<I8> {
    let i8_ty: RawPointer<I8> = llvm_int8_type(cg.context);
    let off: RawPointer<I8> = llvm_const_int(llvm_int64_type(cg.context), offset, 0);
    let idx: RawPointer<I8> = vec_new();
    vec_push(idx, off);
    llvm_build_gep2(cg.builder, i8_ty, raw_base_ptr, vec_data(idx), 1, "enum_raw_field")
}

fn load_enum_tag(cg: Codegen, obj_ptr: RawPointer<I8>, layout: CgEnumLayout) -> RawPointer<I8> {
    let raw_base: RawPointer<I8> = enum_raw_base_ptr(cg, obj_ptr, layout.raw_base);
    let i32_ty: RawPointer<I8> = llvm_int32_type(cg.context);
    llvm_build_load(cg.builder, i32_ty, raw_base, "tag")
}

fn init_header(cg: Codegen, obj_ptr: RawPointer<I8>, meta_ptr: RawPointer<I8>) -> I64 {
    let ptr_ty: RawPointer<I8> = llvm_ptr_type(cg.context);
    let i32_ty: RawPointer<I8> = llvm_int32_type(cg.context);
    let header_ptr: RawPointer<I8> = llvm_build_bitcast(cg.builder, obj_ptr, ptr_ty, "header");
    let meta_slot: RawPointer<I8> = llvm_build_struct_gep2(cg.builder, cg.object_header_ty, header_ptr, 0, "meta");
    let flags_slot: RawPointer<I8> = llvm_build_struct_gep2(cg.builder, cg.object_header_ty, header_ptr, 1, "flags");
    let aux_slot: RawPointer<I8> = llvm_build_struct_gep2(cg.builder, cg.object_header_ty, header_ptr, 2, "aux");
    llvm_build_store(cg.builder, meta_ptr, meta_slot);
    let zero: RawPointer<I8> = llvm_const_int(i32_ty, 0, 0);
    llvm_build_store(cg.builder, zero, flags_slot);
    llvm_build_store(cg.builder, zero, aux_slot);
    0
}

// ---------------------------------------------------------------------------
// Struct field resolution
// ---------------------------------------------------------------------------

fn resolve_struct_base(cg: Codegen, base: Expr, ctx: FnCtx) -> RawPointer<I8> {
    // Returns the object pointer for a struct base expression
    match base {
        Expr::PathExpr { path, span } => {
            let var: String = vec_get_str(path, vec_len(path) - 1);
            let local: CgLocal = ctx_get_local(ctx, var);
            load_local(cg, local)
        },
        Expr::FieldExpr { base, name, span } => {
            let obj_ptr: RawPointer<I8> = resolve_struct_base(cg, base, ctx);
            let type_name: String = resolve_base_type_name(cg, base, ctx);
            let layout: CgStructLayout = cg_get_struct(cg, type_name);
            let fl: CgFieldLayout = find_field_layout(layout.fields, name);
            let fp: RawPointer<I8> = field_ptr(cg, obj_ptr, fl);
            llvm_build_load(cg.builder, fl.llvm_ty, fp, "field_obj")
        },
        _ => {
            print_str_stderr("codegen error: field base must be path or field");
            exit_process(1);
            llvm_const_null(llvm_ptr_type(cg.context))
        }
    }
}

fn resolve_base_type_name(cg: Codegen, base: Expr, ctx: FnCtx) -> String {
    match base {
        Expr::PathExpr { path, span } => {
            let var: String = vec_get_str(path, vec_len(path) - 1);
            let local: CgLocal = ctx_get_local(ctx, var);
            local.type_name
        },
        Expr::FieldExpr { base, name, span } => {
            let parent_type: String = resolve_base_type_name(cg, base, ctx);
            let layout: CgStructLayout = cg_get_struct(cg, parent_type);
            let fl: CgFieldLayout = find_field_layout(layout.fields, name);
            fl.type_name
        },
        _ => {
            print_str_stderr("codegen error: cannot resolve type name for base");
            exit_process(1);
            ""
        }
    }
}

fn find_field_layout(fields: RawPointer<I8>, name: String) -> CgFieldLayout {
    let mut i: I64 = 0;
    while i < vec_len(fields) {
        let fl: CgFieldLayout = vec_get_cgfl(fields, i);
        if string_eq(fl.name, name) == 1 { return fl; };
        i = i + 1;
    };
    print_str_stderr(string_concat("codegen error: unknown field: ", name));
    exit_process(1);
    let dummy: CgFieldLayout = vec_get_cgfl(fields, 0);
    dummy
}

// ---------------------------------------------------------------------------
// Binary operations
// ---------------------------------------------------------------------------

fn codegen_binary(cg: Codegen, op: BinaryOp, left: RawPointer<I8>, right: RawPointer<I8>) -> RawPointer<I8> {
    // Check if float by looking at LLVM type kind
    let left_ty: RawPointer<I8> = llvm_get_value_type(left);
    let kind: I64 = llvm_get_type_kind(left_ty);
    if kind == TK_FLOAT() || kind == TK_DOUBLE() {
        return codegen_binary_float(cg, op, left, right);
    };
    codegen_binary_int(cg, op, left, right)
}

fn codegen_binary_int(cg: Codegen, op: BinaryOp, l: RawPointer<I8>, r: RawPointer<I8>) -> RawPointer<I8> {
    let b: RawPointer<I8> = cg.builder;
    match op {
        BinaryOp::Add {} => { llvm_build_add(b, l, r, "add") },
        BinaryOp::Sub {} => { llvm_build_sub(b, l, r, "sub") },
        BinaryOp::Mul {} => { llvm_build_mul(b, l, r, "mul") },
        BinaryOp::Div {} => { llvm_build_sdiv(b, l, r, "div") },
        BinaryOp::Rem {} => { llvm_build_srem(b, l, r, "rem") },
        BinaryOp::Eq {} => { llvm_build_icmp(b, ICMP_EQ(), l, r, "eq") },
        BinaryOp::NotEq {} => { llvm_build_icmp(b, ICMP_NE(), l, r, "ne") },
        BinaryOp::Lt {} => { llvm_build_icmp(b, ICMP_SLT(), l, r, "lt") },
        BinaryOp::LtEq {} => { llvm_build_icmp(b, ICMP_SLE(), l, r, "le") },
        BinaryOp::Gt {} => { llvm_build_icmp(b, ICMP_SGT(), l, r, "gt") },
        BinaryOp::GtEq {} => { llvm_build_icmp(b, ICMP_SGE(), l, r, "ge") },
        BinaryOp::AndAnd {} => { llvm_build_and(b, l, r, "and") },
        BinaryOp::OrOr {} => { llvm_build_or(b, l, r, "or") }
    }
}

fn codegen_binary_float(cg: Codegen, op: BinaryOp, l: RawPointer<I8>, r: RawPointer<I8>) -> RawPointer<I8> {
    let b: RawPointer<I8> = cg.builder;
    match op {
        BinaryOp::Add {} => { llvm_build_fadd(b, l, r, "fadd") },
        BinaryOp::Sub {} => { llvm_build_fsub(b, l, r, "fsub") },
        BinaryOp::Mul {} => { llvm_build_fmul(b, l, r, "fmul") },
        BinaryOp::Div {} => { llvm_build_fdiv(b, l, r, "fdiv") },
        BinaryOp::Rem {} => { llvm_build_frem(b, l, r, "frem") },
        BinaryOp::Eq {} => { llvm_build_fcmp(b, FCMP_OEQ(), l, r, "feq") },
        BinaryOp::NotEq {} => { llvm_build_fcmp(b, FCMP_ONE(), l, r, "fne") },
        BinaryOp::Lt {} => { llvm_build_fcmp(b, FCMP_OLT(), l, r, "flt") },
        BinaryOp::LtEq {} => { llvm_build_fcmp(b, FCMP_OLE(), l, r, "fle") },
        BinaryOp::Gt {} => { llvm_build_fcmp(b, FCMP_OGT(), l, r, "fgt") },
        BinaryOp::GtEq {} => { llvm_build_fcmp(b, FCMP_OGE(), l, r, "fge") },
        BinaryOp::AndAnd {} => {
            print_str_stderr("codegen error: invalid float logical op");
            exit_process(1);
            l
        },
        BinaryOp::OrOr {} => {
            print_str_stderr("codegen error: invalid float logical op");
            exit_process(1);
            l
        }
    }
}

// ---------------------------------------------------------------------------
// Block codegen
// ---------------------------------------------------------------------------

// codegen_block: emits stmts, returns 1 if terminated (return), 0 otherwise
fn codegen_block(cg: Codegen, block: Block, ctx: FnCtx) -> I64 {
    ctx_push_scope(ctx);
    let mut i: I64 = 0;
    while i < vec_len(block.stmts) {
        let stmt: Stmt = vec_get_stmt(block.stmts, i);
        match stmt {
            Stmt::ExprStmt { expr, span } => {
                codegen_expr(cg, expr, ctx);
            },
            Stmt::ReturnStmt { value, span } => {
                let ret_val: RawPointer<I8> = match value {
                    Option::Some { value } => { codegen_expr(cg, value, ctx) },
                    Option::None {} => { llvm_const_int(llvm_int64_type(cg.context), 0, 0) }
                };
                emit_epilogue(cg, ctx);
                llvm_build_ret(cg.builder, ret_val);
                ctx_pop_scope(ctx);
                return 1;
            }
        };
        i = i + 1;
    };
    match block.tail {
        Option::Some { value } => { codegen_expr(cg, value, ctx); },
        Option::None {} => {}
    };
    ctx_pop_scope(ctx);
    0
}

// codegen_block_value: like codegen_block but returns last value
fn codegen_block_value(cg: Codegen, block: Block, ctx: FnCtx) -> RawPointer<I8> {
    ctx_push_scope(ctx);
    let null: RawPointer<I8> = llvm_const_null(llvm_ptr_type(cg.context));
    let mut last: RawPointer<I8> = null;
    let mut terminated: Bool = false;
    let mut i: I64 = 0;
    while i < vec_len(block.stmts) {
        let stmt: Stmt = vec_get_stmt(block.stmts, i);
        match stmt {
            Stmt::ExprStmt { expr, span } => {
                last = codegen_expr(cg, expr, ctx);
            },
            Stmt::ReturnStmt { value, span } => {
                let ret_val: RawPointer<I8> = match value {
                    Option::Some { value } => { codegen_expr(cg, value, ctx) },
                    Option::None {} => { llvm_const_int(llvm_int64_type(cg.context), 0, 0) }
                };
                emit_epilogue(cg, ctx);
                llvm_build_ret(cg.builder, ret_val);
                terminated = true;
                i = vec_len(block.stmts); // break
            }
        };
        i = i + 1;
    };
    if !terminated {
        match block.tail {
            Option::Some { value } => { last = codegen_expr(cg, value, ctx); },
            Option::None {} => {}
        };
    };
    ctx_pop_scope(ctx);
    last
}

// ---------------------------------------------------------------------------
// Expression codegen â€” returns LLVM value (or null for void expressions)
// ---------------------------------------------------------------------------

fn codegen_expr(cg: Codegen, expr: Expr, ctx: FnCtx) -> RawPointer<I8> {
    let null: RawPointer<I8> = llvm_const_null(llvm_ptr_type(cg.context));
    match expr {
        Expr::LetExpr { name, mutable, ty, value, span } => {
            let val: RawPointer<I8> = codegen_expr(cg, value, ctx);
            let the_ty: Type = match ty {
                Option::Some { value } => { value },
                Option::None {} => {
                    print_str_stderr("codegen error: let requires type annotation");
                    exit_process(1);
                    // unreachable
                    Type::PathType { path: vec_new(), type_args: vec_new() }
                }
            };
            let local: CgLocal = create_local_storage(cg, ctx, name, the_ty);
            store_local(cg, local, val);
            ctx_insert_local(ctx, name, local);
            if is_gc_ref_type(the_ty) {
                ctx.next_root = ctx.next_root + 1;
                emit_pollcheck(cg, ctx);
            };
            null
        },
        Expr::AssignExpr { target, value, span } => {
            let v: RawPointer<I8> = codegen_expr(cg, value, ctx);
            codegen_assign(cg, target, v, ctx);
            null
        },
        Expr::LitExpr { lit, span } => {
            codegen_literal(cg, lit)
        },
        Expr::PathExpr { path, span } => {
            let name: String = vec_get_str(path, vec_len(path) - 1);
            let local: CgLocal = ctx_get_local(ctx, name);
            load_local(cg, local)
        },
        Expr::FieldExpr { base, name, span } => {
            let obj_ptr: RawPointer<I8> = resolve_struct_base(cg, base, ctx);
            let type_name: String = resolve_base_type_name(cg, base, ctx);
            let layout: CgStructLayout = cg_get_struct(cg, type_name);
            let fl: CgFieldLayout = find_field_layout(layout.fields, name);
            let fp: RawPointer<I8> = field_ptr(cg, obj_ptr, fl);
            let loaded: RawPointer<I8> = llvm_build_load(cg.builder, fl.llvm_ty, fp, "field");
            if tag_is_bool(fl.lang_ty_tag) {
                let zero: RawPointer<I8> = llvm_const_int(llvm_int8_type(cg.context), 0, 0);
                return llvm_build_icmp(cg.builder, ICMP_NE(), loaded, zero, "bool");
            };
            loaded
        },
        Expr::BinaryExpr { op, left, right, span } => {
            let l: RawPointer<I8> = codegen_expr(cg, left, ctx);
            let r: RawPointer<I8> = codegen_expr(cg, right, ctx);
            codegen_binary(cg, op, l, r)
        },
        Expr::UnaryExpr { op, operand, span } => {
            let v: RawPointer<I8> = codegen_expr(cg, operand, ctx);
            codegen_unary(cg, op, v)
        },
        Expr::IfExpr { cond, then_branch, else_branch, span } => {
            codegen_if(cg, cond, then_branch, else_branch, ctx)
        },
        Expr::WhileExpr { cond, body, span } => {
            codegen_while(cg, cond, body, ctx);
            null
        },
        Expr::MatchExpr { scrutinee, arms, span } => {
            codegen_match(cg, scrutinee, arms, ctx)
        },
        Expr::CallExpr { callee, args, span } => {
            codegen_call(cg, callee, args, ctx)
        },
        Expr::StructLitExpr { path, fields, span } => {
            codegen_struct_lit(cg, path, fields, ctx)
        },
        Expr::TupleExpr { items, span } => {
            print_str_stderr("codegen error: tuple construction not supported in bootstrap");
            exit_process(1);
            null
        },
        Expr::BlockExpr { block } => {
            codegen_block_value(cg, block, ctx)
        },
        Expr::BreakExpr { span } => {
            let len: I64 = vec_len(ctx.loop_stack);
            let entry: LoopEntry = vec_get_loop(ctx.loop_stack, len - 1);
            llvm_build_br(cg.builder, entry.break_bb);
            null
        },
        Expr::ContinueExpr { span } => {
            let len: I64 = vec_len(ctx.loop_stack);
            let entry: LoopEntry = vec_get_loop(ctx.loop_stack, len - 1);
            emit_pollcheck(cg, ctx);
            llvm_build_br(cg.builder, entry.cond_bb);
            null
        }
    }
}

fn codegen_assign(cg: Codegen, target: Expr, v: RawPointer<I8>, ctx: FnCtx) -> I64 {
    match target {
        Expr::PathExpr { path, span } => {
            let name: String = vec_get_str(path, vec_len(path) - 1);
            let local: CgLocal = ctx_get_local(ctx, name);
            store_local(cg, local, v);
            if local.is_gc_ref { emit_pollcheck(cg, ctx); };
        },
        Expr::FieldExpr { base, name, span } => {
            let obj_ptr: RawPointer<I8> = resolve_struct_base(cg, base, ctx);
            let type_name: String = resolve_base_type_name(cg, base, ctx);
            let layout: CgStructLayout = cg_get_struct(cg, type_name);
            let fl: CgFieldLayout = find_field_layout(layout.fields, name);
            let fp: RawPointer<I8> = field_ptr(cg, obj_ptr, fl);
            let store_val: RawPointer<I8> = if tag_is_bool(fl.lang_ty_tag) {
                llvm_build_zext(cg.builder, v, llvm_int8_type(cg.context), "boolz")
            } else { v };
            llvm_build_store(cg.builder, store_val, fp);
            if tag_is_gc_ref(fl.lang_ty_tag) {
                let wb_args: RawPointer<I8> = vec_new();
                vec_push(wb_args, ctx.thread);
                vec_push(wb_args, obj_ptr);
                vec_push(wb_args, v);
                llvm_build_call(cg.builder, cg.gc_write_barrier_ty, cg.gc_write_barrier_fn, vec_data(wb_args), 3, "wb");
            };
        },
        _ => {
            print_str_stderr("codegen error: unsupported assignment target");
            exit_process(1);
        }
    };
    0
}

fn codegen_literal(cg: Codegen, lit: Literal) -> RawPointer<I8> {
    match lit {
        Literal::IntLiteral { text } => {
            let val: I64 = string_parse_i64(text);
            llvm_const_int(llvm_int64_type(cg.context), val, 1)
        },
        Literal::BoolLiteral { value } => {
            let val: I64 = if value { 1 } else { 0 };
            llvm_const_int(llvm_int1_type(cg.context), val, 0)
        },
        Literal::StrLiteral { text } => {
            let str_len: I64 = string_len(text);
            let const_str: RawPointer<I8> = llvm_const_string(cg.context, text, str_len, 1);
            let arr_ty: RawPointer<I8> = llvm_array_type(llvm_int8_type(cg.context), str_len + 1);
            let name: String = string_concat("__str_lit_", string_from_i64(cg.str_lit_id));
            cg.str_lit_id = cg.str_lit_id + 1;
            let global: RawPointer<I8> = llvm_add_global(cg.llmod, arr_ty, name);
            llvm_set_initializer(global, const_str);
            let zero32: RawPointer<I8> = llvm_const_int(llvm_int32_type(cg.context), 0, 0);
            let gep_idx: RawPointer<I8> = vec_new();
            vec_push(gep_idx, zero32);
            vec_push(gep_idx, zero32);
            llvm_const_gep2(arr_ty, global, vec_data(gep_idx), 2)
        },
        Literal::CharLiteral { value } => {
            llvm_const_int(llvm_int64_type(cg.context), value, 0)
        },
        Literal::UnitLiteral {} => {
            llvm_const_int(llvm_int64_type(cg.context), 0, 0)
        },
        Literal::FloatLiteral { text } => {
            print_str_stderr("codegen error: float literals not supported in bootstrap");
            exit_process(1);
            llvm_const_int(llvm_int64_type(cg.context), 0, 0)
        }
    }
}

fn codegen_unary(cg: Codegen, op: UnaryOp, v: RawPointer<I8>) -> RawPointer<I8> {
    match op {
        UnaryOp::Neg {} => {
            let vty: RawPointer<I8> = llvm_get_value_type(v);
            let kind: I64 = llvm_get_type_kind(vty);
            if kind == TK_FLOAT() || kind == TK_DOUBLE() {
                return llvm_build_fneg(cg.builder, v, "fneg");
            };
            let zero: RawPointer<I8> = llvm_const_int(llvm_int64_type(cg.context), 0, 0);
            llvm_build_sub(cg.builder, zero, v, "neg")
        },
        UnaryOp::Not {} => {
            let one: RawPointer<I8> = llvm_const_int(llvm_int1_type(cg.context), 1, 0);
            llvm_build_xor(cg.builder, v, one, "not")
        }
    }
}

fn codegen_if(cg: Codegen, cond: Expr, then_branch: Block, else_branch: Option<Block>, ctx: FnCtx) -> RawPointer<I8> {
    let cond_val: RawPointer<I8> = codegen_expr(cg, cond, ctx);
    let func: RawPointer<I8> = ctx.function;
    let then_bb: RawPointer<I8> = llvm_append_basic_block(cg.context, func, "then");
    let else_bb: RawPointer<I8> = llvm_append_basic_block(cg.context, func, "else");
    let cont_bb: RawPointer<I8> = llvm_append_basic_block(cg.context, func, "cont");
    llvm_build_cond_br(cg.builder, cond_val, then_bb, else_bb);

    llvm_position_at_end(cg.builder, then_bb);
    let then_val: RawPointer<I8> = codegen_block_value(cg, then_branch, ctx);
    let then_val_bb: RawPointer<I8> = llvm_get_insert_block(cg.builder);
    if llvm_is_null(llvm_get_bb_terminator(then_val_bb)) == 1 {
        llvm_build_br(cg.builder, cont_bb);
    };

    llvm_position_at_end(cg.builder, else_bb);
    let else_val: RawPointer<I8> = match else_branch {
        Option::Some { value } => { codegen_block_value(cg, value, ctx) },
        Option::None {} => { llvm_const_null(llvm_ptr_type(cg.context)) }
    };
    let else_val_bb: RawPointer<I8> = llvm_get_insert_block(cg.builder);
    if llvm_is_null(llvm_get_bb_terminator(else_val_bb)) == 1 {
        llvm_build_br(cg.builder, cont_bb);
    };

    llvm_position_at_end(cg.builder, cont_bb);
    let null: RawPointer<I8> = llvm_const_null(llvm_ptr_type(cg.context));
    // Build phi if both branches produced values
    if llvm_is_null(then_val) == 0 {
        if llvm_is_null(else_val) == 0 {
            let phi_ty: RawPointer<I8> = llvm_get_value_type(then_val);
            let phi: RawPointer<I8> = llvm_build_phi(cg.builder, phi_ty, "iftmp");
            let vals: RawPointer<I8> = vec_new();
            vec_push(vals, then_val);
            vec_push(vals, else_val);
            let bbs: RawPointer<I8> = vec_new();
            vec_push(bbs, then_val_bb);
            vec_push(bbs, else_val_bb);
            llvm_add_incoming(phi, vec_data(vals), vec_data(bbs), 2);
            return phi;
        };
    };
    null
}

fn codegen_while(cg: Codegen, cond: Expr, body: Block, ctx: FnCtx) -> I64 {
    let func: RawPointer<I8> = ctx.function;
    let cond_bb: RawPointer<I8> = llvm_append_basic_block(cg.context, func, "while.cond");
    let body_bb: RawPointer<I8> = llvm_append_basic_block(cg.context, func, "while.body");
    let cont_bb: RawPointer<I8> = llvm_append_basic_block(cg.context, func, "while.cont");
    llvm_build_br(cg.builder, cond_bb);

    llvm_position_at_end(cg.builder, cond_bb);
    let cond_val: RawPointer<I8> = codegen_expr(cg, cond, ctx);
    llvm_build_cond_br(cg.builder, cond_val, body_bb, cont_bb);

    llvm_position_at_end(cg.builder, body_bb);
    vec_push_loop(ctx.loop_stack, LoopEntry { cond_bb: cond_bb, break_bb: cont_bb });
    codegen_block(cg, body, ctx);
    vec_set_len(ctx.loop_stack, vec_len(ctx.loop_stack) - 1);
    let cur_bb: RawPointer<I8> = llvm_get_insert_block(cg.builder);
    if llvm_is_null(llvm_get_bb_terminator(cur_bb)) == 1 {
        emit_pollcheck(cg, ctx);
        llvm_build_br(cg.builder, cond_bb);
    };

    llvm_position_at_end(cg.builder, cont_bb);
    0
}

fn codegen_match(cg: Codegen, scrutinee: Expr, arms: RawPointer<I8>, ctx: FnCtx) -> RawPointer<I8> {
    let null: RawPointer<I8> = llvm_const_null(llvm_ptr_type(cg.context));
    // Determine enum name from first non-wildcard arm
    let mut enum_name: String = "";
    let mut ai: I64 = 0;
    while ai < vec_len(arms) {
        let arm: MatchArm = vec_get_arm(arms, ai);
        match arm.pattern {
            Pattern::PathPat { path, span } => {
                if vec_len(path) >= 2 {
                    enum_name = enum_path_and_variant(path);
                    ai = vec_len(arms);
                };
            },
            Pattern::StructPat { path, fields, span } => {
                if vec_len(path) >= 2 {
                    enum_name = enum_path_and_variant(path);
                    ai = vec_len(arms);
                };
            },
            Pattern::WildcardPat { span } => {}
        };
        ai = ai + 1;
    };

    let layout: CgEnumLayout = cg_get_enum(cg, enum_name);
    let obj_val: RawPointer<I8> = codegen_expr(cg, scrutinee, ctx);
    let tag_val: RawPointer<I8> = load_enum_tag(cg, obj_val, layout);

    let func: RawPointer<I8> = ctx.function;
    let cont_bb: RawPointer<I8> = llvm_append_basic_block(cg.context, func, "match.cont");
    let mut default_bb: RawPointer<I8> = cont_bb;
    let mut has_wildcard: Bool = false;
    let switch_bb: RawPointer<I8> = llvm_get_insert_block(cg.builder);

    // Build switch
    let num_arms: I64 = vec_len(arms);
    let switch_inst: RawPointer<I8> = llvm_build_switch(cg.builder, tag_val, cont_bb, num_arms);

    // Track phi incoming values
    let phi_vals: RawPointer<I8> = vec_new();
    let phi_bbs: RawPointer<I8> = vec_new();

    let mut i: I64 = 0;
    while i < num_arms {
        let arm: MatchArm = vec_get_arm(arms, i);
        let arm_bb: RawPointer<I8> = llvm_append_basic_block(cg.context, func, "match.arm");

        match arm.pattern {
            Pattern::WildcardPat { span } => {
                default_bb = arm_bb;
                has_wildcard = true;
            },
            Pattern::PathPat { path, span } => {
                let vname: String = variant_name_from_path(path);
                let vlayout: CgVariantLayout = cg_get_variant(layout, vname);
                let tag_const: RawPointer<I8> = llvm_const_int(llvm_int32_type(cg.context), vlayout.tag, 0);
                llvm_add_case(switch_inst, tag_const, arm_bb);
            },
            Pattern::StructPat { path, fields, span } => {
                let vname: String = variant_name_from_path(path);
                let vlayout: CgVariantLayout = cg_get_variant(layout, vname);
                let tag_const: RawPointer<I8> = llvm_const_int(llvm_int32_type(cg.context), vlayout.tag, 0);
                llvm_add_case(switch_inst, tag_const, arm_bb);
            }
        };

        // Emit arm body
        llvm_position_at_end(cg.builder, arm_bb);
        ctx_push_scope(ctx);

        // Bind pattern fields
        match arm.pattern {
            Pattern::StructPat { path, fields, span } => {
                let vname: String = variant_name_from_path(path);
                let vlayout: CgVariantLayout = cg_get_variant(layout, vname);
                let raw_base: RawPointer<I8> = enum_raw_base_ptr(cg, obj_val, layout.raw_base);
                let mut fi: I64 = 0;
                while fi < vec_len(fields) {
                    let pf: PatternField = vec_get_pfield(fields, fi);
                    let binding: String = match pf.binding {
                        Option::Some { value } => { value },
                        Option::None {} => { fi = fi + 1; continue; "" }
                    };
                    let vfl: CgVariantFieldLayout = cg_get_variant_field(vlayout, pf.name);
                    let loaded: RawPointer<I8> = if vfl.is_ptr {
                        let slot: RawPointer<I8> = enum_ptr_slot(cg, obj_val, vfl.ptr_index);
                        let ptr_ty: RawPointer<I8> = llvm_ptr_type(cg.context);
                        llvm_build_load(cg.builder, ptr_ty, slot, "enum_field")
                    } else {
                        let fp: RawPointer<I8> = enum_raw_field_ptr(cg, raw_base, vfl.raw_offset);
                        let raw: RawPointer<I8> = llvm_build_load(cg.builder, vfl.llvm_ty, fp, "enum_field");
                        if tag_is_bool(vfl.lang_ty_tag) {
                            let zero: RawPointer<I8> = llvm_const_int(llvm_int8_type(cg.context), 0, 0);
                            llvm_build_icmp(cg.builder, ICMP_NE(), raw, zero, "bool")
                        } else {
                            raw
                        }
                    };
                    // Create local for binding â€” build a Type from the variant field info
                    let local: CgLocal = CgLocal {
                        name: binding,
                        type_name: vfl.type_name,
                        ptr: llvm_const_null(llvm_ptr_type(cg.context)),
                        ty: vfl.llvm_ty,
                        lang_ty_tag: vfl.lang_ty_tag,
                        is_gc_ref: vfl.is_ptr
                    };
                    // For gc refs, use root slot; for raw, use entry alloca
                    let real_local: CgLocal = if vfl.is_ptr {
                        let idx: RawPointer<I8> = llvm_const_int(llvm_int32_type(cg.context), ctx.next_root, 0);
                        let ptr_ty: RawPointer<I8> = llvm_ptr_type(cg.context);
                        let indices: RawPointer<I8> = vec_new();
                        vec_push(indices, idx);
                        let slot_ptr: RawPointer<I8> = llvm_build_gep2(cg.builder, ptr_ty, ctx.root_base, vec_data(indices), 1, "root_slot");
                        CgLocal { name: binding, type_name: vfl.type_name, ptr: slot_ptr, ty: ptr_ty, lang_ty_tag: vfl.lang_ty_tag, is_gc_ref: true }
                    } else {
                        let ptr: RawPointer<I8> = create_entry_alloca(cg, ctx.function, binding, vfl.lang_ty_tag);
                        let lty: RawPointer<I8> = llvm_type_for_tag(cg, vfl.lang_ty_tag);
                        CgLocal { name: binding, type_name: vfl.type_name, ptr: ptr, ty: lty, lang_ty_tag: vfl.lang_ty_tag, is_gc_ref: false }
                    };
                    store_local(cg, real_local, loaded);
                    ctx_insert_local(ctx, binding, real_local);
                    if vfl.is_ptr {
                        ctx.next_root = ctx.next_root + 1;
                    };
                    fi = fi + 1;
                };
            },
            Pattern::PathPat { path, span } => {},
            Pattern::WildcardPat { span } => {}
        };

        let value: RawPointer<I8> = codegen_expr(cg, arm.body, ctx);
        let value_bb: RawPointer<I8> = llvm_get_insert_block(cg.builder);
        if llvm_is_null(llvm_get_bb_terminator(value_bb)) == 1 {
            llvm_build_br(cg.builder, cont_bb);
        };
        if llvm_is_null(value) == 0 {
            vec_push(phi_vals, value);
            vec_push(phi_bbs, value_bb);
        };
        ctx_pop_scope(ctx);
        i = i + 1;
    };

    // Update switch default
    // We can't easily change default after creation, but we built with cont_bb as default.
    // If there's a wildcard, we need to redirect. Rebuild won't work, so just handle
    // the wildcard arm â€” the arm_bb IS connected via the default.
    // Actually the switch was built with cont_bb as default. If wildcard was found,
    // we need to patch it. Since we can't in .lang, let's re-emit from switch_bb.
    // Simpler approach: always build switch after knowing default.
    // For now, this basic approach works if wildcard arm is matched through default_bb.

    llvm_position_at_end(cg.builder, cont_bb);
    if vec_len(phi_vals) > 0 {
        // Add a zero value from switch_bb for default path if needed
        if !has_wildcard {
            if vec_len(phi_vals) > 0 {
                let first_val: RawPointer<I8> = vec_get(phi_vals, 0);
                let zero_ty: RawPointer<I8> = llvm_get_value_type(first_val);
                let zero_val: RawPointer<I8> = llvm_const_int(zero_ty, 0, 0);
                vec_push(phi_vals, zero_val);
                vec_push(phi_bbs, switch_bb);
            };
        };
        let phi_ty: RawPointer<I8> = llvm_get_value_type(vec_get(phi_vals, 0));
        let phi: RawPointer<I8> = llvm_build_phi(cg.builder, phi_ty, "matchtmp");
        llvm_add_incoming(phi, vec_data(phi_vals), vec_data(phi_bbs), vec_len(phi_vals));
        return phi;
    };
    null
}

fn codegen_call(cg: Codegen, callee: Expr, args: RawPointer<I8>, ctx: FnCtx) -> RawPointer<I8> {
    // Check if this is an enum variant constructor
    match callee {
        Expr::PathExpr { path, span } => {
            if vec_len(path) >= 2 {
                let en: String = enum_path_and_variant(path);
                if cg_find_enum(cg, en) == 1 {
                    return codegen_enum_tuple_construct(cg, en, variant_name_from_path(path), args, ctx);
                };
            };
            // Regular function call
            let key: String = path_to_string(path);
            let mut fn_val: RawPointer<I8> = llvm_const_null(llvm_ptr_type(cg.context));
            let mut fn_ty: RawPointer<I8> = llvm_const_null(llvm_ptr_type(cg.context));
            let mut pass_thread: Bool = false;
            if cg_find_fn(cg, key) == 1 {
                let entry: CgFnEntry = cg_get_fn(cg, key);
                fn_val = entry.fn_val;
                fn_ty = entry.fn_ty;
                pass_thread = true;
            } else {
                if cg_find_extern(cg, key) == 1 {
                    let entry: CgFnEntry = cg_get_extern(cg, key);
                    fn_val = entry.fn_val;
                    fn_ty = entry.fn_ty;
                } else {
                    print_str_stderr(string_concat("codegen error: unknown function: ", key));
                    exit_process(1);
                };
            };
            let arg_vals: RawPointer<I8> = vec_new();
            if pass_thread { vec_push(arg_vals, ctx.thread); };
            let mut i: I64 = 0;
            while i < vec_len(args) {
                let arg: Expr = vec_get_expr(args, i);
                let val: RawPointer<I8> = codegen_expr(cg, arg, ctx);
                vec_push(arg_vals, val);
                i = i + 1;
            };
            let call: RawPointer<I8> = llvm_build_call(cg.builder, fn_ty, fn_val, vec_data(arg_vals), vec_len(arg_vals), "call");
            emit_pollcheck(cg, ctx);
            call
        },
        _ => {
            print_str_stderr("codegen error: callee must be path");
            exit_process(1);
            llvm_const_null(llvm_ptr_type(cg.context))
        }
    }
}

fn codegen_enum_tuple_construct(cg: Codegen, enum_name: String, vname: String, args: RawPointer<I8>, ctx: FnCtx) -> RawPointer<I8> {
    let layout: CgEnumLayout = cg_get_enum(cg, enum_name);
    let vlayout: CgVariantLayout = cg_get_variant(layout, vname);

    let size_val: RawPointer<I8> = llvm_const_int(llvm_int64_type(cg.context), layout.size, 0);
    let alloc_args: RawPointer<I8> = vec_new();
    vec_push(alloc_args, ctx.thread);
    vec_push(alloc_args, layout.meta);
    vec_push(alloc_args, size_val);
    let obj_ptr: RawPointer<I8> = llvm_build_call(cg.builder, cg.gc_allocate_ty, cg.gc_allocate_fn, vec_data(alloc_args), 3, "alloc_enum");

    init_header(cg, obj_ptr, layout.meta);
    let raw_base: RawPointer<I8> = enum_raw_base_ptr(cg, obj_ptr, layout.raw_base);
    let tag_val: RawPointer<I8> = llvm_const_int(llvm_int32_type(cg.context), vlayout.tag, 0);
    llvm_build_store(cg.builder, tag_val, raw_base);

    let mut i: I64 = 0;
    while i < vec_len(args) {
        let arg: Expr = vec_get_expr(args, i);
        let arg_val: RawPointer<I8> = codegen_expr(cg, arg, ctx);
        let vfl: CgVariantFieldLayout = vec_get_cgvfl(vlayout.fields, i);
        if vfl.is_ptr {
            let slot: RawPointer<I8> = enum_ptr_slot(cg, obj_ptr, vfl.ptr_index);
            llvm_build_store(cg.builder, arg_val, slot);
        } else {
            let fp: RawPointer<I8> = enum_raw_field_ptr(cg, raw_base, vfl.raw_offset);
            let sv: RawPointer<I8> = if tag_is_bool(vfl.lang_ty_tag) {
                llvm_build_zext(cg.builder, arg_val, llvm_int8_type(cg.context), "boolz")
            } else { arg_val };
            llvm_build_store(cg.builder, sv, fp);
        };
        i = i + 1;
    };
    emit_pollcheck(cg, ctx);
    obj_ptr
}

fn codegen_struct_lit(cg: Codegen, path: RawPointer<I8>, fields: RawPointer<I8>, ctx: FnCtx) -> RawPointer<I8> {
    // Check if it's an enum variant struct literal
    if vec_len(path) >= 2 {
        let en: String = enum_path_and_variant(path);
        if cg_find_enum(cg, en) == 1 {
            return codegen_enum_struct_construct(cg, en, variant_name_from_path(path), fields, ctx);
        };
    };

    // Regular struct literal
    let name: String = path_to_string(path);
    let layout: CgStructLayout = cg_get_struct(cg, name);
    let size_val: RawPointer<I8> = llvm_const_int(llvm_int64_type(cg.context), layout.size, 0);
    let alloc_args: RawPointer<I8> = vec_new();
    vec_push(alloc_args, ctx.thread);
    vec_push(alloc_args, layout.meta);
    vec_push(alloc_args, size_val);
    let obj_ptr: RawPointer<I8> = llvm_build_call(cg.builder, cg.gc_allocate_ty, cg.gc_allocate_fn, vec_data(alloc_args), 3, "alloc");
    init_header(cg, obj_ptr, layout.meta);

    let mut i: I64 = 0;
    while i < vec_len(fields) {
        let sf: StructLitField = vec_get_slfield(fields, i);
        let fl: CgFieldLayout = find_field_layout(layout.fields, sf.name);
        let value: RawPointer<I8> = codegen_expr(cg, sf.value, ctx);
        let fp: RawPointer<I8> = field_ptr(cg, obj_ptr, fl);
        let sv: RawPointer<I8> = if tag_is_bool(fl.lang_ty_tag) {
            llvm_build_zext(cg.builder, value, llvm_int8_type(cg.context), "boolz")
        } else { value };
        llvm_build_store(cg.builder, sv, fp);
        i = i + 1;
    };
    emit_pollcheck(cg, ctx);
    obj_ptr
}

fn codegen_enum_struct_construct(cg: Codegen, enum_name: String, vname: String, fields: RawPointer<I8>, ctx: FnCtx) -> RawPointer<I8> {
    let layout: CgEnumLayout = cg_get_enum(cg, enum_name);
    let vlayout: CgVariantLayout = cg_get_variant(layout, vname);

    let size_val: RawPointer<I8> = llvm_const_int(llvm_int64_type(cg.context), layout.size, 0);
    let alloc_args: RawPointer<I8> = vec_new();
    vec_push(alloc_args, ctx.thread);
    vec_push(alloc_args, layout.meta);
    vec_push(alloc_args, size_val);
    let obj_ptr: RawPointer<I8> = llvm_build_call(cg.builder, cg.gc_allocate_ty, cg.gc_allocate_fn, vec_data(alloc_args), 3, "alloc_enum");
    init_header(cg, obj_ptr, layout.meta);

    let raw_base: RawPointer<I8> = enum_raw_base_ptr(cg, obj_ptr, layout.raw_base);
    let tag_val: RawPointer<I8> = llvm_const_int(llvm_int32_type(cg.context), vlayout.tag, 0);
    llvm_build_store(cg.builder, tag_val, raw_base);

    let mut i: I64 = 0;
    while i < vec_len(fields) {
        let sf: StructLitField = vec_get_slfield(fields, i);
        let vfl: CgVariantFieldLayout = cg_get_variant_field(vlayout, sf.name);
        let value: RawPointer<I8> = codegen_expr(cg, sf.value, ctx);
        if vfl.is_ptr {
            let slot: RawPointer<I8> = enum_ptr_slot(cg, obj_ptr, vfl.ptr_index);
            llvm_build_store(cg.builder, value, slot);
        } else {
            let fp: RawPointer<I8> = enum_raw_field_ptr(cg, raw_base, vfl.raw_offset);
            let sv: RawPointer<I8> = if tag_is_bool(vfl.lang_ty_tag) {
                llvm_build_zext(cg.builder, value, llvm_int8_type(cg.context), "boolz")
            } else { value };
            llvm_build_store(cg.builder, sv, fp);
        };
        i = i + 1;
    };
    emit_pollcheck(cg, ctx);
    obj_ptr
}

// ---------------------------------------------------------------------------
// Function definition
// ---------------------------------------------------------------------------

fn define_functions(cg: Codegen, modules: RawPointer<I8>) -> I64 {
    let mut mi: I64 = 0;
    while mi < vec_len(modules) {
        let m: Module = vec_get_module(modules, mi);
        let mut ii: I64 = 0;
        while ii < vec_len(m.items) {
            let item: Item = vec_get_item(m.items, ii);
            match item {
                Item::FnItem { decl } => {
                    let fname: String = full_item_name(m.path, decl.name);
                    define_fn(cg, fname, decl);
                },
                Item::StructItem { decl } => {},
                Item::EnumItem { decl } => {},
                Item::ExternFnItem { decl } => {},
                Item::UseItem { decl } => {}
            };
            ii = ii + 1;
        };
        mi = mi + 1;
    };
    0
}

fn define_fn(cg: Codegen, full_name: String, f: FnDecl) -> I64 {
    let entry_obj: CgFnEntry = cg_get_fn(cg, full_name);
    let function: RawPointer<I8> = entry_obj.fn_val;
    let entry_bb: RawPointer<I8> = llvm_append_basic_block(cg.context, function, "entry");
    llvm_position_at_end(cg.builder, entry_bb);

    let thread: RawPointer<I8> = llvm_get_param(function, 0);
    let num_roots: I64 = count_roots_in_fn(cg, f.params, f.body);
    let ft: RawPointer<I8> = make_frame_type(cg, num_roots);
    let mut ctx: FnCtx = emit_prologue(cg, function, thread, full_name, num_roots, ft);
    ctx.function = function;

    // Store params
    let mut param_root_index: I64 = 0;
    let mut i: I64 = 0;
    while i < vec_len(f.params) {
        let p: Param = vec_get_param(f.params, i);
        let local: CgLocal = create_local_storage(cg, ctx, p.name, p.ty);
        let arg: RawPointer<I8> = llvm_get_param(function, i + 1);
        store_local(cg, local, arg);
        ctx_insert_local(ctx, p.name, local);
        if is_gc_ref_type(p.ty) {
            ctx.next_root = ctx.next_root + 1;
        };
        i = i + 1;
    };

    let value: RawPointer<I8> = codegen_block_value(cg, f.body, ctx);
    let cur_bb: RawPointer<I8> = llvm_get_insert_block(cg.builder);
    if llvm_is_null(llvm_get_bb_terminator(cur_bb)) == 1 {
        let ret_val: RawPointer<I8> = if llvm_is_null(value) == 1 {
            llvm_const_int(llvm_int64_type(cg.context), 0, 0)
        } else { value };
        emit_epilogue(cg, ctx);
        llvm_build_ret(cg.builder, ret_val);
    };
    0
}

// ---------------------------------------------------------------------------
// AOT wrapper main
// ---------------------------------------------------------------------------

fn emit_aot_wrapper_main(cg: Codegen) -> I64 {
    let lang_main_entry: CgFnEntry = cg_get_fn(cg, "main");
    let lang_main: RawPointer<I8> = lang_main_entry.fn_val;
    let lang_main_ty: RawPointer<I8> = lang_main_entry.fn_ty;

    let ctx: RawPointer<I8> = cg.context;
    let i32_ty: RawPointer<I8> = llvm_int32_type(ctx);
    let ptr_ty: RawPointer<I8> = llvm_ptr_type(ctx);

    let wrapper_params: RawPointer<I8> = vec_new();
    vec_push(wrapper_params, i32_ty);
    vec_push(wrapper_params, ptr_ty);
    let wrapper_ty: RawPointer<I8> = llvm_function_type(i32_ty, vec_data(wrapper_params), 2, 0);
    let wrapper: RawPointer<I8> = llvm_add_function(cg.llmod, "main", wrapper_ty);

    let entry_bb: RawPointer<I8> = llvm_append_basic_block(ctx, wrapper, "entry");
    llvm_position_at_end(cg.builder, entry_bb);

    let argc: RawPointer<I8> = llvm_get_param(wrapper, 0);
    let argv: RawPointer<I8> = llvm_get_param(wrapper, 1);

    // Call rt_init_args(argc, argv)
    let void_ty: RawPointer<I8> = llvm_void_type(ctx);
    let init_params: RawPointer<I8> = vec_new();
    vec_push(init_params, i32_ty);
    vec_push(init_params, ptr_ty);
    let init_ty: RawPointer<I8> = llvm_function_type(void_ty, vec_data(init_params), 2, 0);
    let init_fn: RawPointer<I8> = llvm_get_named_function(cg.llmod, "rt_init_args");
    let actual_init: RawPointer<I8> = if llvm_is_null(init_fn) == 1 {
        llvm_add_function(cg.llmod, "rt_init_args", init_ty)
    } else { init_fn };
    let init_args: RawPointer<I8> = vec_new();
    vec_push(init_args, argc);
    vec_push(init_args, argv);
    llvm_build_call(cg.builder, init_ty, actual_init, vec_data(init_args), 2, "init_args");

    // Alloca thread struct
    let thread_alloca: RawPointer<I8> = llvm_build_alloca(cg.builder, cg.thread_struct_ty, "thread");
    let top_ptr: RawPointer<I8> = llvm_build_struct_gep2(cg.builder, cg.thread_struct_ty, thread_alloca, 0, "thread.top");
    let state_ptr: RawPointer<I8> = llvm_build_struct_gep2(cg.builder, cg.thread_struct_ty, thread_alloca, 1, "thread.state");
    let pad_ptr: RawPointer<I8> = llvm_build_struct_gep2(cg.builder, cg.thread_struct_ty, thread_alloca, 2, "thread.pad");
    llvm_build_store(cg.builder, llvm_const_null(ptr_ty), top_ptr);
    llvm_build_store(cg.builder, llvm_const_int(i32_ty, 0, 0), state_ptr);
    llvm_build_store(cg.builder, llvm_const_int(i32_ty, 0, 0), pad_ptr);

    let thread_ptr: RawPointer<I8> = llvm_build_bitcast(cg.builder, thread_alloca, ptr_ty, "thread_ptr");
    let call_args: RawPointer<I8> = vec_new();
    vec_push(call_args, thread_ptr);
    let call: RawPointer<I8> = llvm_build_call(cg.builder, lang_main_ty, lang_main, vec_data(call_args), 1, "lang_main");
    let ret_i32: RawPointer<I8> = llvm_build_trunc(cg.builder, call, i32_ty, "ret");
    llvm_build_ret(cg.builder, ret_i32);
    0
}

// ---------------------------------------------------------------------------
// Compile to object file
// ---------------------------------------------------------------------------

fn compile_to_object(cg: Codegen, output_path: String) -> I64 {
    llvm_init_native_target();
    llvm_init_native_asm_printer();

    let triple: String = llvm_get_default_triple();
    let target: RawPointer<I8> = llvm_get_target_from_triple(triple);
    let cpu: String = llvm_get_host_cpu_name();
    let features: String = llvm_get_host_cpu_features();
    let machine: RawPointer<I8> = llvm_create_target_machine(target, triple, cpu, features);
    llvm_set_module_target(cg.llmod, machine);

    let result: I64 = llvm_emit_to_file(machine, cg.llmod, output_path);
    if result != 0 {
        print_str_stderr("codegen error: failed to emit object file");
        exit_process(1);
    };
    0
}

// ---------------------------------------------------------------------------
// Entry point: codegen_modules
// ---------------------------------------------------------------------------

fn codegen_modules(modules: RawPointer<I8>, output_path: String) -> I64 {
    let cg: Codegen = new_codegen();
    declare_structs(cg, modules);
    declare_enums(cg, modules);
    declare_functions(cg, modules);
    define_functions(cg, modules);
    emit_aot_wrapper_main(cg);
    compile_to_object(cg, output_path);
    0
}
