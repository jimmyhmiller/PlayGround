// ---------------------------------------------------------------------------
// Qualify pass â€” rewrite AST paths to fully-qualified form
// ---------------------------------------------------------------------------

use ast::Option;
use ast::Span;
use ast::Module;
use ast::Item;
use ast::FnDecl;
use ast::ExternFnDecl;
use ast::StructDecl;
use ast::EnumDecl;
use ast::EnumVariant;
use ast::EnumVariantKind;
use ast::UseDecl;
use ast::Field;
use ast::Param;
use ast::Block;
use ast::Stmt;
use ast::Expr;
use ast::Literal;
use ast::BinaryOp;
use ast::UnaryOp;
use ast::Type;
use ast::Pattern;
use ast::MatchArm;
use ast::PatternField;
use ast::StructLitField;
use ast::ItemEntry;
use ast::UseEntry;

extern fn vec_new() -> RawPointer<I8>;
extern fn vec_len(v: RawPointer<I8>) -> I64;
extern fn vec_clear(v: RawPointer<I8>) -> I64;
extern fn vec_set_len(v: RawPointer<I8>, new_len: I64) -> I64;

extern fn vec_push_str(v: RawPointer<I8>, item: String) -> I64;
extern fn vec_get_str(v: RawPointer<I8>, index: I64) -> String;
extern fn vec_push_item(v: RawPointer<I8>, item: Item) -> I64;
extern fn vec_get_item(v: RawPointer<I8>, index: I64) -> Item;
extern fn vec_push_ientry(v: RawPointer<I8>, item: ItemEntry) -> I64;
extern fn vec_get_ientry(v: RawPointer<I8>, index: I64) -> ItemEntry;
extern fn vec_push_uentry(v: RawPointer<I8>, item: UseEntry) -> I64;
extern fn vec_get_uentry(v: RawPointer<I8>, index: I64) -> UseEntry;
extern fn vec_push_vec(v: RawPointer<I8>, item: RawPointer<I8>) -> I64;
extern fn vec_get_vec(v: RawPointer<I8>, index: I64) -> RawPointer<I8>;
extern fn vec_push_module(v: RawPointer<I8>, item: Module) -> I64;
extern fn vec_get_module(v: RawPointer<I8>, index: I64) -> Module;
extern fn vec_push_field(v: RawPointer<I8>, item: Field) -> I64;
extern fn vec_get_field(v: RawPointer<I8>, index: I64) -> Field;
extern fn vec_push_param(v: RawPointer<I8>, item: Param) -> I64;
extern fn vec_get_param(v: RawPointer<I8>, index: I64) -> Param;
extern fn vec_get_variant(v: RawPointer<I8>, index: I64) -> EnumVariant;
extern fn vec_push_type(v: RawPointer<I8>, item: Type) -> I64;
extern fn vec_get_type(v: RawPointer<I8>, index: I64) -> Type;
extern fn vec_push_expr(v: RawPointer<I8>, item: Expr) -> I64;
extern fn vec_get_expr(v: RawPointer<I8>, index: I64) -> Expr;
extern fn vec_get_arm(v: RawPointer<I8>, index: I64) -> MatchArm;
extern fn vec_get_stmt(v: RawPointer<I8>, index: I64) -> Stmt;
extern fn vec_get_pfield(v: RawPointer<I8>, index: I64) -> PatternField;
extern fn vec_get_slfield(v: RawPointer<I8>, index: I64) -> StructLitField;

extern fn string_eq(a: String, b: String) -> I64;
extern fn string_concat(a: String, b: String) -> String;
extern fn string_from_i64(val: I64) -> String;
extern fn print_str(s: String) -> I64;
extern fn print_str_stderr(s: String) -> I64;
extern fn exit_process(code: I64) -> I64;
extern fn null_ptr() -> RawPointer<I8>;
extern fn ptr_is_null(p: RawPointer<I8>) -> I64;

fn IK_STRUCT() -> I64 { 1 }
fn IK_ENUM() -> I64 { 2 }
fn IK_FN() -> I64 { 3 }
fn IK_EXTERN_FN() -> I64 { 4 }

struct Qualifier {
    module_path: RawPointer<I8>,
    use_map: RawPointer<I8>,
    items: RawPointer<I8>,
    locals: RawPointer<I8>,
    type_params: RawPointer<I8>
}

fn path_to_string(path: RawPointer<I8>) -> String {
    let len: I64 = vec_len(path);
    if len == 0 { return ""; };
    let mut result: String = vec_get_str(path, 0);
    let mut i: I64 = 1;
    while i < len {
        result = string_concat(result, string_concat("::", vec_get_str(path, i)));
        i = i + 1;
    };
    result
}

fn full_item_name(module_path: RawPointer<I8>, name: String) -> String {
    if vec_len(module_path) == 0 { name }
    else { string_concat(path_to_string(module_path), string_concat("::", name)) }
}

fn is_builtin_type(name: String) -> Bool {
    if string_eq(name, "I8") == 1 { return true; };
    if string_eq(name, "I16") == 1 { return true; };
    if string_eq(name, "I32") == 1 { return true; };
    if string_eq(name, "I64") == 1 { return true; };
    if string_eq(name, "U8") == 1 { return true; };
    if string_eq(name, "U16") == 1 { return true; };
    if string_eq(name, "U32") == 1 { return true; };
    if string_eq(name, "U64") == 1 { return true; };
    if string_eq(name, "F32") == 1 { return true; };
    if string_eq(name, "F64") == 1 { return true; };
    if string_eq(name, "Bool") == 1 { return true; };
    if string_eq(name, "Unit") == 1 { return true; };
    if string_eq(name, "String") == 1 { return true; };
    false
}

fn qualify_error(msg: String) -> I64 {
    print_str_stderr(string_concat("qualify error: ", msg));
    exit_process(1); 0
}

fn items_contains(items: RawPointer<I8>, name: String) -> Bool {
    let len: I64 = vec_len(items);
    let mut i: I64 = 0;
    while i < len {
        let entry: ItemEntry = vec_get_ientry(items, i);
        if string_eq(entry.name, name) == 1 { return true; };
        i = i + 1;
    };
    false
}

fn use_map_get(use_map: RawPointer<I8>, alias: String) -> RawPointer<I8> {
    let len: I64 = vec_len(use_map);
    let mut i: I64 = 0;
    while i < len {
        let entry: UseEntry = vec_get_uentry(use_map, i);
        if string_eq(entry.alias, alias) == 1 { return entry.path; };
        i = i + 1;
    };
    null_ptr()
}

fn use_map_contains(use_map: RawPointer<I8>, alias: String) -> Bool {
    ptr_is_null(use_map_get(use_map, alias)) == 0
}

fn locals_push(q: Qualifier) -> I64 { vec_push_vec(q.locals, vec_new()); 0 }

fn locals_pop(q: Qualifier) -> I64 {
    let len: I64 = vec_len(q.locals);
    if len > 0 { vec_set_len(q.locals, len - 1); };
    0
}

fn locals_insert(q: Qualifier, name: String) -> I64 {
    let len: I64 = vec_len(q.locals);
    if len > 0 { vec_push_str(vec_get_vec(q.locals, len - 1), name); };
    0
}

fn locals_contains(q: Qualifier, name: String) -> Bool {
    let num_frames: I64 = vec_len(q.locals);
    let mut fi: I64 = num_frames - 1;
    while fi >= 0 {
        let frame: RawPointer<I8> = vec_get_vec(q.locals, fi);
        let frame_len: I64 = vec_len(frame);
        let mut j: I64 = 0;
        while j < frame_len {
            if string_eq(vec_get_str(frame, j), name) == 1 { return true; };
            j = j + 1;
        };
        fi = fi - 1;
    };
    false
}

fn type_params_contains(tp: RawPointer<I8>, name: String) -> Bool {
    let len: I64 = vec_len(tp);
    let mut i: I64 = 0;
    while i < len {
        if string_eq(vec_get_str(tp, i), name) == 1 { return true; };
        i = i + 1;
    };
    false
}

fn replace_path(old_path: RawPointer<I8>, new_segments: RawPointer<I8>) -> I64 {
    vec_clear(old_path);
    let len: I64 = vec_len(new_segments);
    let mut i: I64 = 0;
    while i < len { vec_push_str(old_path, vec_get_str(new_segments, i)); i = i + 1; };
    0
}

fn collect_global_items(modules: RawPointer<I8>) -> RawPointer<I8> {
    let items: RawPointer<I8> = vec_new();
    let num_modules: I64 = vec_len(modules);
    let mut mi: I64 = 0;
    while mi < num_modules {
        let m: Module = vec_get_module(modules, mi);
        let mod_path: RawPointer<I8> = m.path;
        let num_items: I64 = vec_len(m.items);
        let mut ii: I64 = 0;
        while ii < num_items {
            let item: Item = vec_get_item(m.items, ii);
            match item {
                Item::FnItem { decl } => {
                    let full: String = full_item_name(mod_path, decl.name);
                    if items_contains(items, full) { qualify_error(string_concat("duplicate item '", string_concat(full, "'"))); };
                    vec_push_ientry(items, ItemEntry { name: full, kind: IK_FN() });
                },
                Item::StructItem { decl } => {
                    let full: String = full_item_name(mod_path, decl.name);
                    if items_contains(items, full) { qualify_error(string_concat("duplicate item '", string_concat(full, "'"))); };
                    vec_push_ientry(items, ItemEntry { name: full, kind: IK_STRUCT() });
                },
                Item::EnumItem { decl } => {
                    let full: String = full_item_name(mod_path, decl.name);
                    if items_contains(items, full) { qualify_error(string_concat("duplicate item '", string_concat(full, "'"))); };
                    vec_push_ientry(items, ItemEntry { name: full, kind: IK_ENUM() });
                },
                Item::ExternFnItem { decl } => {
                    let full: String = full_item_name(mod_path, decl.name);
                    if items_contains(items, full) { qualify_error(string_concat("duplicate item '", string_concat(full, "'"))); };
                    vec_push_ientry(items, ItemEntry { name: full, kind: IK_EXTERN_FN() });
                },
                Item::UseItem { decl } => {}
            };
            ii = ii + 1;
        };
        mi = mi + 1;
    };
    items
}

fn build_use_map(items: RawPointer<I8>, module_path: RawPointer<I8>, m: Module) -> RawPointer<I8> {
    let use_map: RawPointer<I8> = vec_new();
    let num_items: I64 = vec_len(m.items);
    let mut ii: I64 = 0;
    while ii < num_items {
        let item: Item = vec_get_item(m.items, ii);
        match item {
            Item::UseItem { decl } => {
                let path: RawPointer<I8> = decl.path;
                let path_len: I64 = vec_len(path);
                if path_len > 0 {
                    let alias: String = vec_get_str(path, path_len - 1);
                    if use_map_contains(use_map, alias) { qualify_error(string_concat("duplicate use alias '", string_concat(alias, "'"))); };
                    let abs_key: String = path_to_string(path);
                    if items_contains(items, abs_key) {
                        vec_push_uentry(use_map, UseEntry { alias: alias, path: path });
                    } else {
                        if vec_len(module_path) > 0 {
                            let rel: RawPointer<I8> = vec_new();
                            let mp_len: I64 = vec_len(module_path);
                            let mut k: I64 = 0;
                            while k < mp_len { vec_push_str(rel, vec_get_str(module_path, k)); k = k + 1; };
                            k = 0;
                            while k < path_len { vec_push_str(rel, vec_get_str(path, k)); k = k + 1; };
                            let rel_key: String = path_to_string(rel);
                            if items_contains(items, rel_key) {
                                vec_push_uentry(use_map, UseEntry { alias: alias, path: rel });
                            } else { qualify_error(string_concat("unresolved use path '", string_concat(abs_key, "'"))); };
                        } else { qualify_error(string_concat("unresolved use path '", string_concat(abs_key, "'"))); };
                    };
                };
            },
            _ => {}
        };
        ii = ii + 1;
    };
    use_map
}

fn qualify_path_common(q: Qualifier, path: RawPointer<I8>) -> I64 {
    let len: I64 = vec_len(path);
    if len == 0 { return 0; };
    if len == 1 {
        let name: String = vec_get_str(path, 0);
        let mapped: RawPointer<I8> = use_map_get(q.use_map, name);
        if ptr_is_null(mapped) == 0 { replace_path(path, mapped); return 0; };
        if vec_len(q.module_path) > 0 {
            let full: RawPointer<I8> = vec_new();
            let mp_len: I64 = vec_len(q.module_path);
            let mut k: I64 = 0;
            while k < mp_len { vec_push_str(full, vec_get_str(q.module_path, k)); k = k + 1; };
            vec_push_str(full, name);
            if items_contains(q.items, path_to_string(full)) { replace_path(path, full); };
        };
        return 0;
    };
    let first: String = vec_get_str(path, 0);
    let mapped: RawPointer<I8> = use_map_get(q.use_map, first);
    if ptr_is_null(mapped) == 0 {
        let out: RawPointer<I8> = vec_new();
        let mapped_len: I64 = vec_len(mapped);
        let mut k: I64 = 0;
        while k < mapped_len { vec_push_str(out, vec_get_str(mapped, k)); k = k + 1; };
        k = 1;
        while k < len { vec_push_str(out, vec_get_str(path, k)); k = k + 1; };
        replace_path(path, out);
        return 0;
    };
    if vec_len(q.module_path) > 0 {
        let candidate: RawPointer<I8> = vec_new();
        let mp_len: I64 = vec_len(q.module_path);
        let mut k: I64 = 0;
        while k < mp_len { vec_push_str(candidate, vec_get_str(q.module_path, k)); k = k + 1; };
        vec_push_str(candidate, first);
        if items_contains(q.items, path_to_string(candidate)) {
            let out: RawPointer<I8> = vec_new();
            k = 0;
            while k < mp_len { vec_push_str(out, vec_get_str(q.module_path, k)); k = k + 1; };
            k = 0;
            while k < len { vec_push_str(out, vec_get_str(path, k)); k = k + 1; };
            replace_path(path, out);
        };
    };
    0
}

fn qualify_type_path(q: Qualifier, path: RawPointer<I8>) -> I64 {
    let len: I64 = vec_len(path);
    if len == 1 {
        let name: String = vec_get_str(path, 0);
        if is_builtin_type(name) { return 0; };
        if type_params_contains(q.type_params, name) { return 0; };
    };
    qualify_path_common(q, path); 0
}

fn qualify_value_path(q: Qualifier, path: RawPointer<I8>, span: Span) -> I64 {
    let len: I64 = vec_len(path);
    if len == 1 { if locals_contains(q, vec_get_str(path, 0)) { return 0; }; };
    qualify_path_common(q, path); 0
}

fn qualify_type(q: Qualifier, ty: Type) -> I64 {
    match ty {
        Type::PathType { path, type_args } => {
            qualify_type_path(q, path);
            let num_args: I64 = vec_len(type_args);
            let mut ai: I64 = 0;
            while ai < num_args { qualify_type(q, vec_get_type(type_args, ai)); ai = ai + 1; };
        },
        Type::RawPtrType { inner } => { qualify_type(q, inner); },
        Type::TupleType { types } => {
            let num_types: I64 = vec_len(types);
            let mut ti: I64 = 0;
            while ti < num_types { qualify_type(q, vec_get_type(types, ti)); ti = ti + 1; };
        }
    };
    0
}

fn qualify_pattern(q: Qualifier, pat: Pattern) -> I64 {
    match pat {
        Pattern::WildcardPat { span } => {},
        Pattern::PathPat { path, span } => { qualify_value_path(q, path, span); },
        Pattern::StructPat { path, fields, span } => {
            qualify_value_path(q, path, span);
            let num_fields: I64 = vec_len(fields);
            let mut fi: I64 = 0;
            while fi < num_fields {
                let pf: PatternField = vec_get_pfield(fields, fi);
                match pf.binding {
                    Option::Some { value: binding } => { locals_insert(q, binding); },
                    Option::None {} => {}
                };
                fi = fi + 1;
            };
        }
    };
    0
}

fn qualify_block(q: Qualifier, block: Block) -> I64 {
    locals_push(q);
    let num_stmts: I64 = vec_len(block.stmts);
    let mut si: I64 = 0;
    while si < num_stmts {
        let stmt: Stmt = vec_get_stmt(block.stmts, si);
        match stmt {
            Stmt::ExprStmt { expr, span } => { qualify_expr(q, expr); },
            Stmt::ReturnStmt { value, span } => {
                match value {
                    Option::Some { value: rv } => { qualify_expr(q, rv); },
                    Option::None {} => {}
                };
            }
        };
        si = si + 1;
    };
    match block.tail {
        Option::Some { value: tail_expr } => { qualify_expr(q, tail_expr); },
        Option::None {} => {}
    };
    locals_pop(q);
    0
}

fn qualify_expr(q: Qualifier, expr: Expr) -> I64 {
    match expr {
        Expr::LetExpr { name, mutable, ty, value, span } => {
            match ty {
                Option::Some { value: t } => { qualify_type(q, t); },
                Option::None {} => {}
            };
            qualify_expr(q, value);
            locals_insert(q, name);
        },
        Expr::IfExpr { cond, then_branch, else_branch, span } => {
            qualify_expr(q, cond);
            qualify_block(q, then_branch);
            match else_branch {
                Option::Some { value: eb } => { qualify_block(q, eb); },
                Option::None {} => {}
            };
        },
        Expr::WhileExpr { cond, body, span } => {
            qualify_expr(q, cond);
            qualify_block(q, body);
        },
        Expr::MatchExpr { scrutinee, arms, span } => {
            qualify_expr(q, scrutinee);
            let num_arms: I64 = vec_len(arms);
            let mut ai: I64 = 0;
            while ai < num_arms {
                let arm: MatchArm = vec_get_arm(arms, ai);
                locals_push(q);
                qualify_pattern(q, arm.pattern);
                qualify_expr(q, arm.body);
                locals_pop(q);
                ai = ai + 1;
            };
        },
        Expr::AssignExpr { target, value, span } => {
            qualify_expr(q, target);
            qualify_expr(q, value);
        },
        Expr::BinaryExpr { op, left, right, span } => {
            qualify_expr(q, left);
            qualify_expr(q, right);
        },
        Expr::UnaryExpr { op, operand, span } => {
            qualify_expr(q, operand);
        },
        Expr::CallExpr { callee, args, span } => {
            qualify_expr(q, callee);
            let num_args: I64 = vec_len(args);
            let mut ai: I64 = 0;
            while ai < num_args { qualify_expr(q, vec_get_expr(args, ai)); ai = ai + 1; };
        },
        Expr::FieldExpr { base, name, span } => {
            qualify_expr(q, base);
        },
        Expr::PathExpr { path, span } => {
            qualify_value_path(q, path, span);
        },
        Expr::StructLitExpr { path, fields, span } => {
            qualify_value_path(q, path, span);
            let num_fields: I64 = vec_len(fields);
            let mut fi: I64 = 0;
            while fi < num_fields {
                let sf: StructLitField = vec_get_slfield(fields, fi);
                qualify_expr(q, sf.value);
                fi = fi + 1;
            };
        },
        Expr::TupleExpr { items, span } => {
            let num_items: I64 = vec_len(items);
            let mut ii: I64 = 0;
            while ii < num_items { qualify_expr(q, vec_get_expr(items, ii)); ii = ii + 1; };
        },
        Expr::LitExpr { lit, span } => {},
        Expr::BlockExpr { block } => { qualify_block(q, block); },
        Expr::BreakExpr { span } => {},
        Expr::ContinueExpr { span } => {}
    };
    0
}

fn qualify_fields_types(q: Qualifier, fields: RawPointer<I8>) -> I64 {
    let num: I64 = vec_len(fields);
    let mut i: I64 = 0;
    while i < num {
        let f: Field = vec_get_field(fields, i);
        qualify_type(q, f.ty);
        i = i + 1;
    };
    0
}

fn qualify_params(q: Qualifier, params: RawPointer<I8>, register_locals: Bool) -> I64 {
    let num: I64 = vec_len(params);
    let mut i: I64 = 0;
    while i < num {
        let p: Param = vec_get_param(params, i);
        qualify_type(q, p.ty);
        if register_locals { locals_insert(q, p.name); };
        i = i + 1;
    };
    0
}

fn qualify_module(q: Qualifier, m: Module) -> I64 {
    let num_items: I64 = vec_len(m.items);
    let mut ii: I64 = 0;
    while ii < num_items {
        let item: Item = vec_get_item(m.items, ii);
        match item {
            Item::StructItem { decl } => {
                vec_clear(q.type_params);
                let tp_len: I64 = vec_len(decl.type_params);
                let mut k: I64 = 0;
                while k < tp_len { vec_push_str(q.type_params, vec_get_str(decl.type_params, k)); k = k + 1; };
                qualify_fields_types(q, decl.fields);
                vec_clear(q.type_params);
            },
            Item::EnumItem { decl } => {
                vec_clear(q.type_params);
                let tp_len: I64 = vec_len(decl.type_params);
                let mut k: I64 = 0;
                while k < tp_len { vec_push_str(q.type_params, vec_get_str(decl.type_params, k)); k = k + 1; };
                let num_variants: I64 = vec_len(decl.variants);
                let mut vi: I64 = 0;
                while vi < num_variants {
                    let variant: EnumVariant = vec_get_variant(decl.variants, vi);
                    match variant.kind {
                        EnumVariantKind::UnitKind {} => {},
                        EnumVariantKind::TupleKind { types } => {
                            let num_types: I64 = vec_len(types);
                            let mut ti: I64 = 0;
                            while ti < num_types { qualify_type(q, vec_get_type(types, ti)); ti = ti + 1; };
                        },
                        EnumVariantKind::StructKind { fields } => {
                            qualify_fields_types(q, fields);
                        }
                    };
                    vi = vi + 1;
                };
                vec_clear(q.type_params);
            },
            Item::FnItem { decl } => {
                locals_push(q);
                qualify_params(q, decl.params, true);
                qualify_type(q, decl.ret_type);
                qualify_block(q, decl.body);
                locals_pop(q);
            },
            Item::ExternFnItem { decl } => {
                qualify_params(q, decl.params, false);
                qualify_type(q, decl.ret_type);
            },
            Item::UseItem { decl } => {}
        };
        ii = ii + 1;
    };
    0
}

fn qualify_modules(modules: RawPointer<I8>) -> I64 {
    let items: RawPointer<I8> = collect_global_items(modules);
    let num_modules: I64 = vec_len(modules);
    let mut mi: I64 = 0;
    while mi < num_modules {
        let m: Module = vec_get_module(modules, mi);
        let use_map: RawPointer<I8> = build_use_map(items, m.path, m);
        let locals: RawPointer<I8> = vec_new();
        vec_push_vec(locals, vec_new());
        let q: Qualifier = Qualifier {
            module_path: m.path, use_map: use_map, items: items,
            locals: locals, type_params: vec_new()
        };
        qualify_module(q, m);
        mi = mi + 1;
    };
    0
}
