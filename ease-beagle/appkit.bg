namespace appkit

use beagle.ffi as ffi

// ─── ObjC Runtime Bindings (internal) ───────────────────────────────

let objc = ffi/load-library("libobjc.dylib")
let _appkit = ffi/load-library("/System/Library/Frameworks/AppKit.framework/AppKit")

let objc_getClass = ffi/get-function(objc, "objc_getClass", [ffi/Type.String], ffi/Type.Pointer)
let sel_registerName = ffi/get-function(objc, "sel_registerName", [ffi/Type.String], ffi/Type.Pointer)
let objc_allocateClassPair = ffi/get-function(
    objc, "objc_allocateClassPair",
    [ffi/Type.Pointer, ffi/Type.String, ffi/Type.U64],
    ffi/Type.Pointer
)
let class_addMethod = ffi/get-function(
    objc, "class_addMethod",
    [ffi/Type.Pointer, ffi/Type.Pointer, ffi/Type.Pointer, ffi/Type.String],
    ffi/Type.U8
)
let objc_registerClassPair = ffi/get-function(
    objc, "objc_registerClassPair",
    [ffi/Type.Pointer],
    ffi/Type.Void
)

let msgSend = ffi/get-symbol(objc, "objc_msgSend")

// ─── Raw message sending ────────────────────────────────────────────

fn msg0(obj, sel_name, ret_type) {
    let sel = sel_registerName(sel_name)
    ffi/call-variadic(msgSend, [obj, sel], [ffi/Type.Pointer, ffi/Type.Pointer], ret_type)
}

fn msg1(obj, sel_name, a1, t1, ret_type) {
    let sel = sel_registerName(sel_name)
    ffi/call-variadic(msgSend, [obj, sel, a1], [ffi/Type.Pointer, ffi/Type.Pointer, t1], ret_type)
}

fn msg2(obj, sel_name, a1, t1, a2, t2, ret_type) {
    let sel = sel_registerName(sel_name)
    ffi/call-variadic(msgSend, [obj, sel, a1, a2],
        [ffi/Type.Pointer, ffi/Type.Pointer, t1, t2], ret_type)
}

fn msg3(obj, sel_name, a1, t1, a2, t2, a3, t3, ret_type) {
    let sel = sel_registerName(sel_name)
    ffi/call-variadic(msgSend, [obj, sel, a1, a2, a3],
        [ffi/Type.Pointer, ffi/Type.Pointer, t1, t2, t3], ret_type)
}

fn msg4(obj, sel_name, a1, t1, a2, t2, a3, t3, a4, t4, ret_type) {
    let sel = sel_registerName(sel_name)
    ffi/call-variadic(msgSend, [obj, sel, a1, a2, a3, a4],
        [ffi/Type.Pointer, ffi/Type.Pointer, t1, t2, t3, t4], ret_type)
}

fn nsstring(str) {
    let NSString = objc_getClass("NSString")
    msg1(NSString, "stringWithUTF8String:", str, ffi/Type.String, ffi/Type.Pointer)
}

fn get-class(name) {
    objc_getClass(name)
}

fn sel(name) {
    sel_registerName(name)
}

// ─── Internal helpers ───────────────────────────────────────────────

fn msg-initWithFrame(obj, x, y, w, h) {
    let sel = sel_registerName("initWithFrame:")
    ffi/call-variadic(msgSend, [obj, sel, x, y, w, h],
        [ffi/Type.Pointer, ffi/Type.Pointer, ffi/Type.F64, ffi/Type.F64, ffi/Type.F64, ffi/Type.F64],
        ffi/Type.Pointer)
}

fn msg-initWithRect(obj, x, y, w, h, style, backing, defer_) {
    let sel = sel_registerName("initWithContentRect:styleMask:backing:defer:")
    ffi/call-variadic(msgSend,
        [obj, sel, x, y, w, h, style, backing, defer_],
        [ffi/Type.Pointer, ffi/Type.Pointer,
         ffi/Type.F64, ffi/Type.F64, ffi/Type.F64, ffi/Type.F64,
         ffi/Type.U64, ffi/Type.U64, ffi/Type.U64],
        ffi/Type.Pointer)
}

fn msg-rgba(obj, sel_name, r, g, b, a) {
    let sel = sel_registerName(sel_name)
    ffi/call-variadic(msgSend, [obj, sel, r, g, b, a],
        [ffi/Type.Pointer, ffi/Type.Pointer, ffi/Type.F64, ffi/Type.F64, ffi/Type.F64, ffi/Type.F64],
        ffi/Type.Pointer)
}

fn alloc-init(cls) {
    msg0(msg0(cls, "alloc", ffi/Type.Pointer), "init", ffi/Type.Pointer)
}

// ─── Wrapper Structs ────────────────────────────────────────────────

struct App { ptr }
struct Window { ptr }
struct View { ptr }
struct Label { ptr }
struct Button { ptr }
struct Handler { ptr, cls }
struct StatusItem { ptr, button }
struct Popover { ptr, content-view }
struct Image { ptr }
struct ScrollView { ptr, document-view }
struct Menu { ptr }
struct MenuItem { ptr }
struct TextField { ptr }

// ─── Widget Protocol ────────────────────────────────────────────────

protocol Widget {
    fn set-text(self, text)
    fn set-font(self, font)
    fn set-text-color(self, color)
    fn widget-ptr(self)
}

extend Label with Widget {
    fn set-text(self, text) {
        msg1(self.ptr, "setStringValue:", nsstring(text), ffi/Type.Pointer, ffi/Type.Void)
    }
    fn set-font(self, font) {
        msg1(self.ptr, "setFont:", font, ffi/Type.Pointer, ffi/Type.Void)
    }
    fn set-text-color(self, color) {
        msg1(self.ptr, "setTextColor:", color, ffi/Type.Pointer, ffi/Type.Void)
    }
    fn widget-ptr(self) { self.ptr }
}

extend Button with Widget {
    fn set-text(self, text) {
        msg1(self.ptr, "setTitle:", nsstring(text), ffi/Type.Pointer, ffi/Type.Void)
    }
    fn set-font(self, font) {
        msg1(self.ptr, "setFont:", font, ffi/Type.Pointer, ffi/Type.Void)
    }
    fn set-text-color(self, color) { null }
    fn widget-ptr(self) { self.ptr }
}

extend TextField with Widget {
    fn set-text(self, text) {
        msg1(self.ptr, "setStringValue:", nsstring(text), ffi/Type.Pointer, ffi/Type.Void)
    }
    fn set-font(self, font) {
        msg1(self.ptr, "setFont:", font, ffi/Type.Pointer, ffi/Type.Void)
    }
    fn set-text-color(self, color) {
        msg1(self.ptr, "setTextColor:", color, ffi/Type.Pointer, ffi/Type.Void)
    }
    fn widget-ptr(self) { self.ptr }
}

// ─── App Constructors ───────────────────────────────────────────────

fn should-terminate(self_, sel, sender) { 1 }

fn app(name) {
    let NSApplication = objc_getClass("NSApplication")
    let a = msg0(NSApplication, "sharedApplication", ffi/Type.Pointer)
    msg1(a, "setActivationPolicy:", 0, ffi/Type.U64, ffi/Type.U8)

    let NSObject = objc_getClass("NSObject")
    let delegateCls = objc_allocateClassPair(NSObject, "BeagleAppDelegate", 0)
    let terminateSel = sel_registerName("applicationShouldTerminateAfterLastWindowClosed:")
    let cb = ffi/create-callback(should-terminate,
        [ffi/Type.Pointer, ffi/Type.Pointer, ffi/Type.Pointer], ffi/Type.U8)
    class_addMethod(delegateCls, terminateSel, cb, "B@:@")
    objc_registerClassPair(delegateCls)
    let delegate = alloc-init(delegateCls)
    msg1(a, "setDelegate:", delegate, ffi/Type.Pointer, ffi/Type.Void)

    let NSMenu = objc_getClass("NSMenu")
    let NSMenuItem = objc_getClass("NSMenuItem")
    let menubar = alloc-init(NSMenu)
    msg1(a, "setMainMenu:", menubar, ffi/Type.Pointer, ffi/Type.Void)
    let appMenu = alloc-init(NSMenu)
    let quitItem = msg3(
        msg0(NSMenuItem, "alloc", ffi/Type.Pointer),
        "initWithTitle:action:keyEquivalent:",
        nsstring("Quit " ++ name), ffi/Type.Pointer,
        sel_registerName("terminate:"), ffi/Type.Pointer,
        nsstring("q"), ffi/Type.Pointer,
        ffi/Type.Pointer)
    msg1(appMenu, "addItem:", quitItem, ffi/Type.Pointer, ffi/Type.Void)
    let appMenuItem = alloc-init(NSMenuItem)
    msg1(appMenuItem, "setSubmenu:", appMenu, ffi/Type.Pointer, ffi/Type.Void)
    msg1(menubar, "addItem:", appMenuItem, ffi/Type.Pointer, ffi/Type.Void)

    App { ptr: a }
}

fn menu-bar-app() {
    let NSApplication = objc_getClass("NSApplication")
    let a = msg0(NSApplication, "sharedApplication", ffi/Type.Pointer)
    msg1(a, "setActivationPolicy:", 1, ffi/Type.U64, ffi/Type.U8)
    App { ptr: a }
}

// ─── Status Bar ─────────────────────────────────────────────────────

fn status-item(title) {
    let NSStatusBar = objc_getClass("NSStatusBar")
    let systemBar = msg0(NSStatusBar, "systemStatusBar", ffi/Type.Pointer)
    let sel = sel_registerName("statusItemWithLength:")
    let item = ffi/call-variadic(msgSend, [systemBar, sel, -1.0],
        [ffi/Type.Pointer, ffi/Type.Pointer, ffi/Type.F64],
        ffi/Type.Pointer)
    let button = msg0(item, "button", ffi/Type.Pointer)
    msg1(button, "setTitle:", nsstring(title), ffi/Type.Pointer, ffi/Type.Void)
    StatusItem { ptr: item, button: button }
}

fn status-on-click(si, handler, sel_name) {
    msg1(si.button, "setTarget:", handler.ptr, ffi/Type.Pointer, ffi/Type.Void)
    msg1(si.button, "setAction:", sel_registerName(sel_name), ffi/Type.Pointer, ffi/Type.Void)
}

fn set-button-image(si, img) {
    msg1(si.button, "setImage:", img.ptr, ffi/Type.Pointer, ffi/Type.Void)
    msg1(si.button, "setTitle:", nsstring(""), ffi/Type.Pointer, ffi/Type.Void)
}

// ─── Popover ────────────────────────────────────────────────────────

fn popover(w, h) {
    let NSPopover = objc_getClass("NSPopover")
    let pop = alloc-init(NSPopover)

    let sel = sel_registerName("setContentSize:")
    ffi/call-variadic(msgSend, [pop, sel, w, h],
        [ffi/Type.Pointer, ffi/Type.Pointer, ffi/Type.F64, ffi/Type.F64],
        ffi/Type.Void)

    msg1(pop, "setBehavior:", 1, ffi/Type.U64, ffi/Type.Void)

    let NSAppearance = objc_getClass("NSAppearance")
    let dark = msg1(NSAppearance, "appearanceNamed:",
        nsstring("NSAppearanceNameDarkAqua"), ffi/Type.Pointer, ffi/Type.Pointer)
    msg1(pop, "setAppearance:", dark, ffi/Type.Pointer, ffi/Type.Void)

    let NSViewController = objc_getClass("NSViewController")
    let vc = alloc-init(NSViewController)
    let NSView = objc_getClass("NSView")
    let cv = msg-initWithFrame(msg0(NSView, "alloc", ffi/Type.Pointer), 0.0, 0.0, w, h)
    msg1(vc, "setView:", cv, ffi/Type.Pointer, ffi/Type.Void)
    msg1(pop, "setContentViewController:", vc, ffi/Type.Pointer, ffi/Type.Void)

    Popover { ptr: pop, content-view: View { ptr: cv } }
}

fn set-popover-content-size(pop, w, h) {
    let sel = sel_registerName("setContentSize:")
    ffi/call-variadic(msgSend, [pop.ptr, sel, w, h],
        [ffi/Type.Pointer, ffi/Type.Pointer, ffi/Type.F64, ffi/Type.F64],
        ffi/Type.Void)
}

fn show-popover(pop, si) {
    let sel = sel_registerName("showRelativeToRect:ofView:preferredEdge:")
    ffi/call-variadic(msgSend, [pop.ptr, sel, 0.0, 0.0, 0.0, 0.0, si.button, 1],
        [ffi/Type.Pointer, ffi/Type.Pointer,
         ffi/Type.F64, ffi/Type.F64, ffi/Type.F64, ffi/Type.F64,
         ffi/Type.Pointer, ffi/Type.U64],
        ffi/Type.Void)
}

fn close-popover(pop) {
    msg1(pop.ptr, "performClose:", 0, ffi/Type.Pointer, ffi/Type.Void)
}

fn is-popover-shown(pop) {
    msg0(pop.ptr, "isShown", ffi/Type.U8) == 1
}

fn toggle-popover(pop, si) {
    if is-popover-shown(pop) {
        close-popover(pop)
    } else {
        show-popover(pop, si)
    }
}

// ─── Window ─────────────────────────────────────────────────────────

fn window(title, w, h) {
    let NSWindow = objc_getClass("NSWindow")
    let win = msg-initWithRect(
        msg0(NSWindow, "alloc", ffi/Type.Pointer),
        0.0, 0.0, w, h, 15, 2, 0
    )
    msg0(win, "center", ffi/Type.Void)
    msg1(win, "setTitle:", nsstring(title), ffi/Type.Pointer, ffi/Type.Void)

    let contentView = msg0(win, "contentView", ffi/Type.Pointer)
    let NSColor = objc_getClass("NSColor")
    let bg = msg-rgba(NSColor, "colorWithRed:green:blue:alpha:", 0.12, 0.12, 0.15, 1.0)
    msg1(contentView, "setWantsLayer:", 1, ffi/Type.U8, ffi/Type.Void)
    let layer = msg0(contentView, "layer", ffi/Type.Pointer)
    msg1(layer, "setBackgroundColor:", msg0(bg, "CGColor", ffi/Type.Pointer), ffi/Type.Pointer, ffi/Type.Void)

    Window { ptr: win }
}

fn content-view(window) {
    View { ptr: msg0(window.ptr, "contentView", ffi/Type.Pointer) }
}

// ─── Widgets ────────────────────────────────────────────────────────

fn label(text, x, y, w, h) {
    let NSTextField = objc_getClass("NSTextField")
    let lbl = msg-initWithFrame(
        msg0(NSTextField, "alloc", ffi/Type.Pointer),
        x, y, w, h
    )
    msg1(lbl, "setBezeled:", 0, ffi/Type.U8, ffi/Type.Void)
    msg1(lbl, "setDrawsBackground:", 0, ffi/Type.U8, ffi/Type.Void)
    msg1(lbl, "setEditable:", 0, ffi/Type.U8, ffi/Type.Void)
    msg1(lbl, "setSelectable:", 0, ffi/Type.U8, ffi/Type.Void)
    msg1(lbl, "setAlignment:", 1, ffi/Type.U64, ffi/Type.Void)
    msg1(lbl, "setStringValue:", nsstring(text), ffi/Type.Pointer, ffi/Type.Void)
    Label { ptr: lbl }
}

fn left-label(text, x, y, w, h) {
    let NSTextField = objc_getClass("NSTextField")
    let lbl = msg-initWithFrame(
        msg0(NSTextField, "alloc", ffi/Type.Pointer),
        x, y, w, h
    )
    msg1(lbl, "setBezeled:", 0, ffi/Type.U8, ffi/Type.Void)
    msg1(lbl, "setDrawsBackground:", 0, ffi/Type.U8, ffi/Type.Void)
    msg1(lbl, "setEditable:", 0, ffi/Type.U8, ffi/Type.Void)
    msg1(lbl, "setSelectable:", 0, ffi/Type.U8, ffi/Type.Void)
    msg1(lbl, "setAlignment:", 0, ffi/Type.U64, ffi/Type.Void)
    msg1(lbl, "setStringValue:", nsstring(text), ffi/Type.Pointer, ffi/Type.Void)
    Label { ptr: lbl }
}

fn text-field(placeholder, x, y, w, h) {
    let NSTextField = objc_getClass("NSTextField")
    let tf = msg-initWithFrame(
        msg0(NSTextField, "alloc", ffi/Type.Pointer),
        x, y, w, h
    )
    msg1(tf, "setEditable:", 1, ffi/Type.U8, ffi/Type.Void)
    msg1(tf, "setBezeled:", 1, ffi/Type.U8, ffi/Type.Void)
    msg1(tf, "setDrawsBackground:", 1, ffi/Type.U8, ffi/Type.Void)
    msg1(tf, "setPlaceholderString:", nsstring(placeholder), ffi/Type.Pointer, ffi/Type.Void)
    TextField { ptr: tf }
}

fn get-text(widget) {
    let ns = msg0(widget.ptr, "stringValue", ffi/Type.Pointer)
    msg0(ns, "UTF8String", ffi/Type.String)
}

fn button(title, x, y, w, h) {
    let NSButton = objc_getClass("NSButton")
    let btn = msg-initWithFrame(
        msg0(NSButton, "alloc", ffi/Type.Pointer),
        x, y, w, h
    )
    msg1(btn, "setTitle:", nsstring(title), ffi/Type.Pointer, ffi/Type.Void)
    msg1(btn, "setBezelStyle:", 1, ffi/Type.U64, ffi/Type.Void)
    Button { ptr: btn }
}

fn set-bordered(btn, flag) {
    msg1(btn.ptr, "setBordered:", flag, ffi/Type.U8, ffi/Type.Void)
}

fn set-bezel-style(btn, style) {
    msg1(btn.ptr, "setBezelStyle:", style, ffi/Type.U64, ffi/Type.Void)
}

// ─── Handler ────────────────────────────────────────────────────────

fn handler(name) {
    let NSObject = objc_getClass("NSObject")
    let cls = objc_allocateClassPair(NSObject, name, 0)
    Handler { ptr: null, cls: cls }
}

fn add-method(handler, sel_name, callback) {
    let cb = ffi/create-callback(callback,
        [ffi/Type.Pointer, ffi/Type.Pointer, ffi/Type.Pointer], ffi/Type.Void)
    class_addMethod(handler.cls, sel_registerName(sel_name), cb, "v@:@")
    handler
}

fn register(handler) {
    objc_registerClassPair(handler.cls)
    Handler { ptr: alloc-init(handler.cls), cls: handler.cls }
}

// ─── Actions ────────────────────────────────────────────────────────

fn add-to(view, widget) {
    msg1(view.ptr, "addSubview:", widget-ptr(widget), ffi/Type.Pointer, ffi/Type.Void)
}

fn add-view(parent, child) {
    msg1(parent.ptr, "addSubview:", child.ptr, ffi/Type.Pointer, ffi/Type.Void)
}

fn add-raw-view(parent, child-ptr) {
    msg1(parent.ptr, "addSubview:", child-ptr, ffi/Type.Pointer, ffi/Type.Void)
}

fn on-click(button, handler, sel_name) {
    msg1(button.ptr, "setTarget:", handler.ptr, ffi/Type.Pointer, ffi/Type.Void)
    msg1(button.ptr, "setAction:", sel_registerName(sel_name), ffi/Type.Pointer, ffi/Type.Void)
}

fn show(window) {
    msg1(window.ptr, "makeKeyAndOrderFront:", 0, ffi/Type.Pointer, ffi/Type.Void)
    let NSApplication = objc_getClass("NSApplication")
    let a = msg0(NSApplication, "sharedApplication", ffi/Type.Pointer)
    msg1(a, "activateIgnoringOtherApps:", 1, ffi/Type.U8, ffi/Type.Void)
}

fn run(app) {
    msg0(app.ptr, "run", ffi/Type.Void)
}

fn terminate() {
    let NSApplication = objc_getClass("NSApplication")
    let a = msg0(NSApplication, "sharedApplication", ffi/Type.Pointer)
    msg1(a, "terminate:", 0, ffi/Type.Pointer, ffi/Type.Void)
}

// ─── View Management ────────────────────────────────────────────────

fn remove-all-subviews(view) {
    let empty = msg0(objc_getClass("NSArray"), "array", ffi/Type.Pointer)
    msg1(view.ptr, "setSubviews:", empty, ffi/Type.Pointer, ffi/Type.Void)
}

fn set-hidden(view, hidden) {
    msg1(view.ptr, "setHidden:", hidden, ffi/Type.U8, ffi/Type.Void)
}

fn set-tag(view, tag) {
    msg1(view.ptr, "setTag:", tag, ffi/Type.U64, ffi/Type.Void)
}

fn get-tag(view-ptr) {
    msg0(view-ptr, "tag", ffi/Type.U64)
}

fn focus-view(pop, widget) {
    let window = msg0(pop.ptr, "window", ffi/Type.Pointer)
    if window != null {
        msg1(window, "makeFirstResponder:", widget.ptr, ffi/Type.Pointer, ffi/Type.U8)
    }
}

// ─── Style Helpers ──────────────────────────────────────────────────

let NSColor_ = objc_getClass("NSColor")
let NSFont_ = objc_getClass("NSFont")

let white = msg0(NSColor_, "whiteColor", ffi/Type.Pointer)

fn color(r, g, b, a) {
    msg-rgba(NSColor_, "colorWithRed:green:blue:alpha:", r, g, b, a)
}

fn font(size) {
    msg1(NSFont_, "systemFontOfSize:", size, ffi/Type.F64, ffi/Type.Pointer)
}

fn bold-font(size) {
    msg1(NSFont_, "boldSystemFontOfSize:", size, ffi/Type.F64, ffi/Type.Pointer)
}

fn mono-digit-font(size) {
    msg2(NSFont_, "monospacedDigitSystemFontOfSize:weight:", size, ffi/Type.F64, 0.0, ffi/Type.F64, ffi/Type.Pointer)
}

fn set-line-break-mode(lbl, mode) {
    let cell = msg0(lbl.ptr, "cell", ffi/Type.Pointer)
    msg1(cell, "setLineBreakMode:", mode, ffi/Type.U64, ffi/Type.Void)
}

// ─── View Helpers ───────────────────────────────────────────────────

fn colored-view(x, y, w, h, r, g, b, a) {
    let NSView = objc_getClass("NSView")
    let view = msg-initWithFrame(msg0(NSView, "alloc", ffi/Type.Pointer), x, y, w, h)
    msg1(view, "setWantsLayer:", 1, ffi/Type.U8, ffi/Type.Void)
    let c = color(r, g, b, a)
    let layer = msg0(view, "layer", ffi/Type.Pointer)
    msg1(layer, "setBackgroundColor:", msg0(c, "CGColor", ffi/Type.Pointer), ffi/Type.Pointer, ffi/Type.Void)
    View { ptr: view }
}

fn set-frame(view, x, y, w, h) {
    let sel = sel_registerName("setFrame:")
    ffi/call-variadic(msgSend, [view.ptr, sel, x, y, w, h],
        [ffi/Type.Pointer, ffi/Type.Pointer, ffi/Type.F64, ffi/Type.F64, ffi/Type.F64, ffi/Type.F64],
        ffi/Type.Void)
}

fn set-frame-raw(view-ptr, x, y, w, h) {
    let sel = sel_registerName("setFrame:")
    ffi/call-variadic(msgSend, [view-ptr, sel, x, y, w, h],
        [ffi/Type.Pointer, ffi/Type.Pointer, ffi/Type.F64, ffi/Type.F64, ffi/Type.F64, ffi/Type.F64],
        ffi/Type.Void)
}

fn set-corner-radius(view, radius) {
    msg1(view.ptr, "setWantsLayer:", 1, ffi/Type.U8, ffi/Type.Void)
    let layer = msg0(view.ptr, "layer", ffi/Type.Pointer)
    msg1(layer, "setCornerRadius:", radius, ffi/Type.F64, ffi/Type.Void)
}

fn set-bg-color(view, r, g, b, a) {
    msg1(view.ptr, "setWantsLayer:", 1, ffi/Type.U8, ffi/Type.Void)
    let c = color(r, g, b, a)
    let layer = msg0(view.ptr, "layer", ffi/Type.Pointer)
    msg1(layer, "setBackgroundColor:", msg0(c, "CGColor", ffi/Type.Pointer), ffi/Type.Pointer, ffi/Type.Void)
}

fn set-bg-nscolor(view, nscolor) {
    msg1(view.ptr, "setWantsLayer:", 1, ffi/Type.U8, ffi/Type.Void)
    let layer = msg0(view.ptr, "layer", ffi/Type.Pointer)
    msg1(layer, "setBackgroundColor:", msg0(nscolor, "CGColor", ffi/Type.Pointer), ffi/Type.Pointer, ffi/Type.Void)
}

fn set-layer-mask(view) {
    let layer = msg0(view.ptr, "layer", ffi/Type.Pointer)
    msg1(layer, "setMasksToBounds:", 1, ffi/Type.U8, ffi/Type.Void)
}

fn set-border(view, width, nscolor) {
    msg1(view.ptr, "setWantsLayer:", 1, ffi/Type.U8, ffi/Type.Void)
    let layer = msg0(view.ptr, "layer", ffi/Type.Pointer)
    msg1(layer, "setBorderWidth:", width, ffi/Type.F64, ffi/Type.Void)
    msg1(layer, "setBorderColor:", msg0(nscolor, "CGColor", ffi/Type.Pointer), ffi/Type.Pointer, ffi/Type.Void)
}

// ─── NSImage Drawing ────────────────────────────────────────────────

fn image(w, h) {
    let NSImage = objc_getClass("NSImage")
    let img = msg0(NSImage, "alloc", ffi/Type.Pointer)
    let sel = sel_registerName("initWithSize:")
    let result = ffi/call-variadic(msgSend, [img, sel, w, h],
        [ffi/Type.Pointer, ffi/Type.Pointer, ffi/Type.F64, ffi/Type.F64],
        ffi/Type.Pointer)
    Image { ptr: result }
}

fn lock-focus(img) {
    msg0(img.ptr, "lockFocus", ffi/Type.Void)
}

fn unlock-focus(img) {
    msg0(img.ptr, "unlockFocus", ffi/Type.Void)
}

fn set-template(img) {
    msg1(img.ptr, "setTemplate:", 1, ffi/Type.U8, ffi/Type.Void)
}

fn fill-rect(x, y, w, h) {
    let NSBezierPath = objc_getClass("NSBezierPath")
    let sel = sel_registerName("fillRect:")
    ffi/call-variadic(msgSend, [NSBezierPath, sel, x, y, w, h],
        [ffi/Type.Pointer, ffi/Type.Pointer, ffi/Type.F64, ffi/Type.F64, ffi/Type.F64, ffi/Type.F64],
        ffi/Type.Void)
}

fn fill-rounded-rect(x, y, w, h, rx, ry) {
    let NSBezierPath = objc_getClass("NSBezierPath")
    let sel = sel_registerName("bezierPathWithRoundedRect:xRadius:yRadius:")
    let path = ffi/call-variadic(msgSend, [NSBezierPath, sel, x, y, w, h, rx, ry],
        [ffi/Type.Pointer, ffi/Type.Pointer, ffi/Type.F64, ffi/Type.F64, ffi/Type.F64, ffi/Type.F64, ffi/Type.F64, ffi/Type.F64],
        ffi/Type.Pointer)
    msg0(path, "fill", ffi/Type.Void)
}

fn set-fill-color(nscolor) {
    msg0(nscolor, "set", ffi/Type.Void)
}

// ─── ScrollView ─────────────────────────────────────────────────────

fn scroll-view(x, y, w, h) {
    let NSScrollView = objc_getClass("NSScrollView")
    let sv = msg-initWithFrame(msg0(NSScrollView, "alloc", ffi/Type.Pointer), x, y, w, h)
    msg1(sv, "setHasVerticalScroller:", 1, ffi/Type.U8, ffi/Type.Void)
    msg1(sv, "setHasHorizontalScroller:", 0, ffi/Type.U8, ffi/Type.Void)
    msg1(sv, "setDrawsBackground:", 0, ffi/Type.U8, ffi/Type.Void)

    let NSView = objc_getClass("NSView")
    let doc = msg-initWithFrame(msg0(NSView, "alloc", ffi/Type.Pointer), 0.0, 0.0, w, h)
    msg1(sv, "setDocumentView:", doc, ffi/Type.Pointer, ffi/Type.Void)

    ScrollView { ptr: sv, document-view: View { ptr: doc } }
}

fn set-document-size(sv, w, h) {
    set-frame(sv.document-view, 0.0, 0.0, w, h)
}

// ─── NSMenu ─────────────────────────────────────────────────────────

fn menu() {
    Menu { ptr: alloc-init(objc_getClass("NSMenu")) }
}

fn menu-item(title, handler, sel_name) {
    let NSMenuItem = objc_getClass("NSMenuItem")
    let item = msg3(
        msg0(NSMenuItem, "alloc", ffi/Type.Pointer),
        "initWithTitle:action:keyEquivalent:",
        nsstring(title), ffi/Type.Pointer,
        sel_registerName(sel_name), ffi/Type.Pointer,
        nsstring(""), ffi/Type.Pointer,
        ffi/Type.Pointer)
    msg1(item, "setTarget:", handler.ptr, ffi/Type.Pointer, ffi/Type.Void)
    MenuItem { ptr: item }
}

fn menu-separator() {
    MenuItem { ptr: msg0(objc_getClass("NSMenuItem"), "separatorItem", ffi/Type.Pointer) }
}

fn menu-add-item(menu, item) {
    msg1(menu.ptr, "addItem:", item.ptr, ffi/Type.Pointer, ffi/Type.Void)
}

fn popup-menu(menu, view-ptr) {
    let event = current-event()
    let NSMenu = objc_getClass("NSMenu")
    msg3(NSMenu, "popUpContextMenu:withEvent:forView:",
        menu.ptr, ffi/Type.Pointer,
        event, ffi/Type.Pointer,
        view-ptr, ffi/Type.Pointer,
        ffi/Type.Void)
}

// ─── NSEvent ────────────────────────────────────────────────────────

fn current-event() {
    let NSApp = msg0(objc_getClass("NSApplication"), "sharedApplication", ffi/Type.Pointer)
    msg0(NSApp, "currentEvent", ffi/Type.Pointer)
}

fn event-type(event) {
    msg0(event, "type", ffi/Type.U64)
}

fn event-location(event) {
    let sel = sel_registerName("locationInWindow")
    let result = ffi/call-variadic(msgSend, [event, sel],
        [ffi/Type.Pointer, ffi/Type.Pointer],
        ffi/Type.Structure { types: [ffi/Type.F64, ffi/Type.F64] })
    [result.low, result.high]
}

fn event-keycode(event) {
    msg0(event, "keyCode", ffi/Type.U16)
}

fn event-modifier-flags(event) {
    msg0(event, "modifierFlags", ffi/Type.U64)
}

// ─── Custom View Subclasses ─────────────────────────────────────────

fn custom-tracking-view(name, x, y, w, h, on-mouse-down, on-mouse-dragged, on-mouse-up) {
    let NSView = objc_getClass("NSView")
    let cls = objc_allocateClassPair(NSView, name, 0)

    let down-cb = ffi/create-callback(on-mouse-down,
        [ffi/Type.Pointer, ffi/Type.Pointer, ffi/Type.Pointer], ffi/Type.Void)
    class_addMethod(cls, sel_registerName("mouseDown:"), down-cb, "v@:@")

    let drag-cb = ffi/create-callback(on-mouse-dragged,
        [ffi/Type.Pointer, ffi/Type.Pointer, ffi/Type.Pointer], ffi/Type.Void)
    class_addMethod(cls, sel_registerName("mouseDragged:"), drag-cb, "v@:@")

    let up-cb = ffi/create-callback(on-mouse-up,
        [ffi/Type.Pointer, ffi/Type.Pointer, ffi/Type.Pointer], ffi/Type.Void)
    class_addMethod(cls, sel_registerName("mouseUp:"), up-cb, "v@:@")

    objc_registerClassPair(cls)

    let view = msg-initWithFrame(msg0(cls, "alloc", ffi/Type.Pointer), x, y, w, h)
    msg1(view, "setWantsLayer:", 1, ffi/Type.U8, ffi/Type.Void)
    View { ptr: view }
}

fn custom-key-view(name, x, y, w, h, on-key-down) {
    let NSView = objc_getClass("NSView")
    let cls = objc_allocateClassPair(NSView, name, 0)

    let key-cb = ffi/create-callback(on-key-down,
        [ffi/Type.Pointer, ffi/Type.Pointer, ffi/Type.Pointer], ffi/Type.Void)
    class_addMethod(cls, sel_registerName("keyDown:"), key-cb, "v@:@")

    let accepts-cb = ffi/create-callback(fn(self_, sel, _) { 1 },
        [ffi/Type.Pointer, ffi/Type.Pointer, ffi/Type.Pointer], ffi/Type.U8)
    class_addMethod(cls, sel_registerName("acceptsFirstResponder"), accepts-cb, "B@:")

    objc_registerClassPair(cls)

    let view = msg-initWithFrame(msg0(cls, "alloc", ffi/Type.Pointer), x, y, w, h)
    View { ptr: view }
}

fn custom-responder-view(name, x, y, w, h, on-key-down, on-flags-changed) {
    let NSView = objc_getClass("NSView")
    let cls = objc_allocateClassPair(NSView, name, 0)

    let key-cb = ffi/create-callback(on-key-down,
        [ffi/Type.Pointer, ffi/Type.Pointer, ffi/Type.Pointer], ffi/Type.Void)
    class_addMethod(cls, sel_registerName("keyDown:"), key-cb, "v@:@")

    let flags-cb = ffi/create-callback(on-flags-changed,
        [ffi/Type.Pointer, ffi/Type.Pointer, ffi/Type.Pointer], ffi/Type.Void)
    class_addMethod(cls, sel_registerName("flagsChanged:"), flags-cb, "v@:@")

    let accepts-cb = ffi/create-callback(fn(self_, sel, _) { 1 },
        [ffi/Type.Pointer, ffi/Type.Pointer, ffi/Type.Pointer], ffi/Type.U8)
    class_addMethod(cls, sel_registerName("acceptsFirstResponder"), accepts-cb, "B@:")

    objc_registerClassPair(cls)

    let view = msg-initWithFrame(msg0(cls, "alloc", ffi/Type.Pointer), x, y, w, h)
    View { ptr: view }
}

fn make-first-responder(pop, view) {
    let window = msg0(view.ptr, "window", ffi/Type.Pointer)
    if window != null {
        msg1(window, "makeFirstResponder:", view.ptr, ffi/Type.Pointer, ffi/Type.U8)
    }
}

fn make-popover-key(pop) {
    let window = msg0(pop.content-view.ptr, "window", ffi/Type.Pointer)
    if window != null {
        msg0(window, "makeKeyWindow", ffi/Type.Void)
    }
    let NSApplication = objc_getClass("NSApplication")
    let a = msg0(NSApplication, "sharedApplication", ffi/Type.Pointer)
    msg1(a, "activateIgnoringOtherApps:", 1, ffi/Type.U8, ffi/Type.Void)
}

fn set-layer-bg(view-ptr, nscolor) {
    msg1(view-ptr, "setWantsLayer:", 1, ffi/Type.U8, ffi/Type.Void)
    let layer = msg0(view-ptr, "layer", ffi/Type.Pointer)
    msg1(layer, "setBackgroundColor:", msg0(nscolor, "CGColor", ffi/Type.Pointer), ffi/Type.Pointer, ffi/Type.Void)
}

fn set-layer-corner-radius(view-ptr, radius) {
    let layer = msg0(view-ptr, "layer", ffi/Type.Pointer)
    msg1(layer, "setCornerRadius:", radius, ffi/Type.F64, ffi/Type.Void)
}

// ─── Raw pointer helpers (for use from callbacks) ──────────────────

fn hide-view(ptr) {
    msg1(ptr, "setHidden:", 1, ffi/Type.U8, ffi/Type.Void)
}

fn show-view(ptr) {
    msg1(ptr, "setHidden:", 0, ffi/Type.U8, ffi/Type.Void)
}

fn remove-from-superview(ptr) {
    msg0(ptr, "removeFromSuperview", ffi/Type.Void)
}

fn add-subview-to(parent-ptr, child-ptr) {
    msg1(parent-ptr, "addSubview:", child-ptr, ffi/Type.Pointer, ffi/Type.Void)
}

// ─── Animation ─────────────────────────────────────────────────────

fn animate(duration, callback) {
    let NSAnimationContext = objc_getClass("NSAnimationContext")
    msg0(NSAnimationContext, "beginGrouping", ffi/Type.Void)
    let ctx = msg0(NSAnimationContext, "currentContext", ffi/Type.Pointer)
    msg1(ctx, "setDuration:", duration, ffi/Type.F64, ffi/Type.Void)
    msg1(ctx, "setAllowsImplicitAnimation:", 1, ffi/Type.U8, ffi/Type.Void)
    callback()
    msg0(NSAnimationContext, "endGrouping", ffi/Type.Void)
}

fn set-alpha(view-ptr, alpha) {
    let animator = msg0(view-ptr, "animator", ffi/Type.Pointer)
    msg1(animator, "setAlphaValue:", alpha, ffi/Type.F64, ffi/Type.Void)
}

fn animated-set-frame(view-ptr, x, y, w, h) {
    let animator = msg0(view-ptr, "animator", ffi/Type.Pointer)
    let sel = sel_registerName("setFrame:")
    ffi/call-variadic(msgSend, [animator, sel, x, y, w, h],
        [ffi/Type.Pointer, ffi/Type.Pointer, ffi/Type.F64, ffi/Type.F64, ffi/Type.F64, ffi/Type.F64],
        ffi/Type.Void)
}

// ─── SF Symbols ─────────────────────────────────────────────────────

fn symbol-image-view(name, pt-size, x, y, w, h, tint-color) {
    let NSImage = objc_getClass("NSImage")
    let img = msg2(NSImage, "imageWithSystemSymbolName:accessibilityDescription:",
        nsstring(name), ffi/Type.Pointer,
        0, ffi/Type.Pointer,
        ffi/Type.Pointer)
    let NSImageSymbolConfiguration = objc_getClass("NSImageSymbolConfiguration")
    let config = msg2(NSImageSymbolConfiguration, "configurationWithPointSize:weight:",
        pt-size, ffi/Type.F64,
        0.0, ffi/Type.F64,
        ffi/Type.Pointer)
    let sized-img = msg1(img, "imageWithSymbolConfiguration:", config, ffi/Type.Pointer, ffi/Type.Pointer)
    let NSImageView = objc_getClass("NSImageView")
    let iv = msg-initWithFrame(msg0(NSImageView, "alloc", ffi/Type.Pointer), x, y, w, h)
    msg1(iv, "setImage:", sized-img, ffi/Type.Pointer, ffi/Type.Void)
    msg1(iv, "setContentTintColor:", tint-color, ffi/Type.Pointer, ffi/Type.Void)
    View { ptr: iv }
}

fn update-image-view-symbol(iv-ptr, name, pt-size, tint-color) {
    let NSImage = objc_getClass("NSImage")
    let img = msg2(NSImage, "imageWithSystemSymbolName:accessibilityDescription:",
        nsstring(name), ffi/Type.Pointer,
        0, ffi/Type.Pointer,
        ffi/Type.Pointer)
    let NSImageSymbolConfiguration = objc_getClass("NSImageSymbolConfiguration")
    let config = msg2(NSImageSymbolConfiguration, "configurationWithPointSize:weight:",
        pt-size, ffi/Type.F64,
        0.0, ffi/Type.F64,
        ffi/Type.Pointer)
    let sized-img = msg1(img, "imageWithSymbolConfiguration:", config, ffi/Type.Pointer, ffi/Type.Pointer)
    msg1(iv-ptr, "setImage:", sized-img, ffi/Type.Pointer, ffi/Type.Void)
    msg1(iv-ptr, "setContentTintColor:", tint-color, ffi/Type.Pointer, ffi/Type.Void)
}

// ─── Snapshot / Export ──────────────────────────────────────────────

fn view-pdf-data(view, w, h) {
    let sel = sel_registerName("dataWithPDFInsideRect:")
    ffi/call-variadic(msgSend, [view.ptr, sel, 0.0, 0.0, w, h],
        [ffi/Type.Pointer, ffi/Type.Pointer, ffi/Type.F64, ffi/Type.F64, ffi/Type.F64, ffi/Type.F64],
        ffi/Type.Pointer)
}

fn save-panel-run(filename) {
    let NSSavePanel = objc_getClass("NSSavePanel")
    let panel = msg0(NSSavePanel, "savePanel", ffi/Type.Pointer)
    msg1(panel, "setNameFieldStringValue:", nsstring(filename), ffi/Type.Pointer, ffi/Type.Void)
    let result = msg0(panel, "runModal", ffi/Type.U64)
    if result == 1 {
        let url = msg0(panel, "URL", ffi/Type.Pointer)
        let path = msg0(url, "path", ffi/Type.Pointer)
        msg0(path, "UTF8String", ffi/Type.String)
    } else {
        null
    }
}

fn nsdata-write-to-file(data, path) {
    msg2(data, "writeToFile:atomically:",
        nsstring(path), ffi/Type.Pointer,
        1, ffi/Type.U8,
        ffi/Type.U8)
}

// ─── Utilities ──────────────────────────────────────────────────────

fn uuid() {
    let NSUUID = objc_getClass("NSUUID")
    let u = msg0(NSUUID, "UUID", ffi/Type.Pointer)
    let s = msg0(u, "UUIDString", ffi/Type.Pointer)
    msg0(s, "UTF8String", ffi/Type.String)
}

fn epoch-seconds() {
    let NSDate = objc_getClass("NSDate")
    let now = msg0(NSDate, "date", ffi/Type.Pointer)
    msg0(now, "timeIntervalSince1970", ffi/Type.F64)
}

fn home-directory() {
    let NSFileManager = objc_getClass("NSFileManager")
    let fm = msg0(NSFileManager, "defaultManager", ffi/Type.Pointer)
    let url = msg0(fm, "homeDirectoryForCurrentUser", ffi/Type.Pointer)
    let path = msg0(url, "path", ffi/Type.Pointer)
    msg0(path, "UTF8String", ffi/Type.String)
}

fn ensure-directory(path) {
    let NSFileManager = objc_getClass("NSFileManager")
    let fm = msg0(NSFileManager, "defaultManager", ffi/Type.Pointer)
    msg4(fm, "createDirectoryAtPath:withIntermediateDirectories:attributes:error:",
        nsstring(path), ffi/Type.Pointer,
        1, ffi/Type.U8,
        0, ffi/Type.Pointer,
        0, ffi/Type.Pointer,
        ffi/Type.U8)
}

fn file-exists(path) {
    let NSFileManager = objc_getClass("NSFileManager")
    let fm = msg0(NSFileManager, "defaultManager", ffi/Type.Pointer)
    msg1(fm, "fileExistsAtPath:", nsstring(path), ffi/Type.Pointer, ffi/Type.U8) == 1
}

fn read-file(path) {
    let NSString = objc_getClass("NSString")
    let s = msg3(NSString, "stringWithContentsOfFile:encoding:error:",
        nsstring(path), ffi/Type.Pointer,
        4, ffi/Type.U64,
        0, ffi/Type.Pointer,
        ffi/Type.Pointer)
    if s == null {
        null
    } else {
        msg0(s, "UTF8String", ffi/Type.String)
    }
}

fn write-file(path, content) {
    let ns = nsstring(content)
    msg4(ns, "writeToFile:atomically:encoding:error:",
        nsstring(path), ffi/Type.Pointer,
        1, ffi/Type.U8,
        4, ffi/Type.U64,
        0, ffi/Type.Pointer,
        ffi/Type.U8)
}
