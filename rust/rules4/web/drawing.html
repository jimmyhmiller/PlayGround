<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Drawing — Rules4 Learnable Programming</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #f7f7f8;
      padding: 20px;
    }
    .page { max-width: 1200px; margin: 0 auto; }
    .header {
      display: flex; align-items: center; gap: 10px; margin-bottom: 14px;
    }
    h1 { font-size: 20px; font-weight: 700; color: #1a1a1a; }
    .status-dot {
      width: 8px; height: 8px; border-radius: 50%;
      display: inline-block; transition: background 0.2s;
    }
    .status-dot.ok { background: #22c55e; }
    .status-dot.err { background: #ef4444; }
    .status-dot.running { background: #f59e0b; }

    .main {
      display: flex; gap: 16px; margin-bottom: 12px;
      height: calc(100vh - 120px);
      min-height: 500px;
    }
    .editor-col {
      flex: 1; display: flex; flex-direction: column; min-width: 0;
    }
    .canvas-col {
      flex: 1; min-width: 0;
      display: flex; flex-direction: column; gap: 10px;
    }
    .canvas-wrap {
      flex: 1;
      background: white;
      border: 1px solid #eaeaee;
      border-radius: 12px;
      overflow: hidden;
    }
    #canvas-root { width: 100%; height: 100%; }

    /* ── Tab bar ── */
    .tab-bar {
      display: flex; gap: 0;
      border-bottom: 2px solid #e0e0e4;
      flex-shrink: 0;
    }
    .tab {
      padding: 8px 18px;
      border: none; background: none;
      font-size: 13px; font-weight: 600;
      color: #888; cursor: pointer;
      border-bottom: 2px solid transparent;
      margin-bottom: -2px;
      transition: color 0.15s, border-color 0.15s;
    }
    .tab:hover { color: #555; }
    .tab.active { color: #1976d2; border-bottom-color: #1976d2; }

    /* ── Editor panels ── */
    .editor-wrap {
      flex: 1;
      border: 2px solid #e0e0e4;
      border-top: none;
      border-radius: 0 0 10px 10px;
      overflow: hidden;
      position: relative;
    }
    .editor-panel {
      position: absolute; inset: 0;
      display: none;
      overflow: hidden;
    }
    .editor-panel.active { display: flex; flex-direction: column; }
    .editor-panel > div { flex: 1; overflow: hidden; }
    .cm-editor { height: 100%; overflow: hidden; }
    .cm-editor .cm-scroller { overflow: auto !important; }
    .cm-editor .cm-content {
      font-family: 'SF Mono', 'Fira Code', 'Menlo', monospace;
      font-size: 13px;
    }
    .cm-editor .cm-gutters { background: #fafafa; border-right: 1px solid #eee; }
    .cm-editor.cm-focused { outline: none; }

    .error {
      background: #fef2f2; color: #dc2626; border-radius: 8px;
      padding: 6px 10px; font-size: 11px; margin-top: 6px;
      font-family: 'SF Mono', monospace;
      max-height: 50px; overflow: auto;
      display: none; white-space: pre-wrap;
    }
    .error.visible { display: block; }

    /* ── Controls ── */
    .controls {
      display: flex; align-items: center; gap: 14px;
    }
    input[type="range"] {
      flex: 1; height: 6px; background: #ddd;
      border-radius: 3px; outline: none; cursor: pointer;
      -webkit-appearance: none; appearance: none;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none; width: 20px; height: 20px;
      background: white; border-radius: 50%;
      border: 3px solid #1976d2; cursor: pointer;
      box-shadow: 0 1px 4px rgba(0,0,0,0.18);
    }
    .frame-label {
      font-size: 12px; color: #999; min-width: 90px; text-align: center;
      font-variant-numeric: tabular-nums; font-weight: 600;
    }
    .btn {
      padding: 6px 16px;
      border: 2px solid #1976d2;
      background: transparent;
      color: #1976d2;
      font-size: 12px; font-weight: 600;
      border-radius: 8px; cursor: pointer;
      transition: background 0.15s, color 0.15s;
      white-space: nowrap;
    }
    .btn:hover { background: #1976d2; color: white; }
    .btn.active { background: #1976d2; color: white; }

    /* ── Tangle number scrubbing ── */
    .cm-tangle-number {
      color: #1976d2;
      border-bottom: 1.5px dashed rgba(25, 118, 210, 0.5);
      cursor: col-resize;
      padding: 3px 2px;
    }
    .cm-tangle-number:hover {
      background: rgba(25, 118, 210, 0.1);
      border-bottom-style: solid;
    }
    body.tangle-dragging, body.tangle-dragging * {
      cursor: col-resize !important;
      user-select: none !important;
    }
  </style>
</head>
<body>
<div class="page">
  <div class="header">
    <h1>Drawing</h1>
    <span class="status-dot ok" id="status"></span>
  </div>

  <div class="main">
    <div class="editor-col">
      <div class="tab-bar">
        <button class="tab active" data-tab="animation">Animation</button>
        <button class="tab" data-tab="meta">Meta</button>
        <button class="tab" data-tab="js">JS</button>
      </div>
      <div class="editor-wrap">
        <div class="editor-panel active" id="ep-animation"><div id="editor-animation"></div></div>
        <div class="editor-panel" id="ep-meta"><div id="editor-meta"></div></div>
        <div class="editor-panel" id="ep-js"><div id="editor-js"></div></div>
      </div>
      <div class="error" id="error"></div>
    </div>
    <div class="canvas-col">
      <div class="canvas-wrap">
        <div id="canvas-root"></div>
      </div>
      <div class="controls">
        <button class="btn" id="play-pause">Pause</button>
        <input type="range" id="slider" min="0" max="39" value="0">
        <span class="frame-label" id="frame-label">frame 0</span>
        <button class="btn" id="apply-meta">Apply Meta</button>
      </div>
    </div>
  </div>
</div>

<script type="module">
import { Rules4 } from './bridge.js';
import { renderTerm, patch } from './vdom.js';

const { EditorView, basicSetup } = await import('https://esm.sh/codemirror@6.0.1');
const { ViewPlugin, Decoration } = await import('https://esm.sh/@codemirror/view@6');
const { StreamLanguage } = await import('https://esm.sh/@codemirror/language@6');
const { javascript } = await import('https://esm.sh/@codemirror/lang-javascript@6');

// ── rules4 syntax highlighting ──

const rules4Parser = {
  name: "rules4",
  startState() { return { inString: false }; },
  token(stream, state) {
    if (state.inString) {
      while (!stream.eol()) {
        if (stream.peek() === '\\') { stream.next(); stream.next(); }
        else if (stream.next() === '"') { state.inString = false; return "string"; }
      }
      return "string";
    }
    if (stream.eatSpace()) return null;
    if (stream.peek() === '#') { stream.skipToEnd(); return "lineComment"; }
    if (stream.peek() === '"') {
      stream.next(); state.inString = true;
      while (!stream.eol()) {
        if (stream.peek() === '\\') { stream.next(); stream.next(); }
        else if (stream.next() === '"') { state.inString = false; return "string"; }
      }
      return "string";
    }
    if (stream.eat('@')) { stream.eatWhile(/[a-zA-Z_0-9]/); return "meta"; }
    if (stream.eat('?')) { stream.eatWhile(/[a-zA-Z_0-9]/); return "variableName.special"; }
    if (stream.match(/^\d+(\.\d+)?/)) return "number";
    if (stream.match("=>")) return "operator";
    if (stream.match("->")) return "operator";
    if (stream.match("==")) return "operator";
    if (stream.match("!=")) return "operator";
    if (stream.match(">=")) return "operator";
    if (stream.match("<=")) return "operator";
    if (stream.eat(/[=+\-*\/<>%]/)) return "operator";
    if (stream.eat(/[()]/)) return "paren";
    if (stream.eat(/[[\]]/)) return "squareBracket";
    if (stream.eat(/[{}]/)) return "brace";
    if (stream.eat(',')) return "separator";
    if (stream.match(/^[a-zA-Z_][a-zA-Z_0-9]*/)) {
      const w = stream.current();
      if (w === "fn" || w === "rule") return "definitionKeyword";
      if (w === "if" || w === "then" || w === "else") return "controlKeyword";
      if (w === "true" || w === "false" || w === "nil") return "atom";
      if (w === "cons" || w === "result") return "keyword";
      return "name";
    }
    stream.next();
    return null;
  },
  languageData: { commentTokens: { line: "#" } },
};

const rules4Language = StreamLanguage.define(rules4Parser);

// ── Tangle-style number scrubbing ──

function findNumberAt(lineText, col) {
  const commentIdx = lineText.indexOf('#');
  const searchEnd = commentIdx >= 0 ? commentIdx : lineText.length;
  const re = /\b(\d+(\.\d+)?)\b/g;
  let m;
  while ((m = re.exec(lineText)) !== null) {
    if (m.index >= searchEnd) break;
    if (col >= m.index && col < m.index + m[0].length) {
      return { text: m[0], start: m.index, end: m.index + m[0].length };
    }
  }
  return null;
}

const tangleNumberMark = Decoration.mark({ class: "cm-tangle-number" });

function buildNumberDecos(view) {
  const ranges = [];
  for (let i = 1; i <= view.state.doc.lines; i++) {
    const line = view.state.doc.line(i);
    const commentIdx = line.text.indexOf('#');
    const searchEnd = commentIdx >= 0 ? commentIdx : line.text.length;
    const re = /\b(\d+(\.\d+)?)\b/g;
    let m;
    while ((m = re.exec(line.text)) !== null) {
      if (m.index >= searchEnd) break;
      ranges.push(tangleNumberMark.range(line.from + m.index, line.from + m.index + m[0].length));
    }
  }
  return Decoration.set(ranges, true);
}

const tangleDecoPlugin = ViewPlugin.fromClass(class {
  constructor(view) { this.decorations = buildNumberDecos(view); }
  update(update) {
    if (update.docChanged || update.viewportChanged) {
      this.decorations = buildNumberDecos(update.view);
    }
  }
}, { decorations: v => v.decorations });

let isScrubbing = false;
let dragState = null;

function onDragMove(e) {
  if (!dragState) return;
  const dx = e.clientX - dragState.startX;
  const steps = Math.round(dx / 5);
  let newValue = dragState.startValue + steps * dragState.step;

  let newText;
  if (dragState.precision > 0) {
    newText = newValue.toFixed(dragState.precision);
  } else {
    newText = String(Math.round(newValue));
  }

  if (newText === dragState.lastText) return;

  dragState.view.dispatch({
    changes: {
      from: dragState.from,
      to: dragState.from + dragState.lastText.length,
      insert: newText,
    },
  });
  dragState.lastText = newText;
}

function onDragEnd() {
  isScrubbing = false;
  dragState = null;
  document.body.classList.remove('tangle-dragging');
  document.removeEventListener('mousemove', onDragMove);
  document.removeEventListener('mouseup', onDragEnd);
}

const tangleDragHandlers = EditorView.domEventHandlers({
  mousedown(event, view) {
    const pos = view.posAtCoords({ x: event.clientX, y: event.clientY });
    if (pos === null) return false;

    const line = view.state.doc.lineAt(pos);
    const col = pos - line.from;
    let num = findNumberAt(line.text, col);
    if (!num && col > 0) num = findNumberAt(line.text, col - 1);
    if (!num) num = findNumberAt(line.text, col + 1);
    if (!num) return false;

    event.preventDefault();
    isScrubbing = true;
    document.body.classList.add('tangle-dragging');

    const isFloat = num.text.includes('.');
    dragState = {
      view,
      startX: event.clientX,
      startValue: parseFloat(num.text),
      step: isFloat ? 0.1 : 1,
      precision: isFloat ? (num.text.split('.')[1] || '').length : 0,
      from: line.from + num.start,
      lastText: num.text,
    };

    document.addEventListener('mousemove', onDragMove);
    document.addEventListener('mouseup', onDragEnd);
    return true;
  },
});

function tangleExtension() {
  return [tangleDecoPlugin, tangleDragHandlers];
}

// ── Default code for each tab ──

const ANIM_CODE = `\
# === Bouncing ball animation ===

fn ball_x(?f) = ?f * 9 + 20

fn gravity() = 3

fn ball_vy(0) = 0
fn ball_vy(?f) =
  if ball_y(?f - 1) + ball_vy(?f - 1) + gravity() > 270
  then 0 - ball_vy(?f - 1)
  else ball_vy(?f - 1) + gravity()

fn ball_y(0) = 30
fn ball_y(?f) = ball_y(?f - 1) + ball_vy(?f)

# Drawing
fn draw(?f) = circle(ball_x(?f), ball_y(?f), 15)

fn ball_element() =
  element("circle",
    [attr("cx", ball_x(current_frame)),
     attr("cy", ball_y(current_frame)),
     attr("r", 15),
     attr("fill", "none"),
     attr("stroke", "#222"),
     attr("stroke-width", "2.5")], [])

fn render() = @dom element("svg",
  [attr("viewBox", "0 0 400 300"),
   attr("width", "100%"), attr("height", "100%")],
  cons(ball_element(), nil))

# State
fn init() = rule(current_frame, 0)
fn handle_event(set_frame, ?f) = rule(current_frame, ?f)

init()`;

const META_CODE = `\
# === Meta: Ghost Trail ===
# Two meta rules work together:
# 1. trace_draws captures draw() rewrites into @draw
# 2. render_override intercepts render() and replaces
#    its output with the ghost trail when active

rule trace_draws : @meta -> @draw {
  result(?step, draw(?f), ?shape) =>
    pair(ghost(?f), ?shape)
}

rule render_override : @meta -> @dom {
  result(?step, render(), ?val) =>
    if meta_active then
      element("svg",
        [attr("viewBox", "0 0 400 300"),
         attr("width", "100%"), attr("height", "100%")],
        ghost_and_ball(0))
    else ?val
}

# Drive all frames so draw() is evaluated for each
fn run_frames(?f) =
  if ?f >= 40 then 0
  else { draw(?f) run_frames(?f + 1) }

# Destructure circle terms
fn circle_cx(circle(?cx, ?cy, ?r)) = ?cx
fn circle_cy(circle(?cx, ?cy, ?r)) = ?cy
fn circle_r(circle(?cx, ?cy, ?r)) = ?r

# Ghost styling (past vs future)
fn ghost_opacity(?f) =
  if ?f < current_frame then "0.45"
  else "0.25"
fn ghost_stroke(?f) =
  if ?f < current_frame then "#555"
  else "#999"
fn ghost_sw(?f) =
  if ?f < current_frame then "1.2"
  else "0.9"

fn ghost_element(?f) =
  element("circle",
    [attr("cx", circle_cx(ghost(?f))),
     attr("cy", circle_cy(ghost(?f))),
     attr("r", circle_r(ghost(?f))),
     attr("fill", "none"),
     attr("stroke", ghost_stroke(?f)),
     attr("stroke-width", ghost_sw(?f)),
     attr("opacity", ghost_opacity(?f))], [])

# Build children: all ghosts + ball on top
fn ghost_and_ball(40) =
  cons(ball_element(), nil)
fn ghost_and_ball(?f) =
  if ?f == current_frame
  then ghost_and_ball(?f + 1)
  else cons(ghost_element(?f),
            ghost_and_ball(?f + 1))

# Meta state
fn meta_init() = rule(meta_active, false)
meta_init()

# Toggle meta on/off
fn handle_event(apply_meta, ?ev) =
  { run_frames(0) rule(meta_active, true) }
fn handle_event(remove_meta, ?ev) =
  rule(meta_active, false)`;

const JS_CODE = `\
import { Rules4 } from './bridge.js';
import { renderTerm, patch } from './vdom.js';

const r4 = await Rules4.load('./rules4.wasm');
r4.eval(r4.loadProgram(code));

let currentTree, currentTermId;

// Generic: apply any pending rule assertions from @draw
// Any 2-arg term pair(lhs, rhs) becomes assertRule(lhs, rhs)
function processRules() {
  for (const t of r4.scopeTakePending("draw")) {
    if (r4.termTag(t) === 2 && r4.termCallArity(t) === 2) {
      r4.assertRule(
        r4.termCallArg(t, 0),
        r4.termCallArg(t, 1));
    }
  }
}

// Render: process pending rules, eval render(), patch DOM
function doRender() {
  processRules();
  r4.eval(r4.call(r4.sym("render"), []));
  const pending = r4.scopeTakePending("dom");
  if (!pending.length) return;
  const term = pending[pending.length - 1];
  if (!currentTree) {
    currentTree = renderTerm(r4, term, handleEvent);
    root.appendChild(currentTree);
  } else {
    currentTree = patch(r4, currentTermId, term,
      currentTree, root, handleEvent);
  }
  currentTermId = term;
}

// Send named events into the rules4 engine
function sendEvent(name, value) {
  r4.eval(r4.call(r4.sym("handle_event"),
    [r4.sym(name), value]));
  doRender();
}

// Animation: tick each frame
let frame = 0;
requestAnimationFrame(function loop() {
  sendEvent("set_frame", r4.num(frame++ % 40));
  requestAnimationFrame(loop);
});`;

// ── Elements ──

const statusEl    = document.getElementById('status');
const errorEl     = document.getElementById('error');
const slider      = document.getElementById('slider');
const frameLabel  = document.getElementById('frame-label');
const playPauseBtn = document.getElementById('play-pause');
const applyMetaBtn = document.getElementById('apply-meta');
const canvasRoot  = document.getElementById('canvas-root');

// ── Tabbed editors ──

const tabs = document.querySelectorAll('.tab');
const editorPanels = document.querySelectorAll('.editor-panel');

tabs.forEach(tab => {
  tab.addEventListener('click', () => {
    const id = tab.dataset.tab;
    tabs.forEach(t => t.classList.toggle('active', t.dataset.tab === id));
    editorPanels.forEach(p => p.classList.toggle('active', p.id === `ep-${id}`));
  });
});

function makeEditor(parentId, doc) {
  return new EditorView({
    doc,
    extensions: [
      basicSetup,
      rules4Language,
      tangleExtension(),
      EditorView.updateListener.of(u => { if (u.docChanged) scheduleRun(); }),
    ],
    parent: document.getElementById(parentId),
  });
}

const animEditor = makeEditor('editor-animation', ANIM_CODE);
const metaEditor = makeEditor('editor-meta', META_CODE);

const jsEditor = new EditorView({
  doc: JS_CODE,
  extensions: [basicSetup, javascript(), EditorView.editable.of(false)],
  parent: document.getElementById('editor-js'),
});

function getAnimCode() {
  return animEditor.state.doc.toString();
}

function getAllCode() {
  return animEditor.state.doc.toString() + '\n' +
         metaEditor.state.doc.toString();
}

// ── WASM module cache ──

let cachedModule = null;

async function freshR4() {
  if (!cachedModule) {
    const resp = await fetch('./rules4.wasm');
    const bytes = await resp.arrayBuffer();
    cachedModule = await WebAssembly.compile(bytes);
  }
  const instance = await WebAssembly.instantiate(cachedModule, {});
  const r4 = new Rules4(instance);
  r4.wasm.engine_new();
  return r4;
}

// ── Engine state ──

let r4 = null;
let currentTree = null;
let currentTermId = null;
let currentFrame = 0;
let playing = true;
let metaApplied = false;
let tickCounter = 0;
let raf = null;
let runGeneration = 0;

// ── Debounced run ──

let runTimer = null;
function scheduleRun() {
  clearTimeout(runTimer);
  runTimer = setTimeout(() => run(), isScrubbing ? 0 : 300);
}

// ── Run: reload program ──

async function run() {
  const thisGen = ++runGeneration;
  statusEl.className = 'status-dot running';

  try {
    const newR4 = await freshR4();
    if (thisGen !== runGeneration) return;

    // Only include meta code when meta is applied,
    // otherwise meta rules output unevaluated if-expressions to @dom
    const code = metaApplied ? getAllCode() : getAnimCode();
    newR4.eval(newR4.loadProgram(code));
    if (thisGen !== runGeneration) return;

    r4 = newR4;
    currentTree = null;
    currentTermId = null;

    // Restore frame
    r4.eval(r4.call(r4.sym("handle_event"), [r4.sym("set_frame"), r4.num(currentFrame)]));

    // Trigger apply_meta so the meta rules run their setup
    if (metaApplied) {
      r4.eval(r4.call(r4.sym("handle_event"), [r4.sym("apply_meta"), r4.num(0)]));
    }

    doRender();
    errorEl.classList.remove('visible');
    statusEl.className = 'status-dot ok';
  } catch (e) {
    if (thisGen !== runGeneration) return;
    errorEl.textContent = e.message;
    errorEl.classList.add('visible');
    statusEl.className = 'status-dot err';
  }
}

// ── Generic: process any pending rule assertions from @draw ──

function processRules() {
  if (!r4) return;
  const pending = r4.scopeTakePending("draw");
  for (const t of pending) {
    if (r4.termTag(t) === 2 && r4.termCallArity(t) === 2) {
      r4.assertRule(r4.termCallArg(t, 0), r4.termCallArg(t, 1));
    }
  }
}

// ── Render: process rules, call render(), patch @dom output ──

function doRender() {
  if (!r4) return;
  try {
    processRules();
    r4.eval(r4.call(r4.sym("render"), []));
    const pending = r4.scopeTakePending("dom");
    if (pending.length === 0) return;
    const newTermId = pending[pending.length - 1];

    if (!currentTree) {
      const dom = renderTerm(r4, newTermId, () => {});
      canvasRoot.innerHTML = '';
      canvasRoot.appendChild(dom);
      currentTree = dom;
    } else {
      currentTree = patch(r4, currentTermId, newTermId, currentTree, canvasRoot, () => {});
    }
    currentTermId = newTermId;
  } catch (e) {
    // render errors non-fatal during animation
  }
}

// ── Animation loop ──

function animLoop() {
  if (playing && r4) {
    tickCounter++;
    if (tickCounter % 3 === 0) {
      try {
        currentFrame = (currentFrame + 1) % 40;
        r4.eval(r4.call(r4.sym("handle_event"), [r4.sym("set_frame"), r4.num(currentFrame)]));
        doRender();
        slider.value = currentFrame;
        frameLabel.textContent = `frame ${currentFrame}`;
      } catch (e) {
        console.error("[rules4] anim tick error:", e);
      }
    }
  }
  raf = requestAnimationFrame(animLoop);
}

// ── Controls ──

playPauseBtn.addEventListener('click', () => {
  playing = !playing;
  playPauseBtn.textContent = playing ? 'Pause' : 'Play';
  playPauseBtn.classList.toggle('active', !playing);
});

slider.addEventListener('input', () => {
  if (!r4) return;
  currentFrame = parseInt(slider.value);
  r4.eval(r4.call(r4.sym("handle_event"), [r4.sym("set_frame"), r4.num(currentFrame)]));
  doRender();
  frameLabel.textContent = `frame ${currentFrame}`;
});

applyMetaBtn.addEventListener('click', () => {
  metaApplied = !metaApplied;
  applyMetaBtn.textContent = metaApplied ? 'Remove Meta' : 'Apply Meta';
  applyMetaBtn.classList.toggle('active', metaApplied);
  // Full reload: meta changes which code is loaded
  scheduleRun();
});

// ── Init ──

await run();
raf = requestAnimationFrame(animLoop);
</script>
</body>
</html>
