<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Sokoban — PuzzleScript Compiler</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #1a1a2e;
      color: #e0e0e0;
      height: 100vh;
      overflow: hidden;
    }
    .page {
      display: flex;
      flex-direction: column;
      height: 100vh;
      padding: 12px;
      gap: 8px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-shrink: 0;
    }
    h1 { font-size: 20px; font-weight: 700; color: #f0f0f0; }
    .subtitle { font-size: 12px; color: #888; }
    .subtitle code {
      background: #2a2a4a; padding: 2px 6px; border-radius: 3px;
      color: #e94560; font-size: 11px;
    }
    .main {
      display: flex;
      gap: 12px;
      flex: 1;
      min-height: 0;
    }
    .editor-col {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-width: 0;
    }
    .tab-bar {
      display: flex; gap: 0; margin-bottom: 0;
    }
    .tab-btn {
      padding: 6px 16px;
      font-size: 12px; font-weight: 600;
      background: #12122a;
      color: #666;
      border: 1px solid #333;
      border-bottom: none;
      border-radius: 6px 6px 0 0;
      cursor: pointer;
      margin-right: 2px;
    }
    .tab-btn.active {
      background: #1e1e2e;
      color: #e0e0e0;
      border-bottom: 1px solid #1e1e2e;
      position: relative;
      z-index: 1;
    }
    .editor-wrap {
      flex: 1;
      overflow: hidden;
      border: 1px solid #333;
      border-radius: 0 8px 8px 8px;
      background: #1e1e2e;
      position: relative;
    }
    .editor-pane {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      display: none;
    }
    .editor-pane.active {
      display: block;
    }
    .editor-wrap .cm-editor {
      height: 100%;
    }
    .editor-wrap .cm-scroller {
      overflow: auto;
    }
    .game-col {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      flex-shrink: 0;
    }
    .game-area {
      background: #0f0f23;
      border: 2px solid #333;
      border-radius: 12px;
      overflow: hidden;
    }
    .game-area svg { display: block; }
    .controls { font-size: 11px; color: #666; text-align: center; }
    .status-dot {
      width: 8px; height: 8px; border-radius: 50%;
      display: inline-block; margin-left: 8px; vertical-align: middle;
    }
    .status-dot.ok { background: #22c55e; }
    .status-dot.err { background: #ef4444; }
    .status-dot.loading { background: #f59e0b; }
    .error-bar {
      background: #3b1111; color: #f87171; border-radius: 6px;
      padding: 6px 12px; font-size: 11px; margin-top: 4px;
      font-family: 'SF Mono', monospace;
      display: none; white-space: pre-wrap;
      max-height: 60px; overflow: auto;
    }
    .error-bar.visible { display: block; }
  </style>
</head>
<body>
<div class="page">
  <div class="header">
    <h1>Sokoban <span class="status-dot loading" id="status"></span></h1>
    <div class="subtitle">
      PuzzleScript rules compiled to native set rewrites via <code>defclause</code> + <code>make_term</code>
    </div>
  </div>

  <div class="main">
    <div class="editor-col">
      <div class="tab-bar">
        <button class="tab-btn active" data-tab="rules">Rules</button>
        <button class="tab-btn" data-tab="compiler">Compiler</button>
        <button class="tab-btn" data-tab="renderer">Renderer</button>
      </div>
      <div class="editor-wrap">
        <div class="editor-pane active" id="editor-rules"></div>
        <div class="editor-pane" id="editor-compiler"></div>
        <div class="editor-pane" id="editor-renderer"></div>
      </div>
      <div class="error-bar" id="error"></div>
    </div>
    <div class="game-col">
      <div class="game-area" id="game" tabindex="0"></div>
      <div class="controls">Arrow keys to move &middot; R to restart &middot; N for next level</div>
    </div>
  </div>
</div>

<script type="module">
import { Rules4 } from './bridge.js';

const RULES_CODE = `\
# ──────────────────────────────────────────────
# Sokoban — PuzzleScript Rules
# ──────────────────────────────────────────────
# Rules are written in PuzzleScript notation:
#   ps([match cells...], [result cells...])
# m(entity) marks a cell that moves in the direction.
# The compiler expands each rule into 4 directional
# step() clauses via term rewriting + defclause.

# ── Helpers ──
fn append(nil, ?ys) = ?ys
fn append(cons(?h, ?t), ?ys) = cons(?h, append(?t, ?ys))

# ── Win: every target(?x,?y) has at(?x,?y,crate) ──
fn won(#{target(?x, ?y), at(?x, ?y, crate), ?rest...}) = won(?rest...)
fn won(#{target(?x, ?y), ?rest...}) = false
fn won(?world) = true

# ── Levels (world = set of facts) ──
fn level(1) = #{
  at(0,0,wall), at(1,0,wall), at(2,0,wall), at(3,0,wall), at(4,0,wall), at(5,0,wall), at(6,0,wall),
  at(0,1,wall), at(1,1,floor), at(2,1,floor), at(3,1,wall), at(4,1,floor), at(5,1,floor), at(6,1,wall),
  at(0,2,wall), at(1,2,floor), at(2,2,floor), at(3,2,crate), at(4,2,floor), at(5,2,floor), at(6,2,wall),
  at(0,3,wall), at(1,3,floor), at(2,3,floor), at(3,3,player), at(4,3,floor), at(5,3,floor), at(6,3,wall),
  at(0,4,wall), at(1,4,wall), at(2,4,wall), at(3,4,wall), at(4,4,wall), at(5,4,wall), at(6,4,wall),
  target(2, 2), size(7, 5)
}

fn level(2) = #{
  at(0,0,wall), at(1,0,wall), at(2,0,wall), at(3,0,wall), at(4,0,wall), at(5,0,wall), at(6,0,wall), at(7,0,wall),
  at(0,1,wall), at(1,1,floor), at(2,1,floor), at(3,1,floor), at(4,1,floor), at(5,1,floor), at(6,1,floor), at(7,1,wall),
  at(0,2,wall), at(1,2,floor), at(2,2,player), at(3,2,floor), at(4,2,crate), at(5,2,floor), at(6,2,floor), at(7,2,wall),
  at(0,3,wall), at(1,3,floor), at(2,3,floor), at(3,3,wall), at(4,3,crate), at(5,3,floor), at(6,3,floor), at(7,3,wall),
  at(0,4,wall), at(1,4,floor), at(2,4,floor), at(3,4,floor), at(4,4,floor), at(5,4,floor), at(6,4,floor), at(7,4,wall),
  at(0,5,wall), at(1,5,wall), at(2,5,wall), at(3,5,wall), at(4,5,wall), at(5,5,wall), at(6,5,wall), at(7,5,wall),
  target(3, 4), target(4, 4), size(8, 6)
}

fn level(3) = #{
  at(0,0,wall), at(1,0,wall), at(2,0,wall), at(3,0,wall), at(4,0,wall), at(5,0,wall), at(6,0,wall), at(7,0,wall),
  at(0,1,wall), at(1,1,floor), at(2,1,floor), at(3,1,floor), at(4,1,floor), at(5,1,floor), at(6,1,floor), at(7,1,wall),
  at(0,2,wall), at(1,2,floor), at(2,2,crate), at(3,2,floor), at(4,2,wall), at(5,2,floor), at(6,2,floor), at(7,2,wall),
  at(0,3,wall), at(1,3,floor), at(2,3,floor), at(3,3,crate), at(4,3,floor), at(5,3,floor), at(6,3,floor), at(7,3,wall),
  at(0,4,wall), at(1,4,wall), at(2,4,floor), at(3,4,wall), at(4,4,floor), at(5,4,crate), at(6,4,floor), at(7,4,wall),
  at(0,5,wall), at(1,5,floor), at(2,5,floor), at(3,5,floor), at(4,5,floor), at(5,5,floor), at(6,5,floor), at(7,5,wall),
  at(0,6,wall), at(1,6,floor), at(2,6,player), at(3,6,floor), at(4,6,floor), at(5,6,floor), at(6,6,floor), at(7,6,wall),
  at(0,7,wall), at(1,7,wall), at(2,7,wall), at(3,7,wall), at(4,7,wall), at(5,7,wall), at(6,7,wall), at(7,7,wall),
  target(3, 5), target(5, 5), target(5, 6), size(8, 8)
}

# ── Event handling ──
fn handle_event(keydown, right) = do_move(right)
fn handle_event(keydown, left) = do_move(left)
fn handle_event(keydown, up) = do_move(up)
fn handle_event(keydown, down) = do_move(down)
fn handle_event(keydown, restart) = restart_level()
fn handle_event(keydown, next_level) = next_level()
fn handle_event(?a, ?b) = 0

fn do_move(?dir) =
  if screen == won then 0
  else {
    rule(world, step(?dir, world))
    rule(moves, moves + 1)
    check_win()
  }

fn check_win() =
  if won(world) then rule(screen, won) else 0

fn restart_level() = {
  rule(moves, 0)
  rule(screen, playing)
  rule(world, level(current_level))
}

fn next_level() =
  if screen == won then
    if current_level < num_levels then {
      rule(current_level, current_level + 1)
      rule(moves, 0)
      rule(screen, playing)
      rule(world, level(current_level))
    }
    else 0
  else 0

# ── Init ──
fn init() = {
  rule(current_level, 1)
  rule(moves, 0)
  rule(screen, playing)
  rule(num_levels, 3)
  rule(world, level(1))
}

# ── Compile rules and initialize ──
# (compile/defclause calls must be in a { } block
#  so they execute before init())
{
  compile(ps(
    [m(player) | crate | floor],
    [floor | m(player) | m(crate)]))
  compile(ps(
    [m(player) | floor],
    [floor | m(player)]))
  defclause(step, [__pvar(0), __pvar(1)], __pvar(1))
  init()
}
`;

const COMPILER_CODE = `\
# ──────────────────────────────────────────────
# PuzzleScript Compiler
# ──────────────────────────────────────────────
# Compiles ps() rules into native step() clauses
# via term expansion + defclause.
#
# Input:  ps([m(player) | crate | floor],
#             [floor | m(player) | m(crate)])
#
# Output: 4 directional step() clauses using
#         set patterns with computed coordinates.

# ── Compile one PS rule into 4 directional step clauses ──
fn compile(ps(?match, ?result)) = {
  compile_dir(right, 1, 0, to_vec(?match), to_vec(?result))
  compile_dir(left, 0 - 1, 0, to_vec(?match), to_vec(?result))
  compile_dir(down, 0, 1, to_vec(?match), to_vec(?result))
  compile_dir(up, 0, 0 - 1, to_vec(?match), to_vec(?result))
}

# ── Normalize cells(...) pipe syntax to vec ──
fn to_vec(cells(?items...)) = ?items
fn to_vec(?v) = ?v

# ── Build and install one directional clause ──
fn compile_dir(?dir, ?dx, ?dy, ?match, ?result) =
  defclause(step,
    [?dir, make_term(set, vec_push(build_ats(?match, 0, ?dx, ?dy), __spread(2)))],
    make_term(set, vec_push(build_ats(?result, 0, ?dx, ?dy), __spread(2))))

# ── Build vec of at() pattern terms from cell list ──
fn build_ats(vec(?cell, ?rest...), ?i, ?dx, ?dy) =
  vec_concat([mk_at(?cell, ?i, ?dx, ?dy)], build_ats(?rest, ?i + 1, ?dx, ?dy))
fn build_ats(vec(), ?i, ?dx, ?dy) = []

# ── Strip m() wrapper, build at(x_coord, y_coord, entity) ──
fn mk_at(m(?e), ?i, ?dx, ?dy) = mk_at(?e, ?i, ?dx, ?dy)
fn mk_at(?entity, ?i, ?dx, ?dy) =
  at(mk_coord(0, ?i * ?dx), mk_coord(1, ?i * ?dy), ?entity)

# ── Build coordinate: __pvar(id) or add/sub(__pvar(id), offset) ──
fn mk_coord(?var_id, 0) = __pvar(?var_id)
fn mk_coord(?var_id, ?offset) where ?offset > 0 = add(__pvar(?var_id), ?offset)
fn mk_coord(?var_id, ?offset) = sub(__pvar(?var_id), 0 - ?offset)
`;

const RENDERER_CODE = `\
# ──────────────────────────────────────────────
# Renderer
# ──────────────────────────────────────────────

# ── Extract grid dimensions from world ──
fn grid_w(#{size(?w, ?h), _...}) = ?w
fn grid_h(#{size(?w, ?h), _...}) = ?h

# ── Look up cell entity by coordinates ──
fn cell_at(?x, ?y, #{at(?x, ?y, ?entity), _...}) = ?entity
fn cell_at(?x, ?y, ?world) = empty

# ── Target membership check ──
fn is_target(?x, ?y, #{target(?x, ?y), _...}) = true
fn is_target(?x, ?y, ?world) = false

# ── Rendering helpers ──
fn floor_rect(?x, ?y) = element("rect",
  [attr("x", ?x * 64 + 1), attr("y", ?y * 64 + 1),
   attr("width", 62), attr("height", 62),
   attr("rx", 4), attr("fill", "#3a3a4a")], [])

fn target_marker(?x, ?y) = cons(
  element("circle",
    [attr("cx", ?x * 64 + 32), attr("cy", ?y * 64 + 32),
     attr("r", 8), attr("fill", "none"),
     attr("stroke", "#e74c3c"), attr("stroke-width", 3),
     attr("opacity", "0.7")], []),
  cons(element("circle",
    [attr("cx", ?x * 64 + 32), attr("cy", ?y * 64 + 32),
     attr("r", 3), attr("fill", "#e74c3c"),
     attr("opacity", "0.7")], []), nil))

# ── Cell rendering (returns cons-list of SVG elements) ──
fn cell_elems(?x, ?y) = tile(?x, ?y, cell_at(?x, ?y, world), is_target(?x, ?y, world))

# Wall
fn tile(?x, ?y, wall, ?t) = cons(element("rect",
  [attr("x", ?x * 64 + 1), attr("y", ?y * 64 + 1),
   attr("width", 62), attr("height", 62),
   attr("rx", 4), attr("fill", "#5D4E37")], []), nil)

# Floor + target
fn tile(?x, ?y, floor, true) =
  cons(floor_rect(?x, ?y), target_marker(?x, ?y))

# Plain floor
fn tile(?x, ?y, floor, ?t) = cons(floor_rect(?x, ?y), nil)

# Player
fn tile(?x, ?y, player, ?t) = cons(floor_rect(?x, ?y),
  cons(element("circle",
    [attr("cx", ?x * 64 + 32), attr("cy", ?y * 64 + 32),
     attr("r", 22), attr("fill", "#3498DB")], []),
  cons(element("circle",
    [attr("cx", ?x * 64 + 32), attr("cy", ?y * 64 + 32),
     attr("r", 16), attr("fill", "#5DADE2")], []),
  cons(element("circle",
    [attr("cx", ?x * 64 + 26), attr("cy", ?y * 64 + 28),
     attr("r", 3), attr("fill", "white")], []),
  cons(element("circle",
    [attr("cx", ?x * 64 + 38), attr("cy", ?y * 64 + 28),
     attr("r", 3), attr("fill", "white")], []),
  nil)))))

# Crate on target (green)
fn tile(?x, ?y, crate, true) = cons(floor_rect(?x, ?y),
  cons(element("circle",
    [attr("cx", ?x * 64 + 32), attr("cy", ?y * 64 + 32),
     attr("r", 8), attr("fill", "none"),
     attr("stroke", "#e74c3c"), attr("stroke-width", 3),
     attr("opacity", "0.3")], []),
  cons(element("rect",
    [attr("x", ?x * 64 + 8), attr("y", ?y * 64 + 8),
     attr("width", 48), attr("height", 48),
     attr("rx", 6), attr("fill", "#27ae60")], []),
  cons(element("rect",
    [attr("x", ?x * 64 + 14), attr("y", ?y * 64 + 14),
     attr("width", 36), attr("height", 36),
     attr("rx", 4), attr("fill", "#2ecc71"),
     attr("opacity", "0.4")], []),
  nil))))

# Crate (orange)
fn tile(?x, ?y, crate, ?t) = cons(floor_rect(?x, ?y),
  cons(element("rect",
    [attr("x", ?x * 64 + 8), attr("y", ?y * 64 + 8),
     attr("width", 48), attr("height", 48),
     attr("rx", 6), attr("fill", "#E67E22")], []),
  cons(element("rect",
    [attr("x", ?x * 64 + 14), attr("y", ?y * 64 + 14),
     attr("width", 36), attr("height", 36),
     attr("rx", 4), attr("fill", "#F39C12"),
     attr("opacity", "0.4")], []),
  nil)))

# Empty cell (outside grid)
fn tile(?x, ?y, empty, ?t) = nil

# ── Grid rendering ──
fn render_cells(?x, ?y, ?w, ?h) =
  if ?y == ?h then nil
  else if ?x == ?w then render_cells(0, ?y + 1, ?w, ?h)
  else append(cell_elems(?x, ?y), render_cells(?x + 1, ?y, ?w, ?h))

# ── HUD ──
fn render_hud(?w, ?h) = cons(
  element("rect",
    [attr("x", 0), attr("y", ?h * 64),
     attr("width", ?w * 64), attr("height", 48),
     attr("fill", "#1a1a2e")], []),
  cons(element("text",
    [attr("x", 10), attr("y", ?h * 64 + 30),
     attr("fill", "#888"), attr("font-size", 14),
     attr("font-family", "sans-serif")],
    [text("Level " ++ current_level)]),
  cons(element("text",
    [attr("x", ?w * 32), attr("y", ?h * 64 + 30),
     attr("text-anchor", "middle"),
     attr("fill", "#888"), attr("font-size", 14),
     attr("font-family", "sans-serif")],
    [text("Moves: " ++ moves)]),
  nil)))

# ── Win overlay ──
fn render_win() = render_win_screen(screen)

fn render_win_screen(won) = cons(
  element("rect",
    [attr("x", 0), attr("y", 0),
     attr("width", grid_w(world) * 64), attr("height", grid_h(world) * 64),
     attr("fill", "rgba(0,0,0,0.65)")], []),
  cons(element("text",
    [attr("x", grid_w(world) * 32), attr("y", grid_h(world) * 32 - 10),
     attr("text-anchor", "middle"),
     attr("font-size", 32), attr("fill", "#22c55e"),
     attr("font-family", "sans-serif"),
     attr("font-weight", "bold")],
    [text("Level Complete!")]),
  cons(element("text",
    [attr("x", grid_w(world) * 32), attr("y", grid_h(world) * 32 + 20),
     attr("text-anchor", "middle"),
     attr("font-size", 16), attr("fill", "#ccc"),
     attr("font-family", "sans-serif")],
    [text("Moves: " ++ moves)]),
  cons(element("text",
    [attr("x", grid_w(world) * 32), attr("y", grid_h(world) * 32 + 48),
     attr("text-anchor", "middle"),
     attr("font-size", 13), attr("fill", "#888"),
     attr("font-family", "sans-serif")],
    [text(win_message())]),
  nil))))

fn render_win_screen(?other) = nil

fn win_message() =
  if current_level < num_levels then "Press N for next level"
  else "All levels complete! Press R to replay."

# ── Main render function ──
fn render() =
  @dom element("svg",
    [attr("viewBox", "0 0 " ++ (grid_w(world) * 64) ++ " " ++ (grid_h(world) * 64 + 48)),
     attr("width", grid_w(world) * 64),
     attr("height", grid_h(world) * 64 + 48),
     attr("style", "background:#2c2c3a")],
    append(render_cells(0, 0, grid_w(world), grid_h(world)),
           append(render_hud(grid_w(world), grid_h(world)), render_win())))
`;

// ── Minimal DOM renderer ──

const SVG_NS = "http://www.w3.org/2000/svg";
const SVG_TAGS = new Set([
  "svg","g","rect","circle","ellipse","line","polyline","polygon",
  "path","text","tspan","image","defs","clipPath","use",
]);

function termToString(r4, id) {
  const tag = r4.termTag(id);
  if (tag === 0) return String(r4.termNum(id));
  if (tag === 3) return String(r4.termFloat(id));
  if (tag === 1) return r4.termSymName(id);
  return r4.display(id);
}

function forEachItem(r4, listTerm, fn) {
  const tag = r4.termTag(listTerm);
  if (tag === 1 && r4.termSymName(listTerm) === "nil") return;
  if (tag !== 2) return;
  const headId = r4.termCallHead(listTerm);
  if (r4.termTag(headId) !== 1) return;
  const headName = r4.termSymName(headId);
  if (headName === "vec") {
    const arity = r4.termCallArity(listTerm);
    for (let i = 0; i < arity; i++) fn(r4.termCallArg(listTerm, i));
  } else if (headName === "cons") {
    let cur = listTerm;
    while (true) {
      const t = r4.termTag(cur);
      if (t === 1 && r4.termSymName(cur) === "nil") break;
      if (t !== 2) break;
      const h = r4.termCallHead(cur);
      if (r4.termTag(h) !== 1 || r4.termSymName(h) !== "cons") break;
      fn(r4.termCallArg(cur, 0));
      cur = r4.termCallArg(cur, 1);
    }
  }
}

function renderTerm(r4, termId, svgCtx = false) {
  const tag = r4.termTag(termId);
  if (tag === 0) return document.createTextNode(String(r4.termNum(termId)));
  if (tag === 3) return document.createTextNode(String(r4.termFloat(termId)));
  if (tag === 1) return document.createTextNode(r4.termSymName(termId));
  const headId = r4.termCallHead(termId);
  if (r4.termTag(headId) !== 1) return document.createTextNode(r4.display(termId));
  const headName = r4.termSymName(headId);
  if (headName === "text") {
    return document.createTextNode(termToString(r4, r4.termCallArg(termId, 0)));
  }
  if (headName === "element") {
    const tagName = termToString(r4, r4.termCallArg(termId, 0));
    const isSvg = tagName === "svg" || svgCtx || SVG_TAGS.has(tagName);
    const el = isSvg
      ? document.createElementNS(SVG_NS, tagName)
      : document.createElement(tagName);
    forEachItem(r4, r4.termCallArg(termId, 1), (attrTerm) => {
      const ah = r4.termCallHead(attrTerm);
      if (r4.termTag(ah) === 1 && r4.termSymName(ah) === "attr") {
        const name = termToString(r4, r4.termCallArg(attrTerm, 0));
        const val = termToString(r4, r4.termCallArg(attrTerm, 1));
        el.setAttribute(name, val);
      }
    });
    forEachItem(r4, r4.termCallArg(termId, 2), (childTerm) => {
      el.appendChild(renderTerm(r4, childTerm, isSvg));
    });
    return el;
  }
  return document.createTextNode(r4.display(termId));
}

// ── Elements ──

const statusEl = document.getElementById('status');
const errorEl = document.getElementById('error');
const gameEl = document.getElementById('game');

// ── WASM module cache ──

let cachedModule = null;

async function freshR4() {
  if (!cachedModule) {
    const resp = await fetch('./rules4.wasm');
    const bytes = await resp.arrayBuffer();
    cachedModule = await WebAssembly.compile(bytes);
  }
  const instance = await WebAssembly.instantiate(cachedModule, {});
  const r4 = new Rules4(instance);
  r4.wasm.engine_new();
  return r4;
}

// ── CodeMirror 6 ──

const { EditorView, basicSetup } = await import('https://esm.sh/codemirror@6.0.1');
const { oneDark } = await import('https://esm.sh/@codemirror/theme-one-dark@6.1.2');
const { StreamLanguage } = await import('https://esm.sh/@codemirror/language@6.10.8');

const rules4Lang = StreamLanguage.define({
  token(stream) {
    if (stream.match('#')) { stream.skipToEnd(); return 'comment'; }
    if (stream.match('"')) {
      while (!stream.eol()) { if (stream.next() === '"') break; }
      return 'string';
    }
    if (stream.match(/^-?\d+(\.\d+)?/)) return 'number';
    if (stream.match(/^\?[a-zA-Z_]\w*/)) return 'variable-2';
    if (stream.match(/^@[a-zA-Z_]\w*/)) return 'meta';
    if (stream.match(/^(fn|rule|if|then|else|emit|where)\b/)) return 'keyword';
    if (stream.match(/^(=>|->|==|!=|>=|<=|>|<|\+\+)/)) return 'operator';
    if (stream.match(/^(retract|query_all|floor|abs|random|mod|true|false|nil|cons|vec_get|vec_len|vec_push|vec_concat|make_term|defclause|compile)\b/)) return 'atom';
    if (stream.match(/^__[a-zA-Z_]\w*/)) return 'meta';
    if (stream.match(/^[a-zA-Z_]\w*/)) return 'variable';
    if (stream.match(/^[()[\]{},=|]/)) return 'bracket';
    stream.next();
    return null;
  },
});

const rulesEditor = new EditorView({
  doc: RULES_CODE,
  extensions: [
    basicSetup,
    oneDark,
    rules4Lang,
    EditorView.updateListener.of(update => {
      if (update.docChanged) scheduleRestart();
    }),
  ],
  parent: document.getElementById('editor-rules'),
});

const compilerEditor = new EditorView({
  doc: COMPILER_CODE,
  extensions: [
    basicSetup,
    oneDark,
    rules4Lang,
    EditorView.updateListener.of(update => {
      if (update.docChanged) scheduleRestart();
    }),
  ],
  parent: document.getElementById('editor-compiler'),
});

const rendererEditor = new EditorView({
  doc: RENDERER_CODE,
  extensions: [
    basicSetup,
    oneDark,
    rules4Lang,
    EditorView.updateListener.of(update => {
      if (update.docChanged) scheduleRestart();
    }),
  ],
  parent: document.getElementById('editor-renderer'),
});

// ── Tab switching ──

const editors = { rules: rulesEditor, compiler: compilerEditor, renderer: rendererEditor };
const tabBtns = document.querySelectorAll('.tab-btn');
const editorPanes = document.querySelectorAll('.editor-pane');

tabBtns.forEach(btn => {
  btn.addEventListener('click', () => {
    const tab = btn.dataset.tab;
    tabBtns.forEach(b => b.classList.toggle('active', b === btn));
    editorPanes.forEach(p => p.classList.toggle('active', p.id === `editor-${tab}`));
    if (editors[tab]) editors[tab].requestMeasure();
  });
});

// ── Game state ──

let currentR4 = null;
let handleEventSym = null;
let renderSym = null;
let keydownSym = null;

function doRender() {
  if (!currentR4) return;
  const call = currentR4.call(renderSym, []);
  currentR4.eval(call);
  const pending = currentR4.scopeTakePending("dom");
  if (pending.length === 0) return;
  const dom = renderTerm(currentR4, pending[pending.length - 1]);
  gameEl.innerHTML = '';
  gameEl.appendChild(dom);
}

function sendKey(name) {
  if (!currentR4) return;
  const sym = currentR4.sym(name);
  const call = currentR4.call(handleEventSym, [keydownSym, sym]);
  currentR4.eval(call);
  doRender();
}

// ── Restart on code change ──

let restartTimer = null;
let generation = 0;

function scheduleRestart() {
  clearTimeout(restartTimer);
  restartTimer = setTimeout(restart, 600);
}

async function restart() {
  const thisGen = ++generation;
  statusEl.className = 'status-dot loading';

  try {
    const r4 = await freshR4();
    if (thisGen !== generation) return;

    // Load order: renderer first, then compiler, then rules (which call compile())
    const code = rendererEditor.state.doc.toString() + '\n'
      + compilerEditor.state.doc.toString() + '\n'
      + rulesEditor.state.doc.toString();
    r4.eval(r4.loadProgram(code));
    if (thisGen !== generation) return;

    currentR4 = r4;
    handleEventSym = r4.sym("handle_event");
    renderSym = r4.sym("render");
    keydownSym = r4.sym("keydown");

    doRender();
    errorEl.classList.remove('visible');
    statusEl.className = 'status-dot ok';
  } catch (e) {
    if (thisGen !== generation) return;
    errorEl.textContent = e.message;
    errorEl.classList.add('visible');
    statusEl.className = 'status-dot err';
  }
}

// ── Key event wiring ──

const KEY_MAP = {
  ArrowUp: 'up', ArrowDown: 'down', ArrowLeft: 'left', ArrowRight: 'right',
  w: 'up', s: 'down', a: 'left', d: 'right',
};

document.addEventListener('keydown', (e) => {
  if (e.target.closest('.cm-editor')) return;
  if (e.key === 'r' || e.key === 'R') { sendKey('restart'); return; }
  if (e.key === 'n' || e.key === 'N') { sendKey('next_level'); return; }
  const dir = KEY_MAP[e.key];
  if (dir) { e.preventDefault(); sendKey(dir); }
});

// ── Initial boot ──

await restart();
</script>
</body>
</html>
