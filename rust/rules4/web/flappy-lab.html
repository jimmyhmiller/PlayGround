<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Flappy Bird Lab — Rules4</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #1a1a2e;
      color: #e0e0e0;
      overflow-x: hidden;
    }
    .page { max-width: 1400px; margin: 0 auto; padding: 12px 16px; }
    .header {
      display: flex; align-items: center; gap: 10px; margin-bottom: 10px;
    }
    h1 { font-size: 18px; font-weight: 700; color: #f0f0f0; }
    .status-dot {
      width: 8px; height: 8px; border-radius: 50%;
      display: inline-block; transition: background 0.2s;
    }
    .status-dot.ok { background: #22c55e; }
    .status-dot.err { background: #ef4444; }
    .status-dot.loading { background: #f59e0b; }

    .main {
      display: flex; gap: 12px; margin-bottom: 8px;
      height: 480px;
    }
    .editor-col {
      flex: 1; display: flex; flex-direction: column; min-width: 0; min-height: 0;
    }
    .game-col {
      width: 480px; flex-shrink: 0;
      background: #0f0f23;
      border: 1px solid #333;
      border-radius: 8px;
      overflow: hidden;
      cursor: pointer;
      position: relative;
    }
    .game-col svg { display: block; }

    .tab-bar {
      display: flex; gap: 0; margin-bottom: 0;
    }
    .tab-btn {
      padding: 6px 16px;
      font-size: 12px; font-weight: 600;
      background: #12122a;
      color: #666;
      border: 1px solid #333;
      border-bottom: none;
      border-radius: 6px 6px 0 0;
      cursor: pointer;
      margin-right: 2px;
    }
    .tab-btn.active {
      background: #1e1e2e;
      color: #e0e0e0;
      border-bottom: 1px solid #1e1e2e;
      position: relative;
      z-index: 1;
    }
    .editor-wrap {
      flex: 1;
      min-height: 0;
      border: 1px solid #333;
      border-radius: 0 8px 8px 8px;
      overflow: hidden;
      background: #1e1e2e;
      position: relative;
    }
    .editor-pane {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      display: none;
    }
    .editor-pane.active {
      display: block;
    }
    .cm-editor { height: 100%; }
    .cm-editor .cm-scroller { overflow: auto !important; }
    .cm-editor .cm-content {
      font-family: 'SF Mono', 'Fira Code', 'Menlo', monospace;
      font-size: 12px;
    }
    .cm-editor .cm-gutters {
      background: #16162a;
      border-right: 1px solid #333;
    }
    .cm-editor.cm-focused { outline: none; }

    .error-bar {
      background: #3b1111; color: #f87171; border-radius: 6px;
      padding: 4px 10px; font-size: 11px; margin-top: 6px;
      font-family: 'SF Mono', monospace;
      max-height: 40px; overflow: auto;
      display: none; white-space: pre-wrap;
    }
    .error-bar.visible { display: block; }

    .viz-row {
      display: flex; flex-wrap: wrap; gap: 10px;
      margin-top: 10px;
    }
    .viz-panel {
      flex: 1; min-width: 280px; max-width: 460px;
      background: #16162a;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 8px 10px;
    }
    .viz-panel h3 {
      font-size: 11px; font-weight: 600;
      color: #888; text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 4px;
    }
    .viz-panel svg { display: block; width: 100%; }
  </style>
</head>
<body>
<div class="page">
  <div class="header">
    <h1>Flappy Bird Lab</h1>
    <span class="status-dot loading" id="status"></span>
  </div>

  <div class="main">
    <div class="editor-col">
      <div class="tab-bar">
        <button class="tab-btn" data-tab="chart">Chart Lib</button>
        <button class="tab-btn" data-tab="game">Game</button>
        <button class="tab-btn active" data-tab="meta">Meta / Viz</button>
        <button class="tab-btn" data-tab="js">Support JS</button>
      </div>
      <div class="editor-wrap" id="editor-wrap">
        <div class="editor-pane" id="editor-chart"></div>
        <div class="editor-pane" id="editor-game"></div>
        <div class="editor-pane active" id="editor-meta"></div>
        <div class="editor-pane" id="editor-js"></div>
      </div>
      <div class="error-bar" id="error"></div>
    </div>
    <div class="game-col" id="game">
    </div>
  </div>

  <div id="viz-row"></div>
</div>

<script type="module">
import { Rules4 } from './bridge.js';
import { renderTerm, patch } from './vdom.js';

// ── Default programs ──

const DEFAULT_CHART = `\
# ── Pure Rules4 Scatter Plot Library ──

# ── List utilities ──
fn take(0, ?xs) = nil
fn take(?n, cons(?h, ?t)) = cons(?h, take(?n - 1, ?t))
fn take(?n, nil) = nil

fn len(?xs) = list_len(?xs)
fn reverse(?xs) = list_reverse(?xs)

fn concat_lists(nil, ?ys) = ?ys
fn concat_lists(cons(?h, ?t), ?ys) = cons(?h, concat_lists(?t, ?ys))

# ── Min/max/endpoint helpers ──
fn min_y(cons(point(?x, ?y), ?rest)) = min_y_acc(?rest, ?y)
fn min_y_acc(nil, ?acc) = ?acc
fn min_y_acc(cons(point(?x, ?y), ?rest), ?acc) =
  if ?y < ?acc then min_y_acc(?rest, ?y) else min_y_acc(?rest, ?acc)

fn max_y(cons(point(?x, ?y), ?rest)) = max_y_acc(?rest, ?y)
fn max_y_acc(nil, ?acc) = ?acc
fn max_y_acc(cons(point(?x, ?y), ?rest), ?acc) =
  if ?y > ?acc then max_y_acc(?rest, ?y) else max_y_acc(?rest, ?acc)

fn first_x(cons(point(?x, ?y), ?rest)) = ?x
fn last_x(cons(point(?x, ?y), nil)) = ?x
fn last_x(cons(?h, ?t)) = last_x(?t)

fn last_y(cons(point(?x, ?y), nil)) = ?y
fn last_y(cons(?h, ?t)) = last_y(?t)

fn safe_range(?min, ?max) =
  if ?max == ?min then 2.0 else ?max - ?min

# ── Coordinate scaling (W=390, H=96, padTop=8) ──
fn sx(?x, ?minX, ?rX) = (?x - ?minX) / ?rX * 390.0
fn sy(?y, ?minY, ?rY) = 8.0 + 96.0 - ((?y - ?minY) / ?rY * 96.0)

fn round1(?x) = floor(?x * 10.0) / 10.0

# ── Scatter dot builder ──
fn build_dots(nil, ?minX, ?rX, ?minY, ?rY, ?color, ?idx) = nil
fn build_dots(cons(point(?x, ?y), ?rest), ?minX, ?rX, ?minY, ?rY, ?color, ?idx) =
  cons(element("circle",
    [attr("cx", round1(sx(?x, ?minX, ?rX))),
     attr("cy", round1(sy(?y, ?minY, ?rY))),
     attr("r", 2.5),
     attr("fill", ?color),
     attr("opacity", 0.3 + 0.7 * (?idx / 60.0))], []),
  build_dots(?rest, ?minX, ?rX, ?minY, ?rY, ?color, ?idx + 1.0))

# ── Scatter plot rendering pipeline ──
fn render_scatter(?title, ?pts, ?color) =
  render_scatter_check(?title, ?pts, ?color, len(?pts))

fn render_scatter_check(?title, ?pts, ?color, ?n) =
  if ?n < 2 then element("div", [attr("class", "viz-panel")], [
    element("h3", [], [text(?title)]),
    element("svg", [attr("viewBox", "0 0 400 120"), attr("height", "120")], [])])
  else render_scatter_data(?title, list_reverse(?pts), ?color)

fn render_scatter_data(?title, ?pts, ?color) =
  render_scatter_scaled(?title, ?pts, ?color,
    first_x(?pts), last_x(?pts), min_y(?pts), max_y(?pts))

fn render_scatter_scaled(?title, ?pts, ?color, ?x0, ?x1, ?yMin, ?yMax) =
  render_scatter_final(?title, ?pts, ?color, ?x0, ?yMin,
    safe_range(?x0, ?x1), safe_range(?yMin, ?yMax), ?yMin, ?yMax,
    last_x(?pts), last_y(?pts))

fn render_scatter_final(?title, ?pts, ?color, ?minX, ?minY, ?rX, ?rY, ?yMin, ?yMax, ?lx, ?ly) =
  element("div", [attr("class", "viz-panel")], [
    element("h3", [], [text(?title)]),
    element("svg",
      [attr("viewBox", "0 0 400 120"), attr("height", "120")],
      concat_lists(
        [element("line", [attr("x1", 0), attr("y1", sy(?yMin, ?minY, ?rY)),
                          attr("x2", 390), attr("y2", sy(?yMin, ?minY, ?rY)),
                          attr("stroke", "#333"), attr("stroke-width", "0.5")], []),
         element("line", [attr("x1", 0), attr("y1", sy((?yMin + ?yMax) / 2.0, ?minY, ?rY)),
                          attr("x2", 390), attr("y2", sy((?yMin + ?yMax) / 2.0, ?minY, ?rY)),
                          attr("stroke", "#333"), attr("stroke-width", "0.5"),
                          attr("stroke-dasharray", "4")], []),
         element("line", [attr("x1", 0), attr("y1", sy(?yMax, ?minY, ?rY)),
                          attr("x2", 390), attr("y2", sy(?yMax, ?minY, ?rY)),
                          attr("stroke", "#333"), attr("stroke-width", "0.5")], [])],
        concat_lists(
          build_dots(?pts, ?minX, ?rX, ?minY, ?rY, ?color, 0.0),
          [element("circle", [attr("cx", round1(sx(?lx, ?minX, ?rX))),
                              attr("cy", round1(sy(?ly, ?minY, ?rY))),
                              attr("r", 4), attr("fill", ?color),
                              attr("stroke", "white"), attr("stroke-width", "1")], []),
           element("text", [attr("x", round1(sx(?lx, ?minX, ?rX)) + 8.0),
                            attr("y", round1(sy(?ly, ?minY, ?rY)) + 3.0),
                            attr("fill", ?color), attr("font-size", "10"),
                            attr("font-weight", "bold"),
                            attr("font-family", "monospace")],
                  [text(round1(?ly))]),
           element("text", [attr("x", 0), attr("y", 118),
                            attr("fill", "#666"), attr("font-size", "9"),
                            attr("font-family", "monospace")],
                  [text(round1(?yMin))]),
           element("text", [attr("x", 390), attr("y", 118),
                            attr("fill", "#666"), attr("font-size", "9"),
                            attr("font-family", "monospace"), attr("text-anchor", "end")],
                  [text(round1(?yMax))])])))])
`;

const DEFAULT_GAME = `\
# ── Flappy Bird in Rules4 ──

# ── Initial state ──
fn init() = {
  rule(screen, menu)
  rule(player_y, 50.0)
  rule(velocity, 0.0)
  rule(distance, 0.0)
  rule(best, 0)
  rule(pipe_gap_0, 35.0)
  rule(pipe_off_0, 0.0)
  rule(pipe_h_0, 25.0)
  rule(pipe_gap_1, 35.0)
  rule(pipe_off_1, -1.1)
  rule(pipe_h_1, 45.0)
  rule(chart_bird_y, nil)
  rule(chart_score, nil)
  rule(chart_score_n, 0.0)
}

fn score() = floor(distance)

# ── Bird physics ──
fn update_bird() = {
  rule(velocity, velocity + 0.065)
  rule(player_y, player_y + velocity)
  player_y
}

# ── Tick handler (game loop) ──
fn handle_event(tick, ?frame) =
  if screen == game then {
    rule(distance, distance + 0.015)
    update_bird()
    check_collisions()
  }
  else 0

# ── Click handler ──
fn handle_event(click, ?ev) =
  if screen == game then rule(velocity, -1.25)
  else if screen == menu then start_game()
  else start_game()

fn start_game() = {
  rule(best, if score() > best then score() else best)
  rule(screen, game)
  rule(distance, 0.0)
  rule(player_y, 50.0)
  rule(velocity, 0.0)
  rule(pipe_off_0, 0.0)
  rule(pipe_h_0, 25.0)
  rule(pipe_off_1, -1.1)
  rule(pipe_h_1, 45.0)
  rule(chart_bird_y, nil)
  rule(chart_score, nil)
}

# ── Collision detection ──
fn check_collisions() = {
  check_ground()
  check_pipe_0()
  check_pipe_1()
}

fn check_ground() =
  if player_y > 88.0 then { rule(screen, dead) hit_floor }
  else if player_y < 0.0 then { rule(screen, dead) hit_ceil }
  else ok

fn pipe_x(?off) = 100.0 - (50.0 * ((distance + ?off) % 2.2))

fn check_pipe_0() =
  if pipe_x(pipe_off_0) > 15.0 then far
  else if pipe_x(pipe_off_0) < 25.0 then
    if player_y < pipe_h_0 then { rule(screen, dead) hit_top }
    else if player_y > (pipe_h_0 + pipe_gap_0) then { rule(screen, dead) hit_bot }
    else pass
  else past

fn check_pipe_1() =
  if pipe_x(pipe_off_1) > 15.0 then far
  else if pipe_x(pipe_off_1) < 25.0 then
    if player_y < pipe_h_1 then { rule(screen, dead) hit_top }
    else if player_y > (pipe_h_1 + pipe_gap_1) then { rule(screen, dead) hit_bot }
    else pass
  else past

# ── Rendering ──
fn render() = @dom element("svg",
  [attr("viewBox", "0 0 100 100"),
   attr("width", 480),
   attr("height", 480),
   attr("style", "background: #70c5ce")],
  [render_bg(),
   render_pipe(pipe_off_0, pipe_h_0, pipe_gap_0),
   render_pipe(pipe_off_1, pipe_h_1, pipe_gap_1),
   render_player(),
   render_ground(),
   render_ui(),
   render_debug()])

fn render_bg() = element("g", [], [
  element("rect", [attr("x", 0), attr("y", 0),
                   attr("width", 100), attr("height", 100),
                   attr("fill", "#70c5ce")], [])])

fn render_ground() = element("rect",
  [attr("x", 0), attr("y", 90),
   attr("width", 100), attr("height", 10),
   attr("fill", "#ded895")], [])

fn render_player() = element("g", [], [
  element("circle",
    [attr("cx", 20),
     attr("cy", player_y),
     attr("r", 3),
     attr("fill", "#f7dc6f")], []),
  element("circle",
    [attr("cx", 21.5),
     attr("cy", player_y - 0.8),
     attr("r", 0.8),
     attr("fill", "white")], []),
  element("circle",
    [attr("cx", 22.0),
     attr("cy", player_y - 0.8),
     attr("r", 0.4),
     attr("fill", "black")], []),
  element("polygon",
    [attr("points", "23," ++ (player_y - 0.3) ++ " 26," ++ player_y ++ " 23," ++ (player_y + 0.3)),
     attr("fill", "#e74c3c")], [])])

fn render_pipe(?off, ?h, ?gap) = element("g", [], [
  element("rect",
    [attr("x", pipe_x(?off)),
     attr("y", 0),
     attr("width", 8),
     attr("height", ?h),
     attr("fill", "#27ae60")], []),
  element("rect",
    [attr("x", pipe_x(?off)),
     attr("y", ?h + ?gap),
     attr("width", 8),
     attr("height", 100.0 - ?h - ?gap),
     attr("fill", "#27ae60")], [])])

fn render_ui() =
  if screen == menu then element("g", [], [
    element("text",
      [attr("x", 50), attr("y", 35),
       attr("text-anchor", "middle"),
       attr("font-size", 8),
       attr("fill", "white"),
       attr("font-family", "sans-serif")],
      [text("Flappy Bird")]),
    element("text",
      [attr("x", 50), attr("y", 55),
       attr("text-anchor", "middle"),
       attr("font-size", 4),
       attr("fill", "white"),
       attr("font-family", "sans-serif")],
      [text("Click to start")])])
  else if screen == dead then element("g", [], [
    element("rect",
      [attr("x", 20), attr("y", 25),
       attr("width", 60), attr("height", 40),
       attr("fill", "rgba(0,0,0,0.5)"),
       attr("rx", 3)], []),
    element("text",
      [attr("x", 50), attr("y", 38),
       attr("text-anchor", "middle"),
       attr("font-size", 6),
       attr("fill", "#e74c3c"),
       attr("font-family", "sans-serif")],
      [text("Game Over")]),
    element("text",
      [attr("x", 50), attr("y", 48),
       attr("text-anchor", "middle"),
       attr("font-size", 4),
       attr("fill", "white"),
       attr("font-family", "sans-serif")],
      [text("Score: " ++ score())]),
    element("text",
      [attr("x", 50), attr("y", 55),
       attr("text-anchor", "middle"),
       attr("font-size", 4),
       attr("fill", "#f7dc6f"),
       attr("font-family", "sans-serif")],
      [text("Best: " ++ best)]),
    element("text",
      [attr("x", 50), attr("y", 62),
       attr("text-anchor", "middle"),
       attr("font-size", 3),
       attr("fill", "#bbb"),
       attr("font-family", "sans-serif")],
      [text("Click to restart")])])
  else element("g", [], [
    element("text",
      [attr("x", 50), attr("y", 10),
       attr("text-anchor", "middle"),
       attr("font-size", 6),
       attr("fill", "white"),
       attr("font-family", "sans-serif"),
       attr("font-weight", "bold")],
      [text(score())])])

# ── Debug overlay: renders all debug(...) dynamic rules ──
# Meta rules write: rule(debug_KEY, debug(element(...)))
# query_all(debug) collects all values whose head is debug
fn unwrap_debug(cons(debug(?el), ?rest)) = cons(?el, unwrap_debug(?rest))
fn unwrap_debug(nil) = nil

fn render_debug() = element("g", [],
  cons(element("rect",
    [attr("x", 0), attr("y", 0),
     attr("width", 30), attr("height", 23),
     attr("fill", "rgba(0,0,0,0.65)"),
     attr("rx", 1)], []),
  unwrap_debug(query_all(debug))))

init()
`;

const DEFAULT_META = `\
# ── Debug overlay ──
# Write debug(element(...)) values to dynamic rules.
# The game's render_debug() collects them via query_all(debug).

fn dbg_text(?y, ?msg) = element("text",
  [attr("x", 1), attr("y", ?y),
   attr("font-size", 2.2),
   attr("fill", "#0f0"),
   attr("font-family", "monospace")],
  [text(?msg)])

rule debug_info : @meta -> @rules {
  result(?step, score(), ?val) => {
    rule(debug_score, debug(dbg_text(3, "score() -> " ++ ?val)))
    rule(debug_steps, debug(dbg_text(6, "step: " ++ ?step)))
  }
  result(_, handle_event(tick, _), _) => {
    rule(debug_y, debug(dbg_text(9, "y: " ++ player_y)))
    rule(debug_vel, debug(dbg_text(12, "vel: " ++ velocity)))
  }
  result(_, check_ground(), ?val) =>
    rule(debug_ground, debug(dbg_text(15, "check_ground() -> " ++ ?val)))
  result(_, check_pipe_0(), ?val) =>
    rule(debug_pipe0, debug(dbg_text(18, "check_pipe_0() -> " ++ ?val)))
  result(_, check_pipe_1(), ?val) =>
    rule(debug_pipe1, debug(dbg_text(21, "check_pipe_1() -> " ++ ?val)))
}

# ── Chart data: capture function results via meta rules ──

rule track_bird : @meta -> @rules {
  result(_, update_bird(), ?val) =>
    rule(chart_bird_y, take(60, cons(point(distance, ?val), chart_bird_y)))
}

rule track_score : @meta -> @rules {
  result(_, score(), ?val) => {
    rule(chart_score_n, chart_score_n + 1.0)
    rule(chart_score, take(60, cons(point(chart_score_n, ?val), chart_score)))
  }
}

# ── Render scatter plots (called from JS every 6th frame) ──
fn render_charts() = @viz element("div", [attr("class", "viz-row")], [
  render_scatter("update_bird()", chart_bird_y, "#06b6d4"),
  render_scatter("score()", chart_score, "#10b981")])
`;

// ── Elements ──

const statusEl  = document.getElementById('status');
const errorEl   = document.getElementById('error');
const gameEl    = document.getElementById('game');
const vizRowEl  = document.getElementById('viz-row');

// ── WASM module cache ──

let cachedModule = null;

async function freshR4() {
  if (!cachedModule) {
    const resp = await fetch('./rules4.wasm');
    const bytes = await resp.arrayBuffer();
    cachedModule = await WebAssembly.compile(bytes);
  }
  const instance = await WebAssembly.instantiate(cachedModule, {});
  const r4 = new Rules4(instance);
  r4.wasm.engine_new();
  return r4;
}

// ── CodeMirror 6 ──

const { EditorView, basicSetup } = await import('https://esm.sh/codemirror@6.0.1');
const { oneDark } = await import('https://esm.sh/@codemirror/theme-one-dark@6.1.2');
const { StreamLanguage } = await import('https://esm.sh/@codemirror/language@6.10.8');
const { EditorState } = await import('https://esm.sh/@codemirror/state@6');
const { javascript } = await import('https://esm.sh/@codemirror/lang-javascript@6');

// Simple Rules4 syntax highlighting (CM5-style token names for StreamLanguage)
const rules4Lang = StreamLanguage.define({
  token(stream) {
    // Comments
    if (stream.match('#')) { stream.skipToEnd(); return 'comment'; }
    // Strings
    if (stream.match('"')) {
      while (!stream.eol()) {
        if (stream.next() === '"') break;
      }
      return 'string';
    }
    // Numbers (including negative and float)
    if (stream.match(/^-?\d+(\.\d+)?/)) return 'number';
    // Pattern variables (?x, ?name)
    if (stream.match(/^\?[a-zA-Z_]\w*/)) return 'variable-2';
    // Scope annotations (@meta, @viz, @rules, @dom)
    if (stream.match(/^@[a-zA-Z_]\w*/)) return 'meta';
    // Keywords
    if (stream.match(/^(fn|rule|if|then|else|emit)\b/)) return 'keyword';
    // Operators
    if (stream.match(/^(=>|->|==|!=|>=|<=|>|<|\+\+)/)) return 'operator';
    // Builtins / constants
    if (stream.match(/^(retract|query_all|floor|abs|random|mod|add|sub|mul|div|eq|neq|lt|gt|lte|gte|str_concat|str_len|str_join|list_reverse|list_len|true|false|nil|cons|result)\b/)) return 'atom';
    // Identifiers
    if (stream.match(/^[a-zA-Z_]\w*/)) return 'variable';
    // Brackets / punctuation
    if (stream.match(/^[()[\]{},=]/)) return 'bracket';
    stream.next();
    return null;
  },
});

const r4Extensions = [basicSetup, oneDark, rules4Lang];

const chartEditor = new EditorView({
  doc: DEFAULT_CHART,
  extensions: [
    ...r4Extensions,
    EditorView.updateListener.of(update => {
      if (update.docChanged) scheduleRestart();
    }),
  ],
  parent: document.getElementById('editor-chart'),
});

const gameEditor = new EditorView({
  doc: DEFAULT_GAME,
  extensions: [
    ...r4Extensions,
    EditorView.updateListener.of(update => {
      if (update.docChanged) scheduleRestart();
    }),
  ],
  parent: document.getElementById('editor-game'),
});

const metaEditor = new EditorView({
  doc: DEFAULT_META,
  extensions: [
    ...r4Extensions,
    EditorView.updateListener.of(update => {
      if (update.docChanged) scheduleRestart();
    }),
  ],
  parent: document.getElementById('editor-meta'),
});

// ── Support JS editor (read-only, shows bridge.js + vdom.js) ──

const [bridgeSrc, vdomSrc] = await Promise.all([
  fetch('./bridge.js').then(r => r.text()),
  fetch('./vdom.js').then(r => r.text()),
]);

const jsSource = `// ── bridge.js ── Rules4 WASM Bridge\n\n${bridgeSrc}\n\n// ── vdom.js ── Term-to-DOM renderer with diffing\n\n${vdomSrc}`;

const jsEditor = new EditorView({
  doc: jsSource,
  extensions: [
    basicSetup,
    oneDark,
    javascript(),
    EditorState.readOnly.of(true),
  ],
  parent: document.getElementById('editor-js'),
});

// ── Tab switching ──

const editors = { chart: chartEditor, game: gameEditor, meta: metaEditor, js: jsEditor };
const tabBtns = document.querySelectorAll('.tab-btn');
const editorPanes = document.querySelectorAll('.editor-pane');

tabBtns.forEach(btn => {
  btn.addEventListener('click', () => {
    const tab = btn.dataset.tab;
    tabBtns.forEach(b => b.classList.toggle('active', b === btn));
    editorPanes.forEach(p => p.classList.toggle('active', p.id === `editor-${tab}`));
    // Refresh the newly visible editor so it measures correctly
    if (editors[tab]) editors[tab].requestMeasure();
  });
});

// ── Viz rendering (pure Rules4 charts via vdom) ──

let vizTree = null;
let vizTermId = null;

function renderViz(r4) {
  const renderChartsSym = r4.sym("render_charts");
  const call = r4.call(renderChartsSym, []);
  r4.eval(call);

  const pending = r4.scopeTakePending("viz");
  if (pending.length === 0) return;
  const newTermId = pending[pending.length - 1];

  if (vizTree === null) {
    const dom = renderTerm(r4, newTermId, () => {});
    vizRowEl.innerHTML = '';
    vizRowEl.appendChild(dom);
    vizTree = dom;
  } else {
    vizTree = patch(r4, vizTermId, newTermId, vizTree, vizRowEl, () => {});
  }
  vizTermId = newTermId;
}

function clearViz() {
  vizTree = null;
  vizTermId = null;
  vizRowEl.innerHTML = '';
}

// ── FlappyLab: game loop ──

let lab = null;   // current lab instance (survives event wiring)

class FlappyLab {
  constructor(r4) {
    this.r4 = r4;
    this._raf = null;
    this._frame = 0;
    this._tickCount = 0;
    this.currentTree = null;
    this.currentTermId = null;
    this.handleEventSym = r4.sym("handle_event");
    this.renderSym = r4.sym("render");
  }

  refreshSyms() {
    this.handleEventSym = this.r4.sym("handle_event");
    this.renderSym = this.r4.sym("render");
    // Invalidate vdom trees so next render does a full rebuild
    this.currentTree = null;
    this.currentTermId = null;
  }

  start() {
    let tickSym = this.r4.sym("tick");
    const GC_THRESHOLD = 50000;
    const tick = () => {
      try {
        this.r4._nameCache.clear();
        this._frame++;
        this._tickCount++;
        const frameTerm = this.r4.num(this._frame);
        const call = this.r4.call(this.handleEventSym, [tickSym, frameTerm]);
        this.r4.eval(call);
        this.renderGame();
        renderViz(this.r4);
        // GC when term store grows too large
        if (this.r4.termCount() > GC_THRESHOLD) {
          this.r4.gc();
          this.refreshSyms();
          tickSym = this.r4.sym("tick");
          clearViz();
        }
      } catch (e) {
        console.error("[flappy-lab] tick error:", e);
      }
      this._raf = requestAnimationFrame(tick);
    };
    this._raf = requestAnimationFrame(tick);
  }

  stop() {
    if (this._raf != null) {
      cancelAnimationFrame(this._raf);
      this._raf = null;
    }
  }

  sendEvent(sym, payload) {
    const call = this.r4.call(this.handleEventSym, [sym, payload]);
    this.r4.eval(call);
    this.renderGame();
  }

  renderGame() {
    const r4 = this.r4;
    const renderCall = r4.call(this.renderSym, []);
    r4.eval(renderCall);

    const pending = r4.scopeTakePending("dom");
    if (pending.length === 0) return;
    const newTermId = pending[pending.length - 1];

    if (this.currentTree === null) {
      const dom = renderTerm(r4, newTermId, () => {});
      gameEl.innerHTML = '';
      gameEl.appendChild(dom);
      this.currentTree = dom;
    } else {
      this.currentTree = patch(
        r4,
        this.currentTermId,
        newTermId,
        this.currentTree,
        gameEl,
        () => {}
      );
    }
    this.currentTermId = newTermId;
  }
}

// ── Restart logic ──

let restartTimer = null;
let generation = 0;

function scheduleRestart() {
  clearTimeout(restartTimer);
  restartTimer = setTimeout(restart, 600);
}

async function restart() {
  const thisGen = ++generation;
  statusEl.className = 'status-dot loading';

  try {
    // Stop old loop
    if (lab) lab.stop();

    const r4 = await freshR4();
    if (thisGen !== generation) return;

    const code = chartEditor.state.doc.toString() + '\n' + gameEditor.state.doc.toString() + '\n' + metaEditor.state.doc.toString();
    r4.eval(r4.loadProgram(code));
    if (thisGen !== generation) return;

    clearViz();
    lab = new FlappyLab(r4);
    lab.start();

    errorEl.classList.remove('visible');
    statusEl.className = 'status-dot ok';
  } catch (e) {
    if (thisGen !== generation) return;
    errorEl.textContent = e.message;
    errorEl.classList.add('visible');
    statusEl.className = 'status-dot err';
  }
}

// ── Event wiring (once, references `lab`) ──

gameEl.addEventListener('mousedown', (e) => {
  e.preventDefault();
  if (!lab) return;
  const clickSym = lab.r4.sym("click");
  const evSym = lab.r4.sym("mouse");
  lab.sendEvent(clickSym, evSym);
});

document.addEventListener('keydown', (e) => {
  // Don't capture keys when typing in editor
  if (e.target.closest('.cm-editor')) return;
  if (e.code === 'Space' || e.code === 'Enter') {
    e.preventDefault();
    if (!lab) return;
    const clickSym = lab.r4.sym("click");
    const evSym = lab.r4.sym("key");
    lab.sendEvent(clickSym, evSym);
  }
});

// ── Initial boot ──

await restart();
</script>
</body>
</html>
