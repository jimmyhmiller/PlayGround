/* automatically generated by rust-bindgen */

pub type size_t = ::std::os::raw::c_ulong;
pub type Value = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ValueArray {
    pub capacity: ::std::os::raw::c_int,
    pub count: ::std::os::raw::c_int,
    pub values: *mut Value,
}
#[test]
fn bindgen_test_layout_ValueArray() {
    assert_eq!(
        ::std::mem::size_of::<ValueArray>(),
        16usize,
        concat!("Size of: ", stringify!(ValueArray))
    );
    assert_eq!(
        ::std::mem::align_of::<ValueArray>(),
        8usize,
        concat!("Alignment of ", stringify!(ValueArray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ValueArray>())).capacity as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ValueArray),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ValueArray>())).count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ValueArray),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ValueArray>())).values as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ValueArray),
            "::",
            stringify!(values)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Chunk {
    pub count: ::std::os::raw::c_int,
    pub capacity: ::std::os::raw::c_int,
    pub code: *mut u8,
    pub lines: *mut ::std::os::raw::c_int,
    pub constants: ValueArray,
}
#[test]
fn bindgen_test_layout_Chunk() {
    assert_eq!(
        ::std::mem::size_of::<Chunk>(),
        40usize,
        concat!("Size of: ", stringify!(Chunk))
    );
    assert_eq!(
        ::std::mem::align_of::<Chunk>(),
        8usize,
        concat!("Alignment of ", stringify!(Chunk))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Chunk>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Chunk),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Chunk>())).capacity as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Chunk),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Chunk>())).code as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Chunk),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Chunk>())).lines as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Chunk),
            "::",
            stringify!(lines)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Chunk>())).constants as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Chunk),
            "::",
            stringify!(constants)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Entry {
    pub key: *mut ObjString,
    pub value: Value,
}
#[test]
fn bindgen_test_layout_Entry() {
    assert_eq!(
        ::std::mem::size_of::<Entry>(),
        16usize,
        concat!("Size of: ", stringify!(Entry))
    );
    assert_eq!(
        ::std::mem::align_of::<Entry>(),
        8usize,
        concat!("Alignment of ", stringify!(Entry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Entry>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Entry),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Entry>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Entry),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Table {
    pub count: ::std::os::raw::c_int,
    pub capacity: ::std::os::raw::c_int,
    pub entries: *mut Entry,
}
#[test]
fn bindgen_test_layout_Table() {
    assert_eq!(
        ::std::mem::size_of::<Table>(),
        16usize,
        concat!("Size of: ", stringify!(Table))
    );
    assert_eq!(
        ::std::mem::align_of::<Table>(),
        8usize,
        concat!("Alignment of ", stringify!(Table))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Table>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Table),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Table>())).capacity as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Table),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Table>())).entries as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Table),
            "::",
            stringify!(entries)
        )
    );
}
pub const ObjType_OBJ_BOUND_METHOD: ObjType = 0;
pub const ObjType_OBJ_CLASS: ObjType = 1;
pub const ObjType_OBJ_CLOSURE: ObjType = 2;
pub const ObjType_OBJ_FUNCTION: ObjType = 3;
pub const ObjType_OBJ_INSTANCE: ObjType = 4;
pub const ObjType_OBJ_NATIVE: ObjType = 5;
pub const ObjType_OBJ_STRING: ObjType = 6;
pub const ObjType_OBJ_UPVALUE: ObjType = 7;
pub type ObjType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Obj {
    pub type_: ObjType,
    pub isMarked: bool,
    pub next: *mut Obj,
}
#[test]
fn bindgen_test_layout_Obj() {
    assert_eq!(
        ::std::mem::size_of::<Obj>(),
        16usize,
        concat!("Size of: ", stringify!(Obj))
    );
    assert_eq!(
        ::std::mem::align_of::<Obj>(),
        8usize,
        concat!("Alignment of ", stringify!(Obj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Obj>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Obj),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Obj>())).isMarked as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Obj),
            "::",
            stringify!(isMarked)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Obj>())).next as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(Obj), "::", stringify!(next))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ObjFunction {
    pub obj: Obj,
    pub arity: ::std::os::raw::c_int,
    pub upvalueCount: ::std::os::raw::c_int,
    pub chunk: Chunk,
    pub name: *mut ObjString,
}
#[test]
fn bindgen_test_layout_ObjFunction() {
    assert_eq!(
        ::std::mem::size_of::<ObjFunction>(),
        72usize,
        concat!("Size of: ", stringify!(ObjFunction))
    );
    assert_eq!(
        ::std::mem::align_of::<ObjFunction>(),
        8usize,
        concat!("Alignment of ", stringify!(ObjFunction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ObjFunction>())).obj as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjFunction),
            "::",
            stringify!(obj)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ObjFunction>())).arity as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjFunction),
            "::",
            stringify!(arity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ObjFunction>())).upvalueCount as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjFunction),
            "::",
            stringify!(upvalueCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ObjFunction>())).chunk as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjFunction),
            "::",
            stringify!(chunk)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ObjFunction>())).name as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjFunction),
            "::",
            stringify!(name)
        )
    );
}
pub type NativeFn = ::std::option::Option<
    unsafe extern "C" fn(argCount: ::std::os::raw::c_int, args: *mut Value) -> Value,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ObjNative {
    pub obj: Obj,
    pub function: NativeFn,
}
#[test]
fn bindgen_test_layout_ObjNative() {
    assert_eq!(
        ::std::mem::size_of::<ObjNative>(),
        24usize,
        concat!("Size of: ", stringify!(ObjNative))
    );
    assert_eq!(
        ::std::mem::align_of::<ObjNative>(),
        8usize,
        concat!("Alignment of ", stringify!(ObjNative))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ObjNative>())).obj as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjNative),
            "::",
            stringify!(obj)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ObjNative>())).function as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjNative),
            "::",
            stringify!(function)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ObjString {
    pub obj: Obj,
    pub length: ::std::os::raw::c_int,
    pub chars: *mut ::std::os::raw::c_char,
    pub hash: u32,
}
#[test]
fn bindgen_test_layout_ObjString() {
    assert_eq!(
        ::std::mem::size_of::<ObjString>(),
        40usize,
        concat!("Size of: ", stringify!(ObjString))
    );
    assert_eq!(
        ::std::mem::align_of::<ObjString>(),
        8usize,
        concat!("Alignment of ", stringify!(ObjString))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ObjString>())).obj as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjString),
            "::",
            stringify!(obj)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ObjString>())).length as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjString),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ObjString>())).chars as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjString),
            "::",
            stringify!(chars)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ObjString>())).hash as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjString),
            "::",
            stringify!(hash)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ObjUpvalue {
    pub obj: Obj,
    pub location: *mut Value,
    pub closed: Value,
    pub next: *mut ObjUpvalue,
}
#[test]
fn bindgen_test_layout_ObjUpvalue() {
    assert_eq!(
        ::std::mem::size_of::<ObjUpvalue>(),
        40usize,
        concat!("Size of: ", stringify!(ObjUpvalue))
    );
    assert_eq!(
        ::std::mem::align_of::<ObjUpvalue>(),
        8usize,
        concat!("Alignment of ", stringify!(ObjUpvalue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ObjUpvalue>())).obj as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjUpvalue),
            "::",
            stringify!(obj)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ObjUpvalue>())).location as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjUpvalue),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ObjUpvalue>())).closed as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjUpvalue),
            "::",
            stringify!(closed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ObjUpvalue>())).next as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjUpvalue),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ObjClosure {
    pub obj: Obj,
    pub function: *mut ObjFunction,
    pub upvalues: *mut *mut ObjUpvalue,
    pub upvalueCount: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ObjClosure() {
    assert_eq!(
        ::std::mem::size_of::<ObjClosure>(),
        40usize,
        concat!("Size of: ", stringify!(ObjClosure))
    );
    assert_eq!(
        ::std::mem::align_of::<ObjClosure>(),
        8usize,
        concat!("Alignment of ", stringify!(ObjClosure))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ObjClosure>())).obj as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjClosure),
            "::",
            stringify!(obj)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ObjClosure>())).function as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjClosure),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ObjClosure>())).upvalues as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjClosure),
            "::",
            stringify!(upvalues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ObjClosure>())).upvalueCount as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjClosure),
            "::",
            stringify!(upvalueCount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ObjClass {
    pub obj: Obj,
    pub name: *mut ObjString,
    pub methods: Table,
}
#[test]
fn bindgen_test_layout_ObjClass() {
    assert_eq!(
        ::std::mem::size_of::<ObjClass>(),
        40usize,
        concat!("Size of: ", stringify!(ObjClass))
    );
    assert_eq!(
        ::std::mem::align_of::<ObjClass>(),
        8usize,
        concat!("Alignment of ", stringify!(ObjClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ObjClass>())).obj as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjClass),
            "::",
            stringify!(obj)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ObjClass>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjClass),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ObjClass>())).methods as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjClass),
            "::",
            stringify!(methods)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ObjInstance {
    pub obj: Obj,
    pub klass: *mut ObjClass,
    pub fields: Table,
}
#[test]
fn bindgen_test_layout_ObjInstance() {
    assert_eq!(
        ::std::mem::size_of::<ObjInstance>(),
        40usize,
        concat!("Size of: ", stringify!(ObjInstance))
    );
    assert_eq!(
        ::std::mem::align_of::<ObjInstance>(),
        8usize,
        concat!("Alignment of ", stringify!(ObjInstance))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ObjInstance>())).obj as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjInstance),
            "::",
            stringify!(obj)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ObjInstance>())).klass as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjInstance),
            "::",
            stringify!(klass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ObjInstance>())).fields as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjInstance),
            "::",
            stringify!(fields)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ObjBoundMethod {
    pub obj: Obj,
    pub receiver: Value,
    pub method: *mut ObjClosure,
}
#[test]
fn bindgen_test_layout_ObjBoundMethod() {
    assert_eq!(
        ::std::mem::size_of::<ObjBoundMethod>(),
        32usize,
        concat!("Size of: ", stringify!(ObjBoundMethod))
    );
    assert_eq!(
        ::std::mem::align_of::<ObjBoundMethod>(),
        8usize,
        concat!("Alignment of ", stringify!(ObjBoundMethod))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ObjBoundMethod>())).obj as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjBoundMethod),
            "::",
            stringify!(obj)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ObjBoundMethod>())).receiver as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjBoundMethod),
            "::",
            stringify!(receiver)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ObjBoundMethod>())).method as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjBoundMethod),
            "::",
            stringify!(method)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CallFrame {
    pub closure: *mut ObjClosure,
    pub ip: *mut u8,
    pub slots: *mut Value,
}
#[test]
fn bindgen_test_layout_CallFrame() {
    assert_eq!(
        ::std::mem::size_of::<CallFrame>(),
        24usize,
        concat!("Size of: ", stringify!(CallFrame))
    );
    assert_eq!(
        ::std::mem::align_of::<CallFrame>(),
        8usize,
        concat!("Alignment of ", stringify!(CallFrame))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CallFrame>())).closure as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CallFrame),
            "::",
            stringify!(closure)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CallFrame>())).ip as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CallFrame),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CallFrame>())).slots as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CallFrame),
            "::",
            stringify!(slots)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VM {
    pub frames: [CallFrame; 64usize],
    pub frameCount: ::std::os::raw::c_int,
    pub stack: [Value; 16384usize],
    pub stackTop: *mut Value,
    pub globals: Table,
    pub strings: Table,
    pub initString: *mut ObjString,
    pub openUpvalues: *mut ObjUpvalue,
    pub bytesAllocated: size_t,
    pub nextGC: size_t,
    pub objects: *mut Obj,
    pub grayCount: ::std::os::raw::c_int,
    pub grayCapacity: ::std::os::raw::c_int,
    pub grayStack: *mut *mut Obj,
}
#[test]
fn bindgen_test_layout_VM() {
    assert_eq!(
        ::std::mem::size_of::<VM>(),
        132712usize,
        concat!("Size of: ", stringify!(VM))
    );
    assert_eq!(
        ::std::mem::align_of::<VM>(),
        8usize,
        concat!("Alignment of ", stringify!(VM))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VM>())).frames as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VM),
            "::",
            stringify!(frames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VM>())).frameCount as *const _ as usize },
        1536usize,
        concat!(
            "Offset of field: ",
            stringify!(VM),
            "::",
            stringify!(frameCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VM>())).stack as *const _ as usize },
        1544usize,
        concat!("Offset of field: ", stringify!(VM), "::", stringify!(stack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VM>())).stackTop as *const _ as usize },
        132616usize,
        concat!(
            "Offset of field: ",
            stringify!(VM),
            "::",
            stringify!(stackTop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VM>())).globals as *const _ as usize },
        132624usize,
        concat!(
            "Offset of field: ",
            stringify!(VM),
            "::",
            stringify!(globals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VM>())).strings as *const _ as usize },
        132640usize,
        concat!(
            "Offset of field: ",
            stringify!(VM),
            "::",
            stringify!(strings)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VM>())).initString as *const _ as usize },
        132656usize,
        concat!(
            "Offset of field: ",
            stringify!(VM),
            "::",
            stringify!(initString)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VM>())).openUpvalues as *const _ as usize },
        132664usize,
        concat!(
            "Offset of field: ",
            stringify!(VM),
            "::",
            stringify!(openUpvalues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VM>())).bytesAllocated as *const _ as usize },
        132672usize,
        concat!(
            "Offset of field: ",
            stringify!(VM),
            "::",
            stringify!(bytesAllocated)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VM>())).nextGC as *const _ as usize },
        132680usize,
        concat!(
            "Offset of field: ",
            stringify!(VM),
            "::",
            stringify!(nextGC)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VM>())).objects as *const _ as usize },
        132688usize,
        concat!(
            "Offset of field: ",
            stringify!(VM),
            "::",
            stringify!(objects)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VM>())).grayCount as *const _ as usize },
        132696usize,
        concat!(
            "Offset of field: ",
            stringify!(VM),
            "::",
            stringify!(grayCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VM>())).grayCapacity as *const _ as usize },
        132700usize,
        concat!(
            "Offset of field: ",
            stringify!(VM),
            "::",
            stringify!(grayCapacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VM>())).grayStack as *const _ as usize },
        132704usize,
        concat!(
            "Offset of field: ",
            stringify!(VM),
            "::",
            stringify!(grayStack)
        )
    );
}
pub const InterpretResult_INTERPRET_OK: InterpretResult = 0;
pub const InterpretResult_INTERPRET_COMPILE_ERROR: InterpretResult = 1;
pub const InterpretResult_INTERPRET_RUNTIME_ERROR: InterpretResult = 2;
pub type InterpretResult = u32;
