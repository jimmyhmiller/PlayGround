struct Thing {
    x
}


struct TreeNode {
    left
    right
}

fn print_endlessly(message, x) {
    println(message)
    println(x)
    print_endlessly(message, x)
}

fn testGc(n) {
    if n > 10 {
        0
    } else {
        let x = TreeNode {
            left: null
            right: null
        }
        1 + testGc(n + 1)

        let y = TreeNode {
            left: x,
            right: x
        }

        1 + testGc(n + 1)

        let z = TreeNode {
            left: y,
            right: y,
        }
        println(x)
        println(y)
        println(z)
        0
    }
}

fn print_endlessly_gc(message, x) {
    println(message)
    println(x)
    // TODO: This is causing gc issues
    // Even without another thread
    // gc()
    print_endlessly_gc(message, x)
}

// TODO: Move this. I am using this inside of new_thread right now
// It is clever, but needs to not exist in this file
// Maybe I load std.bg always? And then I put something like this in there?
// This is just apply without arguments
fn call_closure(f) {
    f()
}

fn call_function() {
    // Doing this because locals live for the whole function
     let x = Thing { x: 42 };

    let f = fn() { print_endlessly("in thread", x) };
    thread(f);
}

// You can see that thing get's replaced by one of these nodes
// This is because the gc is not working correctly with concurrency
fn main() {
    call_function()
    testGc(0)
    testGc(0)
    testGc(0)
    testGc(0)
    testGc(0)
    testGc(0)
    testGc(0)
    testGc(0)
    testGc(0)
    testGc(0)
    testGc(0)
    testGc(0)
    testGc(0)
    testGc(0)
    
    "done"
}