(ns testing-stuff.core
  (:require [clojure.math.numeric-tower :as math]))
(sqrt 2)
(math\sqrt 2)
(math/sqrt 2)
(ns testing-stuff.core
  (:require [clojure.math.numeric-tower :only sqrt]))
(use '[clojure.math.numeric-tower :only [sqrt]])
(defn list-of-primes [n]
  (loop [i 3
         sieve (transient (vec (replicate n 0)))
         ]
    (cond
     (> i (int (sqrt n))) (cons 2 (filter #(= (get sieve %) 0) (range 3 n 2)))
     (= (get sieve i) 0)
     (recur (+ i 2) (apply assoc! sieve (interleave (range (* i i) n (* i 2)) (repeat 1)))
    )
 :else (recur (+ i 2) sieve)
 ))
  )
(time (list-of-primes 1000000))
(defn primes-to [n]
  (let [#^booleans sieve (boolean-array (inc n) true)
        n (int n)]
    (loop [p (int 2)]
      (let [pp (unchecked-multiply p p)]
        (if (> pp n)
          (filter identity (map #(if %1 %2) (drop 2 sieve) (iterate inc 2)))
          (do
            (loop [i pp]
              (aset sieve i false)
              (let [j (unchecked-add i p)]
                (if (<= j n)
                  (recur j))))
            (let [q (int
                      (loop [p (unchecked-inc p)]
                        (if (aget sieve p)
                          p
                          (recur (unchecked-inc p)))))]
              (recur q))))))))
(time (primes-to 1000000))
(use 'testing-stuff.core)
(doc list-of-primes)
(source map)
(use 'testing-stuff.core)
(doc list-of-primes)
(list-of-primes 100)
(source map)
(list-of-primes 100)
(doc list-of-primes)
(use 'testing-stuff.core)
(doc list-of-primes)
(list-of-primes 100)
(source map)
(use 'testing-stuff.core)
(doc list-of-primes)
(doc map)
