# MLSP IRDL Heterogeneous Operands - SOLVED! ✓

**Date**: 2025-01-05
**Status**: WORKING

---

## Problem

We couldn't define `mlsp.get_element_dyn` with heterogeneous operands:
```
mlsp.get_element_dyn(%list: !llvm.ptr, %index: i64) -> !llvm.ptr
```

Our attempts in lisp syntax kept failing with segfaults or type errors.

---

## Solution

**The issue was our lisp representation, NOT IRDL itself!**

Heterogeneous operands work perfectly in IRDL when you:

1. **Pass multiple constraint SSA values** to `irdl.operands`
2. **Provide matching names array**
3. **Provide matching variadicity array with one entry per constraint**

### Working Generic MLIR Syntax

```mlir
"irdl.operation"() <{sym_name = "get_element_dyn"}> ({
  %ptr_constraint = "irdl.is"() <{expected = !llvm.ptr}> : () -> !irdl.attribute
  %i64_constraint = "irdl.is"() <{expected = i64}> : () -> !irdl.attribute

  "irdl.operands"(%ptr_constraint, %i64_constraint) <{
    names = ["list", "index"],
    variadicity = #irdl<variadicity_array[ single,  single]>
  }> : (!irdl.attribute, !irdl.attribute) -> ()

  "irdl.results"(%ptr_constraint) <{
    names = ["result"],
    variadicity = #irdl<variadicity_array[ single]>
  }> : (!irdl.attribute) -> ()
})
```

### Key Insight

The variadicity array has **one entry per operand**, not one entry total:

```mlir
// WRONG (what we tried)
variadicity = #irdl<variadicity_array[ single single]>  // Two words, one entry

// CORRECT
variadicity = #irdl<variadicity_array[ single,  single]>  // Comma-separated entries
```

---

## Files Created

### 1. `examples/mlsp_dialect.mlir` (MLIR textual syntax)

Clean MLIR syntax that validates with mlir-opt:

```mlir
irdl.dialect @mlsp {
  irdl.operation @get_element_dyn {
    %ptr_type = irdl.is !llvm.ptr
    %i64_type = irdl.is i64
    irdl.operands(list: %ptr_type, index: %i64_type)
    irdl.results(result: %ptr_type)
  }
}
```

**Status**: ✓ Validates with `mlir-opt`

### 2. `examples/mlsp_dialect_generic.mlir` (Generic format)

The canonical generic MLIR format showing exactly what IRDL produces:

```mlir
"irdl.operands"(%1, %2) <{
  names = ["list", "index"],
  variadicity = #irdl<variadicity_array[ single,  single]>
}> : (!irdl.attribute, !irdl.attribute) -> ()
```

**Status**: ✓ Generated by mlir-opt, ready to convert to lisp

### 3. `examples/test_mlsp.mlir` (Test application)

Demonstrates using the dialect operations:

```mlir
%idx = arith.constant 1 : i64
%extracted = "mlsp.get_element_dyn"(%list, %idx) : (!llvm.ptr, i64) -> !llvm.ptr
```

**Status**: ✓ Validates and loads the dialect

### 4. `examples/test_mlsp_generic.mlir` (Test in generic format)

Shows the test application in canonical generic format.

**Status**: ✓ Generated by mlir-opt

---

## Next Steps for Lisp Syntax

We need to update our lisp syntax to properly represent the comma-separated variadicity array:

### Current (Broken)

```lisp
(operation
  (name irdl.operands)
  (attributes {:names ["list" "index"]
               :variadicity #irdl<variadicity_array[ single single]>})
  (operands %ptr_type %i64_type))
```

### Fixed (Should Work)

```lisp
(operation
  (name irdl.operands)
  (attributes {:names ["list" "index"]
               :variadicity #irdl<variadicity_array[ single, single]>})
  (operands %ptr_type %i64_type))
```

**The comma matters!** Without it, MLIR parser treats it as malformed.

---

## All Defined Operations

From `mlsp_dialect_generic.mlir`:

### 1. mlsp.identifier
```mlir
"mlsp.identifier"() {value = "name"} : () -> !llvm.ptr
```

### 2. mlsp.list
```mlir
"mlsp.list"(%elem1, %elem2, %elem3) : (!llvm.ptr, !llvm.ptr, !llvm.ptr) -> !llvm.ptr
```

### 3. mlsp.get_element (with attribute)
```mlir
"mlsp.get_element"(%list) {index = 0 : i64} : (!llvm.ptr) -> !llvm.ptr
```

### 4. mlsp.get_element_dyn (with dynamic operand) ✓ NEW!
```mlir
%idx = arith.constant 1 : i64
"mlsp.get_element_dyn"(%list, %idx) : (!llvm.ptr, i64) -> !llvm.ptr
```

### 5. mlsp.build_operation
```mlir
"mlsp.build_operation"(%name, %types, %operands) : (!llvm.ptr, !llvm.ptr, !llvm.ptr) -> !llvm.ptr
```

---

## Validation Results

### mlir-opt validation
```bash
$ mlir-opt examples/mlsp_dialect.mlir
✓ SUCCESS - Dialect loads

$ mlir-opt examples/test_mlsp.mlir --irdl-file=examples/mlsp_dialect.mlir
✓ SUCCESS - All operations validate
```

### Generated Generic Format
```bash
$ mlir-opt examples/mlsp_dialect.mlir --mlir-print-op-generic > examples/mlsp_dialect_generic.mlir
✓ SUCCESS - Generic format generated

$ mlir-opt examples/test_mlsp.mlir --irdl-file=examples/mlsp_dialect.mlir --mlir-print-op-generic > examples/test_mlsp_generic.mlir
✓ SUCCESS - Test with dialect in generic format
```

---

## Comparison: What Changed

### Before (Broken)
- Tried separate `irdl.operands` operations
- Tried variadicity without commas: `[ single single]`
- Tried variadic with union types `irdl.any_of`
- All resulted in segfaults or type errors

### After (Working) ✓
- Single `irdl.operands` with multiple constraint SSA values
- Comma-separated variadicity: `[ single, single]`
- Each operand has its own type constraint
- Clean, validated syntax

---

## Updated Understanding of IRDL

### Operands Syntax

```mlir
"irdl.operands"(
  %constraint1,
  %constraint2,
  %constraint3
) <{
  names = ["name1", "name2", "name3"],
  variadicity = #irdl<variadicity_array[ modifier1, modifier2, modifier3]>
}> : (!irdl.attribute, !irdl.attribute, !irdl.attribute) -> ()
```

Where each modifier is:
- `single` - exactly one operand
- `optional` - zero or one operand
- `variadic` - zero or more operands

### Key Rules

1. **Number of constraints = Number of names = Number of variadicity entries**
2. **Commas required in variadicity array**
3. **Constraints can be different types** (heterogeneous!)
4. **Works perfectly in IRDL** - limitation was our representation

---

## Conclusion

**IRDL supports heterogeneous operands perfectly!**

The problem was:
1. Our lisp syntax didn't handle comma-separated variadicity arrays
2. We didn't realize multiple SSA values could be passed to `irdl.operands`

The solution:
1. Use proper MLIR generic format with commas: `[ single, single]`
2. Pass multiple constraint SSA values: `(%constraint1, %constraint2)`
3. Match names and variadicity arrays to constraint count

**Next action**: Update our lisp parser/printer to handle comma-separated variadicity arrays properly, or just use the generic MLIR format directly!

---

## Files Summary

| File | Format | Status | Purpose |
|------|--------|--------|---------|
| `examples/mlsp_dialect.mlir` | MLIR textual | ✓ Valid | Human-readable dialect definition |
| `examples/mlsp_dialect_generic.mlir` | Generic MLIR | ✓ Valid | Canonical format for conversion to lisp |
| `examples/test_mlsp.mlir` | MLIR textual | ✓ Valid | Test application code |
| `examples/test_mlsp_generic.mlir` | Generic MLIR | ✓ Valid | Test in generic format |

All files validate with `mlir-opt` and demonstrate working heterogeneous operands!
