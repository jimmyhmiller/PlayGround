/// JIT Executor for MLIR
/// Manages lowering passes and JIT compilation of MLIR modules
const std = @import("std");
const mlir = @import("mlir/c.zig");

pub const ExecutorError = error{
    PassManagerCreationFailed,
    ExecutionEngineCreationFailed,
    LoweringFailed,
    InvokeFailed,
    PatternApplicationFailed,
} || std.mem.Allocator.Error;

pub const OptLevel = enum(u32) {
    O0 = 0,
    O1 = 1,
    O2 = 2,
    O3 = 3,
};

/// Configuration for the executor
pub const ExecutorConfig = struct {
    /// Optimization level (O0, O1, O2, O3)
    opt_level: OptLevel = .O0,

    /// Whether to enable the verifier after passes
    enable_verifier: bool = true,

    /// Shared library paths for external symbols
    shared_lib_paths: []const []const u8 = &.{},

    /// Whether to dump object files for debugging
    enable_object_dump: bool = false,
};

/// JIT executor for MLIR modules
pub const Executor = struct {
    allocator: std.mem.Allocator,
    ctx: *mlir.Context,
    config: ExecutorConfig,
    engine: ?mlir.ExecutionEngine,
    /// Optional transform operations to apply before lowering
    transform_ops: []const mlir.MlirOperation,

    pub fn init(allocator: std.mem.Allocator, ctx: *mlir.Context, config: ExecutorConfig) Executor {
        return Executor{
            .allocator = allocator,
            .ctx = ctx,
            .config = config,
            .engine = null,
            .transform_ops = &.{},
        };
    }

    /// Set transform operations to apply during compilation
    pub fn setTransforms(self: *Executor, transforms: []const mlir.MlirOperation) void {
        self.transform_ops = transforms;
    }

    pub fn deinit(self: *Executor) void {
        if (self.engine) |*eng| {
            eng.destroy();
        }
    }

    /// Apply transform dialect operations to the module using PDL patterns
    /// This extracts PDL patterns and applies them using the greedy rewriter
    /// transformOps: Array of transform operations (should contain PDL patterns)
    pub fn applyTransforms(
        self: *Executor,
        module: *mlir.Module,
        transformOps: []const mlir.MlirOperation,
    ) !void {
        if (transformOps.len == 0) {
            return;
        }

        std.debug.print("  Applying {} transform operation(s) via PDL...\n", .{transformOps.len});

        // Create a temporary module to hold the PDL patterns
        const location = mlir.Location.unknown(self.ctx);
        var pdl_module = try mlir.Module.create(location);
        defer pdl_module.destroy();

        // Extract and clone PDL patterns from transform operations
        const pdl_mod_body = pdl_module.getBody();
        for (transformOps) |transform_op| {
            try self.extractPDLPatterns(transform_op, pdl_mod_body);
        }

        // If no PDL patterns were found, skip
        if (mlir.c.mlirOperationIsNull(mlir.c.mlirBlockGetFirstOperation(pdl_mod_body))) {
            std.debug.print("  No PDL patterns found, skipping transform\n", .{});
            return;
        }

        std.debug.print("  PDL pattern module:\n", .{});
        pdl_module.print();

        std.debug.print("  Module before PDL patterns:\n", .{});
        module.print();

        // Create PDLPatternModule from the module containing PDL patterns
        const pdl_pattern_module = mlir.c.mlirPDLPatternModuleFromModule(pdl_module.module);
        defer mlir.c.mlirPDLPatternModuleDestroy(pdl_pattern_module);

        // Convert to RewritePatternSet
        const pattern_set = mlir.c.mlirRewritePatternSetFromPDLPatternModule(pdl_pattern_module);

        // Freeze the pattern set (compiles PDL to bytecode)
        const frozen_patterns = mlir.c.mlirFreezeRewritePattern(pattern_set);
        defer mlir.c.mlirFrozenRewritePatternSetDestroy(frozen_patterns);

        // Create a greedy rewrite config (use defaults)
        const config = mlir.c.MlirGreedyRewriteDriverConfig{ .ptr = null };

        // Apply patterns greedily
        const result = mlir.c.mlirApplyPatternsAndFoldGreedily(
            module.module,
            frozen_patterns,
            config,
        );

        if (mlir.c.mlirLogicalResultIsFailure(result)) {
            std.debug.print("  ✗ PDL pattern application failed\n", .{});
            return error.PatternApplicationFailed;
        }

        std.debug.print("  Module after PDL patterns:\n", .{});
        module.print();
        std.debug.print("  ✓ PDL patterns applied successfully\n", .{});
    }

    /// Extract PDL patterns from a transform operation and add them to the target block
    /// Recursively searches through transform.with_pdl_patterns operations
    fn extractPDLPatterns(
        self: *Executor,
        op: mlir.MlirOperation,
        target_block: mlir.MlirBlock,
    ) !void {
        // Check if this is a pdl.pattern operation - if so, clone it directly
        const op_name_id = mlir.c.mlirOperationGetName(op);
        const op_name_ref = mlir.c.mlirIdentifierStr(op_name_id);
        const op_name_str = op_name_ref.data[0..op_name_ref.length];

        if (std.mem.eql(u8, op_name_str, "pdl.pattern")) {
            const cloned = mlir.c.mlirOperationClone(op);
            mlir.c.mlirBlockAppendOwnedOperation(target_block, cloned);
            return;
        }

        // Recursively search regions for PDL patterns
        const num_regions = mlir.c.mlirOperationGetNumRegions(op);
        var i: usize = 0;
        while (i < num_regions) : (i += 1) {
            const region = mlir.c.mlirOperationGetRegion(op, @intCast(i));

            // Iterate through blocks in the region
            var block = mlir.c.mlirRegionGetFirstBlock(region);
            while (!mlir.c.mlirBlockIsNull(block)) {
                // Iterate through operations in the block
                var block_op = mlir.c.mlirBlockGetFirstOperation(block);
                while (!mlir.c.mlirOperationIsNull(block_op)) {
                    try self.extractPDLPatterns(block_op, target_block);
                    block_op = mlir.c.mlirOperationGetNextInBlock(block_op);
                }

                block = mlir.c.mlirBlockGetNextInRegion(block);
            }
        }
    }

    /// Apply lowering passes to convert high-level MLIR to LLVM IR
    /// This uses a standard lowering pipeline:
    /// 1. Convert func/arith/scf/cf to lower level dialects
    /// 2. Convert everything to LLVM dialect
    /// 3. Optimize if requested
    pub fn lowerToLLVM(self: *Executor, module: *mlir.Module) !void {
        var pm = try mlir.PassManager.create(self.ctx);
        defer pm.destroy();

        pm.enableVerifier(self.config.enable_verifier);

        // Build the lowering pipeline - note func passes must be nested in func.func()
        // Must be null-terminated for C API
        // Added convert-scf-to-cf to support structured control flow (scf.if, scf.while, etc.)
        // Added convert-cf-to-llvm to convert control flow to LLVM
        // Added finalize-memref-to-llvm to convert memref operations to LLVM
        const pipeline: [:0]const u8 = "builtin.module(func.func(convert-scf-to-cf,convert-arith-to-llvm),convert-cf-to-llvm,finalize-memref-to-llvm,convert-func-to-llvm,reconcile-unrealized-casts)";

        try pm.addPipeline(pipeline);

        // Run the passes
        try pm.run(module);
    }

    /// Compile the MLIR module and create an execution engine
    pub fn compile(self: *Executor, module: *mlir.Module) !void {
        // First, apply transforms if any were set
        if (self.transform_ops.len > 0) {
            try self.applyTransforms(module, self.transform_ops);
        }

        // Then, lower to LLVM IR
        try self.lowerToLLVM(module);

        // Create execution engine config
        const engine_config = mlir.ExecutionEngine.Config{
            .opt_level = @intFromEnum(self.config.opt_level),
            .shared_lib_paths = self.config.shared_lib_paths,
            .enable_object_dump = self.config.enable_object_dump,
        };

        // Create the execution engine
        self.engine = try mlir.ExecutionEngine.create(module, engine_config);
    }

    /// Invoke a function by name with packed arguments
    /// The function must have been compiled with llvm.emit_c_interface attribute
    pub fn invokePacked(self: *Executor, name: []const u8, args: ?*anyopaque) !void {
        const eng = self.engine orelse return error.ExecutionEngineNotCreated;
        try eng.invokePacked(name, args);
    }

    /// Look up a function pointer by name
    pub fn lookup(self: *const Executor, name: []const u8) ?*anyopaque {
        const eng = self.engine orelse return null;
        return eng.lookup(name);
    }

    /// Register an external symbol that can be called from JIT'd code
    /// Useful for registering C library functions like printf, malloc, etc.
    pub fn registerSymbol(self: *Executor, name: []const u8, sym: *anyopaque) void {
        if (self.engine) |*eng| {
            eng.registerSymbol(name, sym);
        }
    }

    /// Dump the compiled module to an object file
    pub fn dumpToObjectFile(self: *Executor, filename: []const u8) void {
        if (self.engine) |eng| {
            eng.dumpToObjectFile(filename);
        }
    }
};

/// Helper to register common C library functions
pub fn registerCommonCLibraryFunctions(executor: *Executor) void {
    // Register printf, malloc, free directly from std.c
    // These are already C functions, so we can register them directly
    executor.registerSymbol("printf", @ptrCast(&std.c.printf));
    executor.registerSymbol("malloc", @ptrCast(&std.c.malloc));
    executor.registerSymbol("free", @ptrCast(&std.c.free));
}
