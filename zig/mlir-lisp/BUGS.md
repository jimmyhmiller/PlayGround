<!-- 
═══════════════════════════════════════════════════════════════════════
⚠️  WARNING: DO NOT EDIT THIS FILE MANUALLY!
═══════════════════════════════════════════════════════════════════════

This file is managed by bug-tracker CLI tool.
Manual edits may be overwritten or cause parsing errors.

To add, close, or list bugs, use:
    bug-tracker --help

═══════════════════════════════════════════════════════════════════════
-->

# Bugs

This file tracks bugs discovered during development.

## Terse syntax fails with multi-argument function calls [fat-bowed-hawk]

**ID:** fat-bowed-hawk
**Timestamp:** 2025-11-11 22:23:25
**Severity:** high
**Location:** src/parser.zig (parseOperands() at line 916)
**Tags:** parser, terse-syntax, func.call

### Description

When using terse/inline syntax for func.call with multiple arguments (where arguments are nested operations), the parser fails with 'Expected value ID in operands'. Single-argument calls work fine, but two or more arguments cause parsing errors.

### Minimal Reproducing Case

See /tmp/multi_arg_repro.lisp - attempting to call a function that takes two i32 arguments using terse syntax fails

### Code Snippet

```
(: (func.call {:callee @add_two}
              (arith.constant {:value (: 5 i32)})
              (arith.constant {:value (: 7 i32)}))
   i32)
```

---

## paredit-like balance incorrectly moves type annotations inside function calls [radiant-frail-bobolink]

**ID:** radiant-frail-bobolink
**Timestamp:** 2025-11-11 22:24:51
**Severity:** high
**Tags:** paredit, type-annotations, tooling

### Description

When using paredit-like balance on files with type-annotated function calls like (: (func.call ...) type), the balancer moves the type annotation inside the func.call as an extra argument, creating invalid syntax that triggers the multi-argument function call bug

### Minimal Reproducing Case

Write (: (func.call {:callee @foo} arg) i32) and run paredit-like balance - it changes to (func.call {:callee @foo} arg i32) which is incorrect

---

## Segmentation fault during mlirOperationPrint with complex recursive program [flimsy-defiant-dingo]

**ID:** flimsy-defiant-dingo
**Timestamp:** 2025-11-11 22:25:42
**Severity:** critical
**Location:** src/mlir/c.zig (print() at line 118)
**Tags:** mlir, segfault, printing, recursion

### Description

When running examples/complex_math.lisp (10 functions with mutual recursion), parsing and IR building succeeds but MLIR crashes with segfault during print operation. The crash occurs in libMLIR.dylib during mlirOperationPrint.

### Minimal Reproducing Case

Run: ./zig-out/bin/mlir_lisp examples/complex_math.lisp - parsing succeeds, crashes during MLIR print

### Code Snippet

```
c.mlirOperationPrint(op, &printCallback, null);
```

---

